<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>网上冲浪记录</title>
    <url>/2020/06/11/wang-shang-chong-lang-ji-lu/</url>
    <content><![CDATA[<p>依旧相信聚沙成塔，切勿浅尝辄止。</p>
<a id="more"></a>
<h2 id="Java相关"><a href="#Java相关" class="headerlink" title="Java相关"></a>Java相关</h2><hr>
<h2 id="开源框架相关"><a href="#开源框架相关" class="headerlink" title="开源框架相关"></a>开源框架相关</h2><h3 id="1-ES文档"><a href="#1-ES文档" class="headerlink" title="1. ES文档"></a>1. ES文档</h3><h4 id="1-ElasticSearch倒排索引原理"><a href="#1-ElasticSearch倒排索引原理" class="headerlink" title="1. ElasticSearch倒排索引原理"></a>1. <a href="https://www.infoq.cn/article/database-timestamp-01" target="_blank" rel="noopener">ElasticSearch倒排索引原理</a></h4><h4 id="2-Lucene实现原理简要介绍"><a href="#2-Lucene实现原理简要介绍" class="headerlink" title="2. Lucene实现原理简要介绍"></a>2. <a href="https://learnku.com/articles/40398" target="_blank" rel="noopener">Lucene实现原理简要介绍</a></h4><h4 id="3-倒排索引与B-Tree比较"><a href="#3-倒排索引与B-Tree比较" class="headerlink" title="3. 倒排索引与B+Tree比较"></a>3. <a href="https://www.cnblogs.com/luxiaoxun/p/5452502.html" target="_blank" rel="noopener">倒排索引与B+Tree比较</a></h4><p>个人理解，由于es对于索引的开销，索引建立很慢，换来的是索引内存开销低，查询快，所以es更适用于更新不频繁的场景。</p>
<ul>
<li>1）Lucene的Term index和Term Dictionary其实对应的就是MySQL的B+Tree的功能，为关键字key提供索引。Lucene的inverted index可以比MySQL的b-tree检索更快。</li>
<li>2）Term index在内存中是以FST（finite state transducers）的形式保存的，其特点是非常节省内存。所以Lucene搜索一个关键字key的速度是非常快的，而MySQL的B+Tree需要读磁盘比较。</li>
<li>3）Term dictionary在磁盘上是以分block的方式保存的，一个block内部利用公共前缀压缩，比如都是Ab开头的单词就可以把Ab省去。这样Term dictionary可以比B-tree更节约磁盘空间。</li>
<li>4）Lucene对不同的数据类型采用了不同的索引方式，上面分析是针对field为字符串的，比如针对int，有TrieIntField类型，针对经纬度，就可以用GeoHash编码。</li>
<li>5）在 Mysql中给两个字段独立建立的索引无法联合起来使用，必须对联合查询的场景建立复合索引，而Lucene可以任何AND或者OR组合使用索引进行检索。</li>
</ul>
<hr>
<h2 id="日常google"><a href="#日常google" class="headerlink" title="日常google"></a>日常google</h2><h3 id="1-next博客如何添加置顶文章"><a href="#1-next博客如何添加置顶文章" class="headerlink" title="1. next博客如何添加置顶文章"></a>1. <a href="https://blog.csdn.net/qwerty200696/article/details/79010629" target="_blank" rel="noopener">next博客如何添加置顶文章</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm uninstall hexo-generator-index --save</span><br><span class="line">$ npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure>

<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: hexo+GitHub博客搭建实战</span><br><span class="line">date: 2017-09-08 12:00:25</span><br><span class="line">categories: 博客搭建系列</span><br><span class="line">top: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="技术思考"><a href="#技术思考" class="headerlink" title="技术思考"></a>技术思考</h2><h3 id="1-第三方平台使用微信登陆流程"><a href="#1-第三方平台使用微信登陆流程" class="headerlink" title="1. 第三方平台使用微信登陆流程"></a>1. <a href="https://zhuanlan.zhihu.com/p/35099961" target="_blank" rel="noopener">第三方平台使用微信登陆流程</a></h3><hr>
<h2 id="书籍阅读"><a href="#书籍阅读" class="headerlink" title="书籍阅读"></a>书籍阅读</h2><hr>
]]></content>
      <categories>
        <category>冲浪</category>
      </categories>
      <tags>
        <tag>冲冲冲</tag>
      </tags>
  </entry>
  <entry>
    <title>db与缓存数据一致性</title>
    <url>/2020/06/09/db-yu-huan-cun-shu-ju-yi-zhi-xing/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/rjzheng/p/9041659.html" target="_blank" rel="noopener">参考文章</a></p>
<p>四种处理时序：</p>
<ul>
<li>先更新缓存，再更新数据库</li>
<li>先更新数据库，再更新缓存</li>
<li>先删除缓存，再更新数据库</li>
<li>先更新数据库，再删除缓存<a id="more"></a></li>
</ul>
<p><strong>为缓存设置过期时间可以保证最终一致性。</strong></p>
<h2 id="先更新缓存，再更新数据库"><a href="#先更新缓存，再更新数据库" class="headerlink" title="先更新缓存，再更新数据库"></a>先更新缓存，再更新数据库</h2><p>这种方式隐患最大，通常db的数据持久化能力强于缓存，因此数据主体应当是数据库。如果先更新缓存，再根据缓存数据去更新数据库，当遇到数据库更新失败的情况，数据库会重试更新，当重试时间过长，缓存已经失效，此时缓存会去读取数据库中旧的数据，此时数据库更新的数据也为旧的数据，从而导致<strong>数据丢失</strong>。</p>
<p>那么可以不设置缓存过期时间，这可能会导致某些数据永远不一致，也考验缓存的持久化能力。</p>
<h2 id="先更新数据库，再更新缓存"><a href="#先更新数据库，再更新缓存" class="headerlink" title="先更新数据库，再更新缓存"></a>先更新数据库，再更新缓存</h2><p>这种方式也会导致数据不一致，但问题更应聚焦于性能开销方面，通常缓存用于提升查询效率，当某些业务读操作不那么频繁，每次更新数据库都需要使用一些计算资源去计算缓存值，是一件得不偿失的事情。</p>
<h2 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库"></a>先删除缓存，再更新数据库</h2><p>双删策略保证数据一致性</p>
<h2 id="先更新数据库，再删除缓存"><a href="#先更新数据库，再删除缓存" class="headerlink" title="先更新数据库，再删除缓存"></a>先更新数据库，再删除缓存</h2><p>这种数据一致性保证最好，出现数据不一致的情况概率很低，需要满足：</p>
<p>假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生</p>
<ul>
<li>（1）缓存刚好失效</li>
<li>（2）请求A查询数据库，得一个旧值</li>
<li>（3）请求B将新值写入数据库</li>
<li>（4）请求B删除缓存</li>
<li>（5）请求A将查到的旧值写入缓存</li>
</ul>
<p>除了设置缓存过期时间，还可以在此基础上设置异步延时删除策略，以及删除失败重试</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>数据一致性</tag>
      </tags>
  </entry>
  <entry>
    <title>开源规则引擎Drools</title>
    <url>/2020/06/04/kai-yuan-gui-ze-yin-qing-drools/</url>
    <content><![CDATA[<p><a href="https://github.com/njustwh2014/drools-demo" target="_blank" rel="noopener">demo地址</a></p>
<h2 id="为什么需要规则引擎"><a href="#为什么需要规则引擎" class="headerlink" title="为什么需要规则引擎"></a>为什么需要<a href="https://www.ibm.com/developerworks/cn/opensource/os-drools/index.html" target="_blank" rel="noopener">规则引擎</a></h2><p>规则引擎起源于基于规则的专家系统。利用规则引擎可以将商业决策者的商业运营决策逻辑和应用开发者的技术决策分离。我们可以把商业决策放在中心数据库或其他统一地方，从而能够在运行时动态的管理和修改，改善了开发和运营效率。</p>
<p>目前Java开源的规则引擎主要有：Drools、Easy Rules、Mandarax、IBM ILOG。使用最广泛并且开源的是Drools。</p>
<a id="more"></a>

<h3 id="规则引擎的优点"><a href="#规则引擎的优点" class="headerlink" title="规则引擎的优点"></a>规则引擎的优点</h3><h4 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h4><p>规则可以很容易地解决困难的问题，并得到解决方案的验证。与代码不同，规则以较不复杂的语言编写; 业务分析师可以轻松阅读和验证一套规则。</p>
<h4 id="逻辑和数据分离"><a href="#逻辑和数据分离" class="headerlink" title="逻辑和数据分离"></a>逻辑和数据分离</h4><p>数据位于“域对象”中，业务逻辑位于“规则”中。根据项目的种类，这种分离是非常有利的。</p>
<h4 id="速度和可扩展性"><a href="#速度和可扩展性" class="headerlink" title="速度和可扩展性"></a>速度和可扩展性</h4><p>写入Drools的Rete OO算法已经是一个成熟的算法。在Drools的帮助下，您的应用程序变得非常可扩展。如果频繁更改请求，可以添加新规则，而无需修改现有规则。</p>
<h4 id="知识集中化"><a href="#知识集中化" class="headerlink" title="知识集中化"></a>知识集中化</h4><p>通过使用规则，您创建一个可执行的知识库（知识库）。这是商业政策的一个真理点。理想情况下，规则是可读的，它们也可以用作文档。</p>
<h2 id="rete-算法"><a href="#rete-算法" class="headerlink" title="rete 算法"></a>rete 算法</h2><p>Rete 算法最初是由卡内基梅隆大学的 Charles L.Forgy 博士在 1974 年发表的论文中所阐述的算法 , 该算法提供了专家系统的一个高效实现。自 Rete 算法提出以后 , 它就被用到一些大型的规则系统中 , 像 ILog、Jess、JBoss Rules 等都是基于 RETE 算法的规则引擎</p>
<p>Rete 在拉丁语中译为”net”，即网络。Rete 匹配算法是一种进行大量模式集合和大量对象集合间比较的高效方法，通过网络筛选的方法找出所有匹配各个模式的对象和规则。</p>
<p>其核心思想是将分离的匹配项根据内容动态构造匹配树，以达到显著降低计算量的效果。Rete 算法可以被分为两个部分：规则编译和规则执行。当Rete算法进行事实的断言时，包含三个阶段：匹配、选择和执行，称做 match-select-act cycle。</p>
<h2 id="DRools特点"><a href="#DRools特点" class="headerlink" title="DRools特点"></a>DRools特点</h2><p>Drools 是一个基于Charles Forgy’s的RETE算法的，易于访问企业策略、易于调整以及易于管理的开源业务规则引擎，符合业内标准，速度快、效率高。 业务分析师人员或审核人员可以利用它轻松查看业务规则，从而检验是否已编码的规则执行了所需的业务规则。</p>
<p>Drools 是用Java语言编写的开放源码规则引擎，使用Rete算法对所编写的规则求值。Drools允许使用声明方式表达业务逻辑。可以使用非XML的本地语言编写规则，从而便于学习和理解。并且，还可以将Java代码直接嵌入到规则文件中，这令Drools的学习更加吸引人。</p>
<h3 id="Drools优点："><a href="#Drools优点：" class="headerlink" title="Drools优点："></a>Drools优点：</h3><ul>
<li>非常活跃的社区支持</li>
<li>易用</li>
<li>快速的执行速度</li>
<li>在 Java 开发人员中流行</li>
<li>与 Java Rule Engine API（JSR 94）兼容</li>
</ul>
<h2 id="Drools相关概念："><a href="#Drools相关概念：" class="headerlink" title="Drools相关概念："></a>Drools相关概念：</h2><ul>
<li>事实（Fact）：对象之间及对象属性之间的关系</li>
<li>规则（rule）：是由条件和结论构成的推理语句，一般表示为if…Then。一个规则的if部分称为LHS，then部分称为RHS。</li>
<li>模式（module）：就是指IF语句的条件。这里IF条件可能是有几个更小的条件组成的大条件。模式就是指的不能在继续分割下去的最小的原子条件。</li>
</ul>
<p>Drools通过<strong>事实、规则和模式</strong>相互组合来完成工作，drools在开源规则引擎中使用率最广，但是在国内企业使用偏少，保险、支付行业使用稍多。</p>
<h2 id="简单demo"><a href="#简单demo" class="headerlink" title="简单demo"></a>简单demo</h2><p>drools有专门的<a href="http://einverne.github.io/post/2019/03/drools-syntax.html" target="_blank" rel="noopener">规则语法drl</a>,用于描述规则如何执行。</p>
<p>简单demo主要实现当status=hello时，输出hello world，并将status置为bye，当status=bye时，输出goodbye。</p>
<p>用java语言可以描述如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(message.status==Message.HELLO)&#123;</span><br><span class="line">    System.out.println(message.message);</span><br><span class="line">    message.status=Message.GOODBYE;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(message.status==Message.GOODBYE)&#123;</span><br><span class="line">    System.out.println(message.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用drl语言描述，drl文件需要放在<code>src/main/resources/..</code>目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package rules</span><br><span class="line"></span><br><span class="line">import cn.edu.seu.wh.drools.simple.demo.entity.Message;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">global java.util.List list</span><br><span class="line"></span><br><span class="line">rule &quot;Hello World&quot;</span><br><span class="line">    dialect &quot;mvel&quot;</span><br><span class="line">    salience 3</span><br><span class="line">    when</span><br><span class="line">        m:Message(status==Message.HELLO,msg:message)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        list.add(m);</span><br><span class="line">        modify(m)&#123;message=&quot;Goodbye cruel world!&quot;,status=Message.GOODBYE&#125;;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule &quot;Good Bye&quot;</span><br><span class="line">    dialect &quot;java&quot;</span><br><span class="line">    when</span><br><span class="line">        Message(status==Message.GOODBYE,msg:message)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<ul>
<li>package与java语言类似，但package不必和物理路径一致。</li>
<li>import可以导入java类完整路径或静态方法</li>
<li>rule 规则名称，需要保持唯一性，可以设置重复次数，默认重复无数次。</li>
<li>salience 用于设置优先级，数字越大优先级越高，不设置时执行顺序随机。</li>
<li>when 条件语句  就是当达到什么条件的时候</li>
<li>then 根据条件的结果，来执行具体动作</li>
<li>end 规则结束</li>
</ul>
<p>需要一个配置文件告诉代码drl文件在哪里，在drools中这个文件是kmodule.xml，放置在<code>src/main/resources/META-INF</code>下</p>
<p>kmodule.xml内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">kmodule</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">"http://www.drools.org/xsd/kmodule"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">kbase</span> <span class="attr">name</span>=<span class="string">"HelloWorldKB"</span> <span class="attr">packages</span>=<span class="string">"rules"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ksession</span> <span class="attr">name</span>=<span class="string">"HelloWorldKS"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">kbase</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">kmodule</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Kmodule 中可以包含一个到多个 kbase,分别对应 drl 的规则文件。</li>
<li>Kbase 需要一个唯一的 name,可以取任意字符串。</li>
<li>packages 为drl文件所在resource目录下的路径。<strong>注意区分drl文件中的package与此处的package不一定相同</strong>。多个包用逗号分隔。默认情况下会扫描 resources目录下所有(包含子目录)规则文件。<strong>此目录下所有rule名称不能重复</strong></li>
<li>kbase的default属性,标示当前KieBase是不是默认的,如果是默认的则不用名称 就可以查找到该 KieBase,但每个 module 最多只能有一个默认 KieBase。</li>
<li>kbase 下面可以有一个或多个 ksession,ksession 的 name 属性必须设置,且必须唯一。</li>
</ul>
<p>代码端处理如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// KieServices is the factory for all KIE services</span></span><br><span class="line">        KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">        <span class="comment">// KieContainer是重量级组件，建议复用</span></span><br><span class="line">        KieContainer kieContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">        execute(kieContainer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(KieContainer kieContainer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 依赖KieContainer产生一个KieSession，它的定义和配置在 META-INF/kmodule.xml</span></span><br><span class="line">        KieSession kieSession=kieContainer.newKieSession(<span class="string">"HelloWorldKS"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一旦KieSession生成，application可以和它交互</span></span><br><span class="line">        <span class="comment">// 这个demo里声明了一个global变量list 在rules/HelloWorld.drl文件里</span></span><br><span class="line">        List&lt;Object&gt; list=<span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">        kieSession.setGlobal(<span class="string">"list"</span>,list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// application也可以设置监听器</span></span><br><span class="line">        kieSession.addEventListener(<span class="keyword">new</span> DebugAgendaEventListener());</span><br><span class="line">        kieSession.addEventListener(<span class="keyword">new</span> DebugRuleRuntimeEventListener());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// To setup a file based audit logger, uncomment the next line</span></span><br><span class="line">        <span class="comment">// KieRuntimeLogger logger = ks.getLoggers().newFileLogger( ksession, "./helloworld" );</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// To setup a ThreadedFileLogger, so that the audit view reflects events whilst debugging,</span></span><br><span class="line">        <span class="comment">// uncomment the next line</span></span><br><span class="line">        <span class="comment">// KieRuntimeLogger logger = ks.getLoggers().newThreadedFileLogger( ksession, "./helloworld", 1000 );</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// application插入facts into session</span></span><br><span class="line">        <span class="keyword">final</span> Message message=<span class="keyword">new</span> Message();</span><br><span class="line">        message.setMessage(<span class="string">"Hello World!"</span>);</span><br><span class="line">        message.setStatus(Message.HELLO);</span><br><span class="line">        kieSession.insert(message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行所有rules</span></span><br><span class="line">        kieSession.fireAllRules();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Object obj:list)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Object in list:"</span>+obj.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remove comment if using logging</span></span><br><span class="line">        <span class="comment">// logger.close();</span></span><br><span class="line"></span><br><span class="line">        kieSession.dispose();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>Message</code>如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HELLO=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GOODBYE=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="整合Spring，动态从数据库覆盖原有的规则"><a href="#整合Spring，动态从数据库覆盖原有的规则" class="headerlink" title="整合Spring，动态从数据库覆盖原有的规则"></a>整合Spring，动态从数据库覆盖原有的规则</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-drools/index.html" target="_blank" rel="noopener">规则引擎</a></p>
</li>
<li><p><a href="http://einverne.github.io/post/2019/03/drools-syntax.html" target="_blank" rel="noopener">规则语法drl</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Drools</category>
      </categories>
      <tags>
        <tag>Drools</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis自动生成的Example类用法</title>
    <url>/2020/05/11/mybatis-zi-dong-sheng-cheng-de-example-lei-yong-fa/</url>
    <content><![CDATA[<h2 id="什么是Example类"><a href="#什么是Example类" class="headerlink" title="什么是Example类"></a>什么是Example类</h2><p>mybatis-generator会为每个字段产生Criterion，为底层的mapper.xml创建动态sql。理论上通过Example类可以构造出任何筛选条件。</p>
<a id="more"></a>

<h2 id="了解Example类的成员变量"><a href="#了解Example类的成员变量" class="headerlink" title="了解Example类的成员变量"></a>了解Example类的成员变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//作用：升序还是降序</span></span><br><span class="line"><span class="comment">//参数格式：字段+空格+asc(desc)</span></span><br><span class="line"><span class="keyword">protected</span> String orderByClause;  </span><br><span class="line"><span class="comment">//作用：去除重复</span></span><br><span class="line"><span class="comment">//true是选择不重复记录，false，反之</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> distinct;</span><br><span class="line"><span class="comment">//自定义查询条件</span></span><br><span class="line"><span class="comment">//Criteria的集合，集合中对象是由or连接</span></span><br><span class="line"><span class="keyword">protected</span> List&lt;Criteria&gt; oredCriteria;</span><br><span class="line"><span class="comment">//内部类Criteria包含一个Cretiron的集合，</span></span><br><span class="line"><span class="comment">//每一个Criteria对象内包含的Cretiron之间是由  AND连接的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Criteria</span> <span class="keyword">extends</span> <span class="title">GeneratedCriteria</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="title">Criteria</span><span class="params">()</span> </span>&#123;<span class="keyword">super</span>();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是mybatis中逆向工程中的代码模型</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneratedCriteria</span> </span>&#123;......&#125;</span><br><span class="line"><span class="comment">//是最基本,最底层的Where条件，用于字段级的筛选</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Criterion</span> </span>&#123;......&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Example使用前准备"><a href="#Example使用前准备" class="headerlink" title="Example使用前准备"></a>Example使用前准备</h2><p>比如我的Example是根据user表生成的，UserMapper属于dao层，UserMapper.xml是对应的映射文件。</p>
<blockquote>
<p>UserMapper接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">countByExample</span><span class="params">(UserExample example)</span></span>;</span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">selectByExample</span><span class="params">(UserExample example)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="查询记录数"><a href="#查询记录数" class="headerlink" title="查询记录数"></a>查询记录数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> count = userMapper.countByExample(example);</span><br></pre></td></tr></table></figure>

<p>类似于</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<h2 id="where条件查询或多条件查询"><a href="#where条件查询或多条件查询" class="headerlink" title="where条件查询或多条件查询"></a>where条件查询或多条件查询</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">example.setOrderByClause(<span class="string">"age asc"</span>); <span class="comment">//升序</span></span><br><span class="line"> example.setDistinct(<span class="keyword">false</span>); <span class="comment">//不去重</span></span><br><span class="line"> <span class="keyword">if</span>(!StringUtils.isNotBlank(user.getName()))&#123;</span><br><span class="line"> Criteria.andNameEqualTo(user.getName());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(!StringUtils.isNotBlank(user.getSex()))&#123;</span><br><span class="line"> Criteria.andSexEqualTo(user.getSex());</span><br><span class="line"> &#125;</span><br><span class="line"> List&lt;User&gt; userList=userMapper.selectByExample(example);</span><br></pre></td></tr></table></figure>

<p>类似于</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span>=&#123;<span class="comment">#user.name&#125; and sex=&#123;#user.sex&#125; order by age asc;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserExample.Criteria criteria1 = example.createCriteria();</span><br><span class="line">UserExample.Criteria criteria2 = example.createCriteria();</span><br><span class="line"><span class="keyword">if</span>(!StringUtils.isNotBlank(user.getName()))&#123;</span><br><span class="line">Criteria1.andNameEqualTo(user.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!StringUtils.isNotBlank(user.getSex()))&#123;</span><br><span class="line">Criteria2.andSexEqualTo(user.getSex());</span><br><span class="line">&#125;</span><br><span class="line">Example.or(criteria2);</span><br><span class="line">List&lt;User&gt; userList=userMapper.selectByExample(example);</span><br></pre></td></tr></table></figure>

<p>类似于</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span>=&#123;<span class="comment">#user.name&#125; or sex=&#123;#user.sex&#125; ;</span></span><br></pre></td></tr></table></figure>

<h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!StringUtils.isNotBlank(user.getName()))&#123;</span><br><span class="line">criteria.andNameLIke(‘%’+name+’%’);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;User&gt; userList=userMapper.selectByExample(example);</span><br></pre></td></tr></table></figure>

<p>类似于</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> %&#123;<span class="comment">#user.name&#125;%;</span></span><br></pre></td></tr></table></figure>

<h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> start = (currentPage - <span class="number">1</span>) * rows;</span><br><span class="line"><span class="comment">//分页查询中的一页数量</span></span><br><span class="line">example.setPageSize(rows); </span><br><span class="line"><span class="comment">//开始查询的位置</span></span><br><span class="line">example.setStartRow(start);  </span><br><span class="line">List&lt;User&gt; userList=userMapper.selectByExample(example);</span><br></pre></td></tr></table></figure>

<p>类似于</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> %&#123;<span class="comment">#user.name&#125;%</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>动态代理总结</title>
    <url>/2020/03/22/dong-tai-dai-li-zong-jie/</url>
    <content><![CDATA[<h2 id="动态代理有什么作用以及使用场景？"><a href="#动态代理有什么作用以及使用场景？" class="headerlink" title="动态代理有什么作用以及使用场景？"></a>动态代理有什么作用以及使用场景？</h2><ul>
<li>日志集中打印</li>
<li>事务</li>
<li>权限管理</li>
<li>AOP</li>
</ul>
<h2 id="Spring-AOP的实现方式"><a href="#Spring-AOP的实现方式" class="headerlink" title="Spring AOP的实现方式"></a>Spring AOP的实现方式</h2><a id="more"></a>
<ul>
<li>java动态代理</li>
<li>cglib</li>
<li>AspectJ：在程序编译时，修改目标类的字节，织入代理的字节</li>
<li>instrumentation：基于javaagent，在类装载时，动态拦截去修改目标类的字节码</li>
</ul>
<p><img src="/2020/03/22/dong-tai-dai-li-zong-jie/%E5%90%84%E7%A7%8D%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A1%86%E6%9E%B6.png" alt></p>
]]></content>
      <categories>
        <category>求职</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>算法与数据结构面试题汇总</title>
    <url>/2020/03/17/suan-fa-yu-shu-ju-jie-gou-mian-shi-ti-hui-zong/</url>
    <content><![CDATA[<h2 id="堆排序算法的时间复杂度"><a href="#堆排序算法的时间复杂度" class="headerlink" title="堆排序算法的时间复杂度"></a>堆排序算法的时间复杂度</h2><p><strong>堆排序与快速排序、归并排序一样都是时间复杂度为O(N*logN)的几种常见排序方法。</strong></p>
<h3 id="堆和堆排序"><a href="#堆和堆排序" class="headerlink" title="堆和堆排序"></a><a href="https://blog.csdn.net/MoreWindows/article/details/6709644" target="_blank" rel="noopener">堆和堆排序</a></h3><a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>:datastructureimpl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:堆接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Huan Wang(https://github.com/njustwh2014)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>:2020-03-17 16:48</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>;<span class="comment">//最小堆得到的是递减数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>:datastructureimpl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:小顶堆实现 简约实现，不支持扩容，具体扩容实现参考PriorityQueue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Huan Wang(https://github.com/njustwh2014)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>:2020-03-17 17:03</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span> <span class="keyword">implements</span> <span class="title">Heap</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>[] nums;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinHeap</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">        <span class="keyword">this</span>.capacity=nums.length;</span><br><span class="line">        <span class="keyword">this</span>.nums=<span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">        <span class="keyword">this</span>.index=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">this</span>.nums[i]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinHeap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.nums=<span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">        <span class="keyword">this</span>.index=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinHeap</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">//如果nums长度大于capacity则放弃超过部分</span></span><br><span class="line">        <span class="keyword">this</span>.index=(capacity&gt;=nums.length)?nums.length-<span class="number">1</span>:capacity-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.nums=<span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">this</span>.nums[i]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 堆化数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span>: []</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@thorws</span>:</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: Mr.Wang</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span>: 2020/3/17</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=(index+<span class="number">1</span>)/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            fixDown(nums,i,index+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span>: [o]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>: boolean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@thorws</span>:</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: Mr.Wang</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span>: 2020/3/17</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==capacity-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//添加失败</span></span><br><span class="line">        &#125;</span><br><span class="line">        nums[++index]=o;</span><br><span class="line">        fixUp(nums,index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 向上调整堆</span></span><br><span class="line"><span class="comment">     *      * 每次插入都是将新数据放在数组最后。可以发现从这个新数据的父结点到根结点必然为一个有序的数列，</span></span><br><span class="line"><span class="comment">     *      * 现在的任务是将这个新数据插入到这个有序数据中——这就类似于直接插入排序中将一个数据并入到有序区间中</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span>: [nums, index]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@thorws</span>:</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: Mr.Wang</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span>: 2020/3/17</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixUp</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> o=nums[i];</span><br><span class="line">        <span class="keyword">int</span> j=(i-<span class="number">1</span>)/<span class="number">2</span>;<span class="comment">//父节点下标</span></span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;i!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;=o)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[i]=nums[j];</span><br><span class="line">            i=j;</span><br><span class="line">            j=(i-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i]=o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index==<span class="number">0</span>)&#123;</span><br><span class="line">            nums[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,<span class="number">0</span>,index);</span><br><span class="line">        index--;</span><br><span class="line">        fixDown(nums,<span class="number">0</span>,index+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=nums[i];</span><br><span class="line">        nums[i]=nums[j];</span><br><span class="line">        nums[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 向下调整</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span>: [nums, i, n] n为节点总数 i为从i节点开始调整</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@thorws</span>:</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: Mr.Wang</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span>: 2020/3/17</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixDown</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> o=nums[i];</span><br><span class="line">        <span class="keyword">int</span> j=i*<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//左子节点</span></span><br><span class="line">        <span class="keyword">while</span>(j&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span>&lt;n&amp;&amp;nums[j+<span class="number">1</span>]&lt;nums[j])&#123;</span><br><span class="line">                j++;<span class="comment">//这步很妙，选取出了左右子节点中较小值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(o&lt;=nums[j])&#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//父节点均小于左右子节点，则不需要调整</span></span><br><span class="line">            &#125;</span><br><span class="line">            nums[i]=nums[j];</span><br><span class="line">            i=j;</span><br><span class="line">            j=i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i]=o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=index;i++)&#123;</span><br><span class="line">            System.out.print(nums[i]);</span><br><span class="line">            System.out.print(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            System.out.print(nums[i]);</span><br><span class="line">            System.out.print(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"堆中无元素"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 利用最小堆进行排序得到的是递减数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span>: [nums]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@thorws</span>:</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: Mr.Wang</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span>: 2020/3/17</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先堆化数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            fixDown(nums,i,nums.length);</span><br><span class="line">        &#125;</span><br><span class="line">        print(nums);</span><br><span class="line">        <span class="comment">//交换nums[0]与nums[i]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            swap(nums,<span class="number">0</span>,i);</span><br><span class="line">            fixDown(nums,<span class="number">0</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Iterator实现"><a href="#Iterator实现" class="headerlink" title="Iterator实现"></a>Iterator实现</h2><h3 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>:datastructure</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Huan Wang(https://github.com/njustwh2014)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>:2019-12-17 15:35</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>:datastructure</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Huan Wang(https://github.com/njustwh2014)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>:2019-12-17 15:36</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>:datastructure</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Huan Wang(https://github.com/njustwh2014)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>:2019-12-17 15:37</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameRepository</span> <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] name=&#123;<span class="string">"tingting"</span>,<span class="string">"huanhuan"</span>,<span class="string">"dog"</span>,<span class="string">"cat"</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NameIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NameIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(index&lt;name.length)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.hasNext())&#123;</span><br><span class="line"><span class="comment">//                String ret= name[index];</span></span><br><span class="line"><span class="comment">////                index++;</span></span><br><span class="line"><span class="comment">////                return ret;</span></span><br><span class="line">                <span class="keyword">return</span> name[index++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode-301-Remove-Invalid-Parentheses"><a href="#Leetcode-301-Remove-Invalid-Parentheses" class="headerlink" title="Leetcode 301: Remove Invalid Parentheses"></a><a href="https://leetcode.com/problems/remove-invalid-parentheses/" target="_blank" rel="noopener">Leetcode 301: Remove Invalid Parentheses</a></h2><p>先来举个例子：(()))</p>
<p>对于这种情况，当遍历到下标4处的)，此时出现右括号多于左括号，那么只需要删除此前任意一个右括号即可，得到如下结果：(())、(())、(())，可以发现存在重复结果，因此保留一个结果[“(())”]</p>
<p>对于左括号多于右括号的情况，如：()(()，需要将字符串反转，)(()(，并将)(视为合法组合，当遍历到下标为2处的左括号，则出现左括号多于右括号情况，可以删除此前任一一个左括号即可，同右括号多于左括号情况了。</p>
<p>接下来处理怎么去重。</p>
<p>还是举一个例子：()())())</p>
<p>删除原则就是当出现连续括号时，默认删除第一个</p>
<p>当遍历到下标4处的右括号时，需要进行处理，根据原则我们可以得到如下两种处理结果: (())())、()()())</p>
<p>接下来再对(())())处理，根据原则可以得到 (()())、(())()两种结果</p>
<p>对()()())处理，根据原则可以得到(()())、()(())、()()()</p>
<p>此外还需记录上次删除的下标，如果在删除下标前再删除也会产生重复结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: leetcode 301 Remove Invalid Parentheses https://leetcode.com/problems/remove-invalid-parentheses/</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Param</span>: [s]</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>: java.util.List&lt;java.lang.String&gt;</span></span><br><span class="line"><span class="comment">* <span class="doctag">@thorws</span>:</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: Mr.Wang</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Date</span>: 2020/4/28</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">removeInvalidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ret=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="keyword">null</span>||s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        ret.add(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    removeInvalidParenthesesHelper(s,ret,<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'('</span>,<span class="string">')'</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeInvalidParenthesesHelper</span><span class="params">(String s,List&lt;String&gt; ret,<span class="keyword">int</span> lastRemoveIndex,<span class="keyword">int</span> lastCheckedIndex,<span class="keyword">char</span>[] pattern)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意这个pattern数组，可以将左括号还是右括号多转化成同一个问题</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=lastCheckedIndex,stack=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> cur=s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(cur==pattern[<span class="number">0</span>]) stack++;</span><br><span class="line">        <span class="keyword">if</span>(cur==pattern[<span class="number">1</span>]) stack--;</span><br><span class="line">        <span class="keyword">if</span>(stack&gt;=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=lastRemoveIndex;j&lt;=i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(j)==pattern[<span class="number">1</span>]&amp;&amp;(j==lastRemoveIndex||s.charAt(j-<span class="number">1</span>)!=pattern[<span class="number">1</span>]))&#123;</span><br><span class="line">                removeInvalidParenthesesHelper(s.substring(<span class="number">0</span>,j)+s.substring(j+<span class="number">1</span>),ret,j,i,pattern);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    String reversed=<span class="keyword">new</span> StringBuilder(s).reverse().toString();</span><br><span class="line">    <span class="keyword">if</span>(pattern[<span class="number">0</span>]==<span class="string">'('</span>)&#123;</span><br><span class="line">        <span class="comment">//说明左括号不少于右括号，所以需要先反转字符串</span></span><br><span class="line">        removeInvalidParenthesesHelper(reversed,ret,<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">')'</span>,<span class="string">'('</span>&#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        假设输入为(())</span></span><br><span class="line"><span class="comment">        reversed=))((</span></span><br><span class="line"><span class="comment">        removeInvalidParenthesesHelper(reversed,ret,0,0,new char[]&#123;')','('&#125;);</span></span><br><span class="line"><span class="comment">        才会到这</span></span><br><span class="line"><span class="comment">        此时 reversed=(())</span></span><br><span class="line"><span class="comment">        还不理解，就去IDE打断点吧</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        ret.add(reversed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@nums 排序好的数组</span></span><br><span class="line"><span class="comment">@target</span></span><br><span class="line"><span class="comment">@return f返回目标下标 如果没有 返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right=mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除单链表中包含目标数据的节点"><a href="#删除单链表中包含目标数据的节点" class="headerlink" title="删除单链表中包含目标数据的节点"></a>删除单链表中包含目标数据的节点</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteTarget</span><span class="params">(ListNode head,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    ListNode newHead=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    newHead.next=head;</span><br><span class="line">    ListNode prev=newHead,cur=head;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.val==target)&#123;</span><br><span class="line">            prev.next=cur.next;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            prev=prev.next;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="迷宫传送门"><a href="#迷宫传送门" class="headerlink" title="迷宫传送门"></a>迷宫传送门</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1 0 -1 1</span></span><br><span class="line"><span class="comment">-2 0 -1 -3</span></span><br><span class="line"><span class="comment">2 2 0 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-2:起点</span></span><br><span class="line"><span class="comment">-3:终点</span></span><br><span class="line"><span class="comment">-1:障碍物不能走</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1和2 任意门，可以用也可以不用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//存坐标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node&#123;"</span> +</span><br><span class="line">                <span class="string">"x="</span> + x +</span><br><span class="line">                <span class="string">", y="</span> + y +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//bfs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinSteps</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存任意门坐标</span></span><br><span class="line">    List&lt;Node&gt; door1=<span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//1：任意门</span></span><br><span class="line">    List&lt;Node&gt; door2=<span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//2:任意门</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//任意门存储已经找到终点和起点</span></span><br><span class="line">    Node start=<span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>),end=<span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix[i].length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                Node node=<span class="keyword">new</span> Node(i,j);</span><br><span class="line">                door1.add(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j]==<span class="number">2</span>)&#123;</span><br><span class="line">                Node node=<span class="keyword">new</span> Node(i,j);</span><br><span class="line">                door2.add(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j]==-<span class="number">2</span>)&#123;</span><br><span class="line">                start.x=i;</span><br><span class="line">                start.y=j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j]==-<span class="number">3</span>)&#123;</span><br><span class="line">                end.x=i;</span><br><span class="line">                end.y=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Queue&lt;Node&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    HashSet&lt;String&gt; hashSet=<span class="keyword">new</span> HashSet&lt;&gt;();<span class="comment">//访问过的点不重复</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//bfs</span></span><br><span class="line">    <span class="keyword">int</span> steps=<span class="number">0</span>,size=<span class="number">1</span>;</span><br><span class="line">    queue.add(start);</span><br><span class="line">    hashSet.add(start.toString());</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        Node cur=queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(matrix[cur.x][cur.y]==-<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="comment">//找到终点</span></span><br><span class="line">            <span class="keyword">return</span> steps;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加下次到达的点</span></span><br><span class="line">        <span class="keyword">if</span>(matrix[cur.x][cur.y]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Node node:door1)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!hashSet.contains(node.toString()))&#123;</span><br><span class="line">                    hashSet.add(node.toString());</span><br><span class="line">                    queue.add(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(matrix[cur.x][cur.y]==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Node node:door2)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!hashSet.contains(node.toString()))&#123;</span><br><span class="line">                    hashSet.add(node.toString());</span><br><span class="line">                    queue.add(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(validPosition(matrix,cur.x+<span class="number">1</span>,cur.y))&#123;</span><br><span class="line">            Node node=<span class="keyword">new</span> Node(cur.x+<span class="number">1</span>,cur.y);</span><br><span class="line">            <span class="keyword">if</span>(!hashSet.contains(node.toString()))&#123;</span><br><span class="line">                hashSet.add(node.toString());</span><br><span class="line">                queue.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(validPosition(matrix,cur.x-<span class="number">1</span>,cur.y))&#123;</span><br><span class="line">            Node node=<span class="keyword">new</span> Node(cur.x-<span class="number">1</span>,cur.y);</span><br><span class="line">            <span class="keyword">if</span>(!hashSet.contains(node.toString()))&#123;</span><br><span class="line">                hashSet.add(node.toString());</span><br><span class="line">                queue.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(validPosition(matrix,cur.x,cur.y+<span class="number">1</span>))&#123;</span><br><span class="line">            Node node=<span class="keyword">new</span> Node(cur.x,cur.y+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(!hashSet.contains(node.toString()))&#123;</span><br><span class="line">                hashSet.add(node.toString());</span><br><span class="line">                queue.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(validPosition(matrix,cur.x,cur.y+<span class="number">1</span>))&#123;</span><br><span class="line">            Node node=<span class="keyword">new</span> Node(cur.x,cur.y+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(!hashSet.contains(node.toString()))&#123;</span><br><span class="line">                hashSet.add(node.toString());</span><br><span class="line">                queue.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>)&#123;</span><br><span class="line">            steps++;</span><br><span class="line">            size=queue.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validPosition</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;=matrix.length||y&lt;<span class="number">0</span>||y&gt;=matrix[<span class="number">0</span>].length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="求比整数N小的所有正整数中，各位数字乘积最大者，如输入220，返回199"><a href="#求比整数N小的所有正整数中，各位数字乘积最大者，如输入220，返回199" class="headerlink" title="求比整数N小的所有正整数中，各位数字乘积最大者，如输入220，返回199"></a>求比整数N小的所有正整数中，各位数字乘积最大者，如输入220，返回199</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxMultiByDp</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    String str=String.valueOf(x);</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nine=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>,bits=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] nums=<span class="keyword">new</span> <span class="keyword">int</span>[str.length()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=str.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> cur=Integer.valueOf(str.charAt(i)-<span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">if</span>(i==str.length()-<span class="number">1</span>)&#123;</span><br><span class="line">            res=cur;</span><br><span class="line">            nums[i]=cur;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;cur==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//处理首位为1</span></span><br><span class="line">            <span class="keyword">if</span>(nine&gt;cur*res)&#123;</span><br><span class="line">                res=nine;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">                    nums[j]=<span class="number">9</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                nums[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res=cur*res;</span><br><span class="line">                nums[i]=cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>((cur-<span class="number">1</span>)*nine&gt;cur*res)&#123;</span><br><span class="line">                res=(cur-<span class="number">1</span>)*nine;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">                    nums[j]=<span class="number">9</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                nums[i]=cur-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res=cur*res;</span><br><span class="line">                nums[i]=cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nine=nine*<span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        res=res*<span class="number">10</span>+nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>求职</category>
      </categories>
  </entry>
  <entry>
    <title>Docker面试总结</title>
    <url>/2020/03/16/docker-mian-shi-zong-jie/</url>
    <content><![CDATA[<h2 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h2><ul>
<li>Docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保您的应用程序在开发，测试或生产的任何环境中无缝运行。</li>
<li>Docker容器，将一个软件包装在一个完整的文件系统中，该文件系统包含运行所需的一切：代码，运行时，系统工具，系统库等可以安装在服务器上的任何东西。</li>
<li>这可以保证软件始终运行相同，无论其环境如何。</li>
</ul>
<h2 id="为什么要用Docker"><a href="#为什么要用Docker" class="headerlink" title="为什么要用Docker"></a>为什么要用Docker</h2><a id="more"></a>
<ul>
<li>容器具有封闭性，在一个服务器里，可以有好多容器。每个容器他可以是系统，可以是服务、可以是应用，装着什么就是什么。</li>
<li>程序性迁移。容器内的环境是可以与程序相适应。而这个容器又可以在不同的生产环境里使用。试使用一下，windows的游戏我就放到一个linux里面玩，宝马的外壳里面是奔驰，而且可以是很多台奔驰。</li>
<li>速度快，定制快。持续交付与部署。（例如公司有多个项目，所使用的环境都好相似，由于客户不愿意给更多的钱购买专用的服务器，于是把这堆客户放在一个集群里面，共享他们的资源。)</li>
<li>容器服务是在集群里的。这样服务器的横向扩展（随时增加ECS）和纵向扩展（升级ECS配置）都是很容易的事，无限的扩充。</li>
</ul>
<h2 id="DOcker网络模式"><a href="#DOcker网络模式" class="headerlink" title="DOcker网络模式"></a>DOcker网络模式</h2><p><a href="https://juejin.im/post/5c3363bf6fb9a049e2322cdb" target="_blank" rel="noopener">参考文章</a></p>
<p>可以使用<code>docker network ls</code>查看网络模式</p>
<ul>
<li>Bridge contauner 桥接式网络模式 </li>
<li>Host(open) container   开放式网络模式 </li>
<li>Container(join) container   联合挂载式网络模式，是host网络模式的延伸 </li>
<li>None(Close) container   封闭式网络模式</li>
</ul>
<h3 id="Bridge模式"><a href="#Bridge模式" class="headerlink" title="Bridge模式"></a>Bridge模式</h3><p>当Docker进程启动时，会在<strong>主机上创建一个名为docker0的虚拟网桥</strong>，此主机上启动的Docker容器会连接到这个虚拟网桥上，所以有默认地址172.17.0.0/16的地址。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。　　</p>
<p>从<strong>docker0子网中分配一个IP给容器使用</strong>，并设置docker0的IP地址为容器的默认网关。在主机上创建一对虚拟网卡veth pair设备，Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0（容器的网卡），另一端放在主机中，以vethxxx这样类似的名字命名，并将这个网络设备加入到docker0网桥中。可以通过brctl show命令查看。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@along ~]<span class="comment"># brctl show</span></span><br><span class="line">bridge name    bridge id        STP enabled    interfaces</span><br><span class="line">docker0    8000.024241c45d6e    no</span><br></pre></td></tr></table></figure>

<p><strong>bridge模式是docker的默认网络模式</strong>，不写–net参数，就是bridge模式。使用docker run -p时，docker实际是在iptables做了DNAT规则，实现端口转发功能。可以使用<code>iptables -t nat -vnL</code>查看。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@along ~]<span class="comment"># iptables -t nat -vnL</span></span><br><span class="line">Chain POSTROUTING (policy ACCEPT 20 packets, 1238 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">    0     0 MASQUERADE  all  --  *      !docker0  172.17.0.0/16        0.0.0.0/0</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/16/docker-mian-shi-zong-jie/bridge.png" alt="bridge"></p>
<h3 id="Host-网络模式"><a href="#Host-网络模式" class="headerlink" title="Host 网络模式"></a>Host 网络模式</h3><p>如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的<strong>Network Namespace</strong>，而是和宿主机共用一个Network Namespace。<strong>容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</strong></p>
<p><img src="/2020/03/16/docker-mian-shi-zong-jie/host.png" alt="host"></p>
<h3 id="Container-网络模式"><a href="#Container-网络模式" class="headerlink" title="Container 网络模式"></a>Container 网络模式</h3><p>这个模式指定<strong>新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享</strong>。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p>
<p><img src="/2020/03/16/docker-mian-shi-zong-jie/container.png" alt="container"></p>
<h3 id="None-网络模式"><a href="#None-网络模式" class="headerlink" title="None 网络模式"></a>None 网络模式</h3><p>使用none模式，<strong>Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。</strong>也就是说，这个Docker容器没有网卡、IP、路由等信息，只有lo 网络接口。需要我们自己为Docker容器添加网卡、配置IP等。　　</p>
<p>不参与网络通信，运行于此类容器中的进程仅能访问本地回环接口；<strong>仅适用于进程无须网络通信的场景中，例如：备份、进程诊断及各种离线任务等。</strong></p>
<p><img src="/2020/03/16/docker-mian-shi-zong-jie/none.png" alt="none"></p>
<h2 id="Docker与虚拟机的区别"><a href="#Docker与虚拟机的区别" class="headerlink" title="Docker与虚拟机的区别"></a>Docker与虚拟机的区别</h2><p>Docker不是虚拟化方法。它依赖于实际实现基于容器的虚拟化或操作系统级虚拟化的其他工具。为此，Docker最初使用LXC驱动程序，然后移动到libcontainer现在重命名为runc。Docker主要专注于在应用程序容器内自动部署应用程序。应用程序容器旨在打包和运行单个服务，而系统容器则设计为运行多个进程，如虚拟机。因此，Docker被视为容器化系统上的容器管理或应用程序部署工具。</p>
<ul>
<li>与虚拟机不同，容器不需要引导操作系统内核，因此可以在不到一秒的时间内创建容器。此功能使基于容器的虚拟化比其他虚拟化方法更加独特和可取。</li>
<li>由于基于容器的虚拟化为主机增加了很少或没有开销，因此基于容器的虚拟化具有接近本机的性能</li>
<li>对于基于容器的虚拟化，与其他虚拟化不同，不需要其他软件。</li>
<li>主机上的所有容器共享主机的调度程序，从而节省了额外资源的需求。</li>
<li>与虚拟机映像相比，容器状态（Docker或LXC映像）的大小很小，因此容器映像很容易分发。</li>
<li>容器中的资源管理是通过cgroup实现的。Cgroups不允许容器+ 消耗比分配给它们更多的资源。虽然主机的所有资源都在虚拟机中可见，但无法使用。这可以通过在容器和主机上同时运行top或htop来实现。所有环境的输出看起来都很相似。</li>
</ul>
<h2 id="容器内部机制"><a href="#容器内部机制" class="headerlink" title="容器内部机制"></a>容器内部机制</h2><p>大约在2006年，包括Google的一些员工在内的人们实现了名为命名空间的新的Linux内核级功能（不过这个想法早在FreeBSD中就已存在）。操作系统的一个功能是允许将全局资源（如网络和磁盘）共享到进程。如果将这些全局资源包装在命名空间中，以使它们仅对在同一命名空间中运行的那些进程可见，该怎么办？比如说，你可以获得一大块磁盘并将其放在命名空间X中，然后在命名空间Y中运行的进程无法查看或访问它。类似地，名称空间X中的进程无法访问分配给名称空间Y的内存中的任何内容。当然，X中的进程无法查看或与名称空间Y中的进程通信。这为全局资源提供了一种虚拟化和隔离。</p>
<p><strong>这就是Docker的工作原理：每个容器都在自己的命名空间中运行，但使用与所有其他容器完全相同的内核。发生隔离是因为内核知道分配给进程的命名空间，并且在API调用期间确保进程只能访问其自己的命名空间中的资源。</strong></p>
<h2 id="如何使用Docker构建与环境无关的系统？"><a href="#如何使用Docker构建与环境无关的系统？" class="headerlink" title="如何使用Docker构建与环境无关的系统？"></a>如何使用Docker构建与环境无关的系统？</h2><ul>
<li>Volumes</li>
<li>环境变量注入</li>
<li>只读文件系统</li>
</ul>
<h2 id="什么是Docker镜像？"><a href="#什么是Docker镜像？" class="headerlink" title="什么是Docker镜像？"></a>什么是Docker镜像？</h2><p><strong>Docker镜像是Docker容器的源代码。</strong>换句话说，Docker镜像用于创建容器。使用build命令创建映像，并且在使用run启动时它们将生成容器。镜像存储在Docker注册表<a href="http://registry.hub.docker.com中，因为它们可能变得非常大，镜像被设计为由其他镜像层组成，允许在通过网络传输镜像时发送最少量的数据。" target="_blank" rel="noopener">http://registry.hub.docker.com中，因为它们可能变得非常大，镜像被设计为由其他镜像层组成，允许在通过网络传输镜像时发送最少量的数据。</a></p>
<h2 id="什么是Docker容器？"><a href="#什么是Docker容器？" class="headerlink" title="什么是Docker容器？"></a>什么是Docker容器？</h2><p><strong>Docker容器包括应用程序及其所有依赖项，但与其他容器共享内核，作为主机操作系统上用户空间中的独立进程运行。</strong>Docker容器不依赖于任何特定的基础架构：它们可以在任何计算机，任何基础架构和任何云中运行。</p>
<h2 id="什么是Docker-Hub？"><a href="#什么是Docker-Hub？" class="headerlink" title="什么是Docker Hub？"></a>什么是Docker Hub？</h2><p>Docker hub是一个基于云的注册表服务，允许您链接到代码存储库，构建镜像并测试它们，存储手动推送的镜像以及指向Docker云的链接，以便您可以将镜像部署到主机。它为整个开发流程中的容器镜像发现，分发和变更管理，用户和团队协作以及工作流自动化提供了集中资源。</p>
<h2 id="Docker容器有几种状态？"><a href="#Docker容器有几种状态？" class="headerlink" title="Docker容器有几种状态？"></a>Docker容器有几种状态？</h2><p>Docker容器可以有四种状态：</p>
<ul>
<li>运行</li>
<li>已暂停</li>
<li>重新启动</li>
<li>已退出</li>
</ul>
<p>可以通过<code>docker ps -a</code>查看容器状态</p>
<h2 id="什么类型的应用程序-无状态或有状态更适合Docker容器？​​​​​​​"><a href="#什么类型的应用程序-无状态或有状态更适合Docker容器？​​​​​​​" class="headerlink" title="什么类型的应用程序 - 无状态或有状态更适合Docker容器？​​​​​​​"></a>什么类型的应用程序 - 无状态或有状态更适合Docker容器？​​​​​​​</h2><p><strong>最好为Docker Container创建无状态应用程序。</strong>我们可以从应用程序中创建一个容器，并从应用程序中取出可配置的状态参数。现在我们可以在生产和具有不同参数的QA环境中运行相同的容器。这有助于在不同场景中重用相同的图像。使用Docker Containers比使用有状态应用程序更容易扩展无状态应用程序。</p>
<p><strong>解释基本的Docker使用流程</strong></p>
<ul>
<li>一切都从Dockerfile开始。Dockerfile是镜像的源代码。</li>
<li>创建Dockerfile后，您可以构建它以创建容器的镜像。镜像只是“源代码”的“编译版本”，即Dockerfile。</li>
<li>获得容器的镜像后，应使用注册表重新分发容器。注册表就像一个git存储库 - 你可以推送和拉取镜像。</li>
<li>接下来，您可以使用该镜像来运行容器。在许多方面，正在运行的容器与虚拟机（但没有管理程序）非常相似。</li>
</ul>
<h2 id="Dockerfile中最常见的指令是什么？​​​​​​​"><a href="#Dockerfile中最常见的指令是什么？​​​​​​​" class="headerlink" title="Dockerfile中最常见的指令是什么？​​​​​​​"></a>Dockerfile中最常见的指令是什么？​​​​​​​</h2><p>Dockerfile中的一些常用指令如下：</p>
<ul>
<li>FROM：我们使用FROM为后续指令设置基本镜像。在每个有效的Dockerfile中，FROM是第一条指令。</li>
<li>LABEL：我们使用LABEL按照项目，模块，许可等组织我们的镜像。我们也可以使用LABEL来帮助实现自动化。在LABEL中，我们指定一个键值对，以后可用于以编程方式处理Dockerfile。</li>
<li>RUN：我们使用RUN命令在当前镜像之上的新图层中执行任何指令。使用每个RUN命令，我们在镜像顶部添加一些内容，并在Dockerfile的后续步骤中使用它。</li>
<li>CMD：我们使用CMD命令提供执行容器的默认值。在Dockerfile中，如果我们包含多个CMD命令，则只使用最后一条指令。</li>
</ul>
<h2 id="Dockerfile中的命令COPY和ADD命令有什么区别？"><a href="#Dockerfile中的命令COPY和ADD命令有什么区别？" class="headerlink" title="Dockerfile中的命令COPY和ADD命令有什么区别？"></a>Dockerfile中的命令COPY和ADD命令有什么区别？</h2><p>一般而言，虽然ADD并且COPY在功能上类似，但是<strong>COPY是优选的</strong>。</p>
<p>那是因为它比ADD更透明。</p>
<p>COPY仅支持将本地文件基本复制到容器中，而ADD具有一些功能（如仅限本地的tar提取和远程URL支持），这些功能并不是很明显。因此，ADD的最佳用途是将本地tar文件自动提取到镜像中，如ADD rootfs.tar.xz /中所示。</p>
<h2 id="解释一下dockerfile的ONBUILD指令？"><a href="#解释一下dockerfile的ONBUILD指令？" class="headerlink" title="解释一下dockerfile的ONBUILD指令？"></a>解释一下dockerfile的ONBUILD指令？</h2><p>当镜像用作另一个镜像构建的基础时，ONBUILD指令向镜像添加将在稍后执行的触发指令。如果要构建将用作构建其他镜像的基础的镜像（例如，可以使用特定于用户的配置自定义的应用程序构建环境或守护程序），这将非常有用。</p>
<h2 id="Docker镜像和层有什么区别？"><a href="#Docker镜像和层有什么区别？" class="headerlink" title="Docker镜像和层有什么区别？"></a>Docker镜像和层有什么区别？</h2><ul>
<li>镜像：Docker镜像是由一系列只读层构建的</li>
<li>层：每个层代表镜像Dockerfile中的一条指令。</li>
</ul>
<p>下面的Dockerfile包含四个命令，每个命令都创建一个层。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">15.04</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> make /app</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> python /app/app.py</span></span><br></pre></td></tr></table></figure>

<p>重要的是，每个层只是与之前一层的一组差异层（相同的就不再放到新层中）。</p>
<h2 id="什么是Docker-Swarm？"><a href="#什么是Docker-Swarm？" class="headerlink" title="什么是Docker Swarm？"></a>什么是Docker Swarm？</h2><p><strong>Docker Swarm是Docker的本机群集。</strong>它将Docker主机池转变为单个虚拟Docker主机。Docker Swarm提供标准的Docker API，任何已经与Docker守护进程通信的工具都可以使用Swarm透明地扩展到多个主机。</p>
<h2 id="如何在生产中监控Docker？"><a href="#如何在生产中监控Docker？" class="headerlink" title="如何在生产中监控Docker？"></a>如何在生产中监控Docker？</h2><p><strong>Docker提供docker stats和docker事件等工具来监控生产中的Docker。</strong>我们可以使用这些命令获取重要统计数据的报告。</p>
<ul>
<li>Docker统计数据：当我们使用容器ID调用docker stats时，我们获得容器的CPU，内存使用情况等。它类似于Linux中的top命令。</li>
<li>Docker事件：Docker事件是一个命令，用于查看Docker守护程序中正在进行的活动流。<br>一些常见的Docker事件是：attach，commit，die，detach，rename，destroy等。我们还可以使用各种选项来限制或过滤我们感兴趣的事件。</li>
</ul>
<h2 id="Docker如何在非Linux系统中运行容器？"><a href="#Docker如何在非Linux系统中运行容器？" class="headerlink" title="Docker如何在非Linux系统中运行容器？"></a>Docker如何在非Linux系统中运行容器？</h2><p>通过添加到Linux内核版本2.6.24的名称空间功能，可以实现容器的概念。容器将其ID添加到每个进程，并向每个系统调用添加新的访问控制检查。它由clone（）系统调用访问，该调用允许创建先前全局命名空间的单独实例。</p>
<p>如果由于Linux内核中可用的功能而可以使用容器，那么显而易见的问题是非Linux系统如何运行容器。Docker for Mac和Windows都使用Linux VM来运行容器。Docker Toolbox用于在Virtual Box VM中运行容器。但是，最新的Docker在Windows中使用Hyper-V，在Mac中使用Hypervisor.framework。</p>
<h2 id="如何在多个环境中使用Docker？"><a href="#如何在多个环境中使用Docker？" class="headerlink" title="如何在多个环境中使用Docker？"></a>如何在多个环境中使用Docker？</h2><p>可以进行以下更改：</p>
<ul>
<li>删除应用程序代码的任何卷绑定，以便代码保留在容器内，不能从外部更改</li>
<li>绑定到主机上的不同端口</li>
<li>以不同方式设置环境变量（例如，减少日志记录的详细程度，或启用电子邮件发送）</li>
<li>指定重启策略（例如，重启：始终）以避免停​​机</li>
<li>添加额外服务（例如，日志聚合器）</li>
</ul>
<p>因此，您可能希望定义一个额外的Compose文件，例如production.yml，它指定适合生产的配置。此配置文件只需要包含您要从原始Compose文件中进行的更改。</p>
<h2 id="为什么Docker-Compose不会等待容器准备就绪，然后继续以依赖顺序启动下一个服务？"><a href="#为什么Docker-Compose不会等待容器准备就绪，然后继续以依赖顺序启动下一个服务？" class="headerlink" title="为什么Docker Compose不会等待容器准备就绪，然后继续以依赖顺序启动下一个服务？"></a>为什么Docker Compose不会等待容器准备就绪，然后继续以依赖顺序启动下一个服务？</h2><p>Compose按照依赖顺服启动和停止容器，决定依赖关系语句有 depends_on, links, volumes_from, 和network_mode: “service:…”.</p>
<p>但是，对于启动，Compose不会等到容器“准备好它运行“。这里有一个很好的理由：</p>
<ul>
<li>等待数据库（例如）准备就绪的问题实际上只是分布式系统更大问题的一个子集。在生产中，您的数据库可能随时变得不可用或移动主机。您的应用程序需要能够适应这些类型的故障。</li>
<li>要处理此问题，请将应用程序设计为在发生故障后尝试重新建立与数据库的连接。如果应用程序重试连接，它最终可以连接到数据库。</li>
<li>最佳解决方案是在启动时以及出于任何原因丢失连接时，在应用程序代码中执行此检查。</li>
</ul>
<h2 id="如何批量删除或者停止运行的容器？"><a href="#如何批量删除或者停止运行的容器？" class="headerlink" title="如何批量删除或者停止运行的容器？"></a>如何批量删除或者停止运行的容器？</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">kill</span>/rm `docker ps -aq`</span><br></pre></td></tr></table></figure>

<h2 id="本地的镜像文件都存放在哪里"><a href="#本地的镜像文件都存放在哪里" class="headerlink" title="本地的镜像文件都存放在哪里"></a>本地的镜像文件都存放在哪里</h2><p>Docker相关的本地资源存放在/var/lib/docker/目录下，其中container目录存放容器信息，graph目录存放镜像信息，aufs目录下存放具体的镜像底层文件。</p>
<h2 id="构建Docker镜像应该遵循哪些原则？"><a href="#构建Docker镜像应该遵循哪些原则？" class="headerlink" title="构建Docker镜像应该遵循哪些原则？"></a>构建Docker镜像应该遵循哪些原则？</h2><p>整体远侧上，尽量保持镜像功能的明确和内容的精简，要点包括：</p>
<ul>
<li>尽量选取满足需求但较小的基础系统镜像，建议选择debian:wheezy镜像，仅有86MB大小</li>
<li>清理编译生成文件、安装包的缓存等临时文件</li>
<li>安装各个软件时候要指定准确的版本号，并避免引入不需要的依赖</li>
<li>从安全的角度考虑，应用尽量使用系统的库和依赖</li>
<li>使用Dockerfile创建镜像时候要添加.dockerignore文件或使用干净的工作目录</li>
</ul>
<h2 id="容器退出后，通过docker-ps-命令查看不到，数据会丢失么？"><a href="#容器退出后，通过docker-ps-命令查看不到，数据会丢失么？" class="headerlink" title="容器退出后，通过docker ps 命令查看不到，数据会丢失么？"></a>容器退出后，通过docker ps 命令查看不到，数据会丢失么？</h2><p>容器退出后会处于终止（exited）状态，此时可以通过<code>docker ps -a</code>查看，其中数据不会丢失，还可以通过docker start 来启动，只有删除容器才会清除数据。</p>
<h2 id="如何临时退出一个正在交互的容器的终端，而不终止它？"><a href="#如何临时退出一个正在交互的容器的终端，而不终止它？" class="headerlink" title="如何临时退出一个正在交互的容器的终端，而不终止它？"></a>如何临时退出一个正在交互的容器的终端，而不终止它？</h2><p>按Ctrl+p，后按Ctrl+q，如果按Ctrl+c会使容器内的应用进程终止，进而会使容器终止。</p>
<h2 id="很多应用容器都是默认后台运行的，怎么查看它们的输出和日志信息？"><a href="#很多应用容器都是默认后台运行的，怎么查看它们的输出和日志信息？" class="headerlink" title="很多应用容器都是默认后台运行的，怎么查看它们的输出和日志信息？"></a>很多应用容器都是默认后台运行的，怎么查看它们的输出和日志信息？</h2><p>使用docker logs，后面跟容器的名称或者ID信息</p>
<h2 id="可以在一个容器中同时运行多个应用进程吗？"><a href="#可以在一个容器中同时运行多个应用进程吗？" class="headerlink" title="可以在一个容器中同时运行多个应用进程吗？"></a>可以在一个容器中同时运行多个应用进程吗？</h2><p>一般不推荐在同一个容器内运行多个应用进程，如果有类似需求，可以通过额外的进程管理机制，比如supervisord来管理所运行的进程。</p>
<h2 id="如何控制容器占用系统资源（CPU，内存）的份额？"><a href="#如何控制容器占用系统资源（CPU，内存）的份额？" class="headerlink" title="如何控制容器占用系统资源（CPU，内存）的份额？"></a>如何控制容器占用系统资源（CPU，内存）的份额？</h2><p>在使用docker create命令创建容器或使用docker run 创建并运行容器的时候，可以使用-c|–cpu-shares[=0]参数来调整同期使用CPU的权重，使用-m|–memory参数来调整容器使用内存的大小。</p>
<h2 id="仓库（Repository）、注册服务器（Registry）、注册索引（Index）有何关系？"><a href="#仓库（Repository）、注册服务器（Registry）、注册索引（Index）有何关系？" class="headerlink" title="仓库（Repository）、注册服务器（Registry）、注册索引（Index）有何关系？"></a>仓库（Repository）、注册服务器（Registry）、注册索引（Index）有何关系？</h2><p>首先，仓库是存放一组关联镜像的集合，比如同一个应用的不同版本的镜像，注册服务器是存放实际的镜像的地方，注册索引则负责维护用户的账号，权限，搜索，标签等管理。注册服务器利用注册索引来实现认证等管理。</p>
<h2 id="如何更改Docker的默认存储设置？"><a href="#如何更改Docker的默认存储设置？" class="headerlink" title="如何更改Docker的默认存储设置？"></a>如何更改Docker的默认存储设置？</h2><p>Docker的默认存放位置是/var/lib/docker,如果希望将Docker的本地文件存储到其他分区，可以使用Linux软连接的方式来做。</p>
<h2 id="如何将一台宿主机的docker环境迁移到另外一台宿主机？"><a href="#如何将一台宿主机的docker环境迁移到另外一台宿主机？" class="headerlink" title="如何将一台宿主机的docker环境迁移到另外一台宿主机？"></a>如何将一台宿主机的docker环境迁移到另外一台宿主机？</h2><p>停止Docker服务，将整个docker存储文件复制到另外一台宿主机上，然后调整另外一台宿主机的配置即可</p>
<h2 id="为什么要用Docker-1"><a href="#为什么要用Docker-1" class="headerlink" title="为什么要用Docker"></a>为什么要用Docker</h2><ul>
<li>容器具有封闭性，在一个服务器里，可以有好多容器。每个容器他可以是系统，可以是服务、可以是应用，装着什么就是什么。</li>
<li>程序性迁移。容器内的环境是可以与程序相适应。而这个容器又可以在不同的生产环境里使用。试使用一下，windows的游戏我就放到一个linux里面玩，宝马的外壳里面是奔驰，而且可以是很多台奔驰。</li>
<li>速度快，定制快。持续交付与部署。（例如公司有多个项目，所使用的环境都好相似，由于客户不愿意给更多的钱购买专用的服务器，于是把这堆客户放在一个集群里面，共享他们的资源。)</li>
<li>容器服务是在集群里的。这样服务器的横向扩展（随时增加ECS）和纵向扩展（升级ECS配置）都是很容易的事，无限的扩充。</li>
</ul>
]]></content>
      <categories>
        <category>求职</category>
      </categories>
  </entry>
  <entry>
    <title>Spring面试总结</title>
    <url>/2020/03/16/spring-mian-shi-zong-jie/</url>
    <content><![CDATA[<h2 id="Spring-Aop实现方式，还有其他的什么方式实现"><a href="#Spring-Aop实现方式，还有其他的什么方式实现" class="headerlink" title="Spring Aop实现方式，还有其他的什么方式实现"></a>Spring Aop实现方式，还有其他的什么方式实现</h2><p>AOP 面向切面编程，是对面向对象的补充，处理系统中各个模块的横切关注点，常用于事务管理、日志模块、缓存等。</p>
<p>AOP实现的关键在于AOP框架自动创建AOP代理，常有以AspectJ为代表的静态代理，和以SpringAop为代表的动态代理</p>
<p>SpringAop的实现方式主要有通过反射的JDK动态代理和CGLIB(Code Generation Library).</p>
<a id="more"></a>
<ul>
<li><p>JDK动态代理：核心是<code>InvocationHandler</code>接口和<code>Proxy</code>类，目标类必须是个实现接口的类</p>
<ul>
<li><p>基于标准的JDK动态代理</p>
</li>
<li><p>只针对实现了接口的业务对象</p>
</li>
</ul>
</li>
<li><p>CGLIB：对于没有实现接口的类，SpringAOP使用CGLIB来动态代理目标类，<strong>注意CGLIB是通过继承来实现动态代理，对于final类不能通过CGLIB做动态代理</strong></p>
<ul>
<li><p>通过动态地对目标子类化来实现AOP代理</p>
</li>
<li><p>需要指定<code>@EnableAspectJAutoProxy(proxyTargetClass = true)</code>来强制使用</p>
</li>
<li><p>当目标类没有实现接口会默认使用CGLIB</p>
</li>
</ul>
</li>
</ul>
<p><strong>JDK动态代理示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>:datastructureimpl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:服务接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Huan Wang(https://github.com/njustwh2014)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>:2020-02-27 21:09</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口对应实现类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>:datastructureimpl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:服务实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Huan Wang(https://github.com/njustwh2014)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>:2020-02-27 21:11</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceImpl</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"add..."</span>);</span><br><span class="line">        <span class="keyword">this</span>.num+=num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//InvocationHandler实现类 这里我类的名字拼错了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>:datastructureimpl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:Invocation实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Huan Wang(https://github.com/njustwh2014)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>:2020-02-27 21:13</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInnovacation</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInnovacation</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.target=o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//方法之前前操作</span></span><br><span class="line">        System.out.println(method.getName()+<span class="string">"执行前"</span>);</span><br><span class="line">        Object result=method.invoke(target,args);<span class="comment">//注意不是proxy，不然会循环invoke</span></span><br><span class="line">        <span class="comment">//方法执行后操作</span></span><br><span class="line">        System.out.println(method.getName()+<span class="string">"执行后"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Service service=<span class="keyword">new</span> ServiceImpl(<span class="number">10</span>);</span><br><span class="line">        MyInnovacation myInnovacation=<span class="keyword">new</span> MyInnovacation(service);</span><br><span class="line">        Service proxyService= (Service) Proxy.newProxyInstance(service.getClass().getClassLoader(),service.getClass().getInterfaces(),myInnovacation);</span><br><span class="line"></span><br><span class="line">        proxyService.add(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        proxyService.add(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"current num in target: "</span>+(<span class="keyword">int</span>)proxyService.search());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CGLib示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标类 不需要实现统一接口</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>:datastructureimpl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:未实现统一接口类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Huan Wang(https://github.com/njustwh2014)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>:2020-02-27 21:37</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cglib动态代理的目标类必须要有无参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num+=num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现动态代理类CglibProxy，需要实现MethodInterceptor接口的intercept方法。该代理中在add方法前后加入了自定义的切面逻辑，目标类add方法执行语句为proxy.invokeSuper(object, args);</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>:datastructureimpl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:cglib动态代理类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Huan Wang(https://github.com/njustwh2014)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>:2020-02-27 21:39</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before...."</span>);</span><br><span class="line">        Object result=methodProxy.invokeSuper(o,args);</span><br><span class="line">        System.out.println(<span class="string">"after..."</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理工厂类 用于获取增强后的目标类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>:datastructureimpl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:增强类的工厂类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Huan Wang(https://github.com/njustwh2014)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>:2020-02-27 21:50</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 获得增强后的目标类，也就是切入逻辑advice之后的目标类</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span>: [proxy]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>: cn.edu.seu.wh.aop.cglib.proxy.Base</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@thorws</span>:</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: Mr.Wang</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span>: 2020/2/27</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Base <span class="title">getInstance</span><span class="params">(CglibProxy proxy)</span></span>&#123;</span><br><span class="line">        Enhancer enhancer=<span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(Base.class);</span><br><span class="line">        <span class="comment">//回调方法的参数为代理类对象CglibProxy，最后增强目标类调用的是代理类对象CglibProxy中的intercept方法</span></span><br><span class="line">        enhancer.setCallback(proxy);</span><br><span class="line">        <span class="comment">//此刻已是增强后的目标类，继承于源目标类</span></span><br><span class="line">        Base base=(Base)enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CglibProxy cglibProxy=<span class="keyword">new</span> CglibProxy();</span><br><span class="line">        <span class="comment">//base为增强后的目标类</span></span><br><span class="line">        Base base=CglibProxyFactory.getInstance(cglibProxy);</span><br><span class="line">        base.add(<span class="number">10</span>);</span><br><span class="line">        base.search();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h2><h3 id="IOC容器到底是个什么东西"><a href="#IOC容器到底是个什么东西" class="headerlink" title="IOC容器到底是个什么东西"></a>IOC容器到底是个什么东西</h3><ul>
<li>1.我把它看做是一个桶，具体例子有（XMLBeanDefinition、ApplicationContext）这两个都是IOC容器的具体实现。</li>
<li>2.这个桶implements接口BeanFactory.桶里面持有一个HashMap装的是BeanDefinition。</li>
</ul>
<h3 id="IOC容器的实现过程"><a href="#IOC容器的实现过程" class="headerlink" title="IOC容器的实现过程"></a>IOC容器的实现过程</h3><ul>
<li>1.初始化一个接口BeanFactory的实现</li>
<li>2.初始化一个Resource</li>
<li>3.初始化一个BeanDefinitionReader来与BeanFactory的实现装配。</li>
<li>4.通过装配后的BeanDefinitionReader来去读取resource</li>
</ul>
<p>例如XmlBeanFactory：初始化XmlBeanDefinitionReader需要一个Resource对象（XML文件中的BeanDefinition）来读取，这个Resource对象在代码中是这么定义的 ClassPathResource resource = new ClassPathR（“XML文件的路径”）；</p>
<h3 id="从类的角度去理解一下IOC容器的初始化过程"><a href="#从类的角度去理解一下IOC容器的初始化过程" class="headerlink" title="从类的角度去理解一下IOC容器的初始化过程"></a>从类的角度去理解一下IOC容器的初始化过程</h3><ul>
<li>1.获取BeanDefinition<br>AbstractBeanDefinitionReader是XmlBeanDefinitionReader的父类,调用loadBeanDefinition()方法来加载BeanDefinition。该方法（loadBeanDefinition()）会有两个过程：<ul>
<li>1.document会被解析成BeanDefinitionParseDelegate（Class）.</li>
<li>2.创建DefaultBeanDefinitionDocumentReader来解析成为springIOC容器需要的BeanDefinition<br>注：BeanDefinition包括了被依赖的对象的别名、ID等等信息。</li>
</ul>
</li>
<li>2.把获取到的BeanDefinition注册到IOC容器的HashMap里面去<ul>
<li>1.在DefaultListtableBeanFactory中实现了BeanDefinitionRegistry接口。</li>
<li>在完成BeanDefinition的注册之后IOC容器的初始化就此完成。</li>
</ul>
</li>
<li>以上就是注入的过程了。在IOC容器中的BeanDefinition是怎么注入的呢。<ul>
<li>1.注入由AbstractAutowireCapableBeanFactory中的方法populateBean()方法完成（包括了对autoware属性的处理）</li>
<li>2.在该方法中通过BeanDefinitionResolver来对BeanDefinition进行解析，并注入到property中</li>
<li>3.至此完成IOC容器的初始化以及依赖注入。<br>注</li>
</ul>
<ul>
<li>1.具体的BeanWrapper的setPropertyValues.</li>
<li>2.在IOC容器初始化完成之后，可以通过lazy-init属性来设置是否立即进行依赖注入。lazy-init属性定义在BeanDefinition中。</li>
<li>3.IOC容器的后置监听器BeanPostProcessor.</li>
</ul>
</li>
</ul>
<h2 id="IOC容器初始化过程"><a href="#IOC容器初始化过程" class="headerlink" title="IOC容器初始化过程"></a>IOC容器初始化过程</h2><p>IOC初始化过程主要包括<strong>Resource资源定位，BeanDefinition载入，BeanDefinition注册</strong>三个步骤。</p>
<ul>
<li>Resource资源定位</li>
</ul>
<p>Resource资源定位是指BeanDefinition资源定位，IOC容器找数据的过程。Spring通过外部资源，如xml文件或注解形式定描述一个Bean对象，IOC容器第一步就是需要定位Resource资源，由ResourceLoader通过统一统一的Resource接口实现。</p>
<ul>
<li>BeanDefinition载入</li>
</ul>
<p>载入的过程就是把定义好Bean表示成IOC容器内部数据结构，即BeanDefinition.在配置文件中每一个Bean都对应着一个BeanDefinition对象。</p>
<p>通过BeanDefinitionReader读取，解析Resource定位的资源，将用户定义好的Bean表示成IOC容器的内部数据结构BeanDefinition。</p>
<p>在IOC容器内部维护着一个BeanDefinitionMap的数据结构，通过BeanDefinitionMap，IOC容器可以对Bean进行更好的管理</p>
<ul>
<li>BeanDefinition注册</li>
</ul>
<p>注册就是将前面的BeanDefition保存到Map中的过程，通过BeanDefinitionRegistry接口来实现注册。</p>
<p>IOC容器的初始化过程就是对Bean定义资源的定位、载入和注册，此时容器对Bean的依赖注入并没有发生。依赖注入时刻由<code>lazy-init=false</code>决定。</p>
<h2 id="BeanFactory与FactoryBean的区别"><a href="#BeanFactory与FactoryBean的区别" class="headerlink" title="BeanFactory与FactoryBean的区别"></a>BeanFactory与FactoryBean的区别</h2><ul>
<li><p>BeanFactory: Bean工厂，是一个工厂，是Spring IOC容器的最顶层接口，用于管理bean，即实例化、定位和配置应用程序中的对象以及建立这些对象间的依赖关系。</p>
</li>
<li><p>FactoryBean: 工厂Bean，是一个Bean。作用是产生其他Bean实例，需要提供一个工厂方法，该方法用于返回其他Bean实例。</p>
</li>
</ul>
<h2 id="接着说说BeanFactory与ApplicationContext区别"><a href="#接着说说BeanFactory与ApplicationContext区别" class="headerlink" title="接着说说BeanFactory与ApplicationContext区别"></a>接着说说BeanFactory与ApplicationContext区别</h2><p>BeanFactory是Spring里面最顶层的接口，包含了各种Bean的定义，读取Bean配置文档，管理Bean的加载、实例化，控制Bean的生命周期，维护Bean之间的依赖关系。</p>
<p>ApplicationContext接口是BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p>
<ul>
<li><p>继承了MessageSource，支持国际化。</p>
</li>
<li><p>提供了统一的资源文件访问方式。</p>
</li>
<li><p>提供在Listener中注册Bean的事件。</p>
</li>
<li><p>提供同时加载多个配置文件的功能。</p>
</li>
<li><p>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</p>
</li>
</ul>
<p><strong>ApplicationContext 三种常见的实现方式:</strong></p>
<ul>
<li><p>FileSystemXmlApplicationContext：此容器从一个XML文件中加载Bean的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</p>
</li>
<li><p>ClassPathXmlApplicationContext：此容器也从一个XML文件中加载Bean的定义，需要正确设置classpath因为这个容器将在classpath里找Bean配置。</p>
</li>
<li><p>WebXmlApplicationContext：此容器加载一个XML文件，定义了一个WEB应用的所有Bean。</p>
</li>
</ul>
<p><strong>在创建Bean和内存方面的区别</strong></p>
<ul>
<li><p><strong>BeanFactory采用的是延迟加载形式来注入Bean的</strong>，即只有在使用到某个Bean时(调用<code>getBean()</code>)，才对该Bean进行加载实例化。这样，就不能发现一些存在于Spring配置中的问题。如果Bean的某一个属性没有注入，BeanFactory加载后，直至第一次使用调用getBean方法才会抛出异常。</p>
</li>
<li><p>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例Bean ,确保当需要的时候，可以直接获取。</p>
</li>
<li><p>相对于基本的BeanFactory，ApplicationContext不足之处是占用内存空间。当应用程序配置Bean较多时，程序启动较慢，因为其一次性创建了所有的Bean。</p>
</li>
</ul>
<p><strong>二者优缺点对比</strong></p>
<blockquote>
<p>BeanFactory的优缺点：</p>
</blockquote>
<ul>
<li><p>优点：应用启动的时候占用资源很少，对资源要求较高的应用，比较有优势；</p>
</li>
<li><p>缺点：运行速度会相对来说慢一些。而且有可能会出现空指针异常的错误，而且通过Bean工厂创建的Bean生命周期会简单一些。</p>
</li>
</ul>
<blockquote>
<p>ApplicationContext的优缺点：</p>
</blockquote>
<ul>
<li><p>优点：所有的Bean在启动的时候都进行了加载，系统运行的速度快；在系统启动的时候，可以发现系统中的配置问题。</p>
</li>
<li><p>缺点：把费时的操作放到系统启动中完成，所有的对象都可以预加载，缺点就是内存占用较大。</p>
</li>
</ul>
<h2 id="Spring如何生成一个Bean"><a href="#Spring如何生成一个Bean" class="headerlink" title="Spring如何生成一个Bean"></a>Spring如何生成一个Bean</h2><ul>
<li>BeanDefinition解析：调用容器中InstantiationAwareBeanPostProcessor的postProcessBeforeInstantiation()方法，可以在Bean实例化前修改BeanDefinition。</li>
<li>实例化：将指定的BeanDefinition转换成BeanWrapper，然后调用createBeanInstance创建Bean的实例。Bean的实例化有多种策略，如工厂方法、指定参数构造器和默认无参构造器等。总之，createBeanInstance()方法会返回一个刚实例化好的、属性未赋值的空Bean。</li>
<li>属性填充：调用populateBean()方法，为Bean进行属性的赋值和依赖的注入。</li>
<li>属性填充后置处理：调用容器中InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation()方法，进行属性填充后处理。</li>
<li>初始化前置处理：调用BeanPostProcessor的postProcessBeforeInitialization()方法进行初始化前置处理。</li>
<li>初始化：调用Bean的初始化方法，顺序为：InitializingBean的afterPropertiesSet() -&gt; 注册的init-method。</li>
<li>初始化后置处理：调用BeanPostProcessor的postProcessAfterInitialization()执行初始化后置处理。</li>
<li>调用registerDisposableBeanIfNecessary()方法，注册Bean的销毁处理逻辑：将所有实现了DisposableBean接口的或者注册了destroy-method方法的Bean,封装成一个DisposableBean,将其销毁的回调注册到容器中。</li>
</ul>
<blockquote>
<p>对应源码流程</p>
</blockquote>
<ul>
<li>实例化BeanFactoryPostProcessor实现类</li>
<li>调用BeanFactoryPostProcessor#postProcessBeanFactory</li>
<li>实例化BeanPostProcessor实现类</li>
<li>调用InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation</li>
<li>实例化Bean</li>
<li>调用InstantiationAwareBeanProcessor#postProcessAfterInstantiation</li>
<li>调用InstantiationAwareBeanPostProcessor#postProcessPropertyValues</li>
<li>为Bean注入属性</li>
<li>调用BeanNameAware#setBeanName</li>
<li>调用BeanClassLoaderAware#setBeanClassLoader</li>
<li>调用BeanFactoryAware#setBeanFactory</li>
<li>调用BeanPostProcessor#postProcessBeforeInitialization</li>
<li>调用InitializingBean#afterPropertiesSet</li>
<li>调用Bean的init-method</li>
<li>调用BeanPostProcessor#postProcessAfterInitialization</li>
</ul>
<h2 id="Bean循环依赖如何解决"><a href="#Bean循环依赖如何解决" class="headerlink" title="Bean循环依赖如何解决"></a>Bean循环依赖如何解决</h2><p>不是所有的循环依赖Spring都能够解决的。</p>
<ul>
<li>对于最简单的情况，bean为单例,且使用Autowired或者setter注入，Spring是可以解决这样的循环依赖的。在一个Bean实例化后,会调用addSingletonFactory方法，在IOC容器中通过一个ObjectFactory暴露出可以获取还未完全初始化完毕的bean引用。若存在循环依赖，则依赖的bean可以在调用getBean时通过getSingleton方法获取到循环依赖的bean。</li>
<li>但是Spring是不允许出现原型环的，举例来说,BeanA和BeanB循环依赖且scope都为prototype。因为prototype的bean，不会触发addSingletonFactory，即每次get这样的bean都会新创建一个。所以创建BeanA需要注入一个BeanB，而这个BeanB又需要注入一个新的BeanA，这样的循环依赖是没办法解决的。Spring会判断当前bean是否是prototype并且已经在创建中，然后抛出异常。</li>
<li>对于构造器依赖，可以作一下讨论，下面讨论的bean的scope都为单例<ul>
<li>如果BeanA构造器中依赖BeanB，并且BeanA先创建，则无论BeanB以哪种形式依赖BeanA，都没办法解决这样的循环依赖。因为实例化BeanA需要先得到BeanB（此时还未提前暴露引用），BeanB依赖BeanA，但是拿不到BeanA提前暴露的引用，这就形成了无限循环。这种情况会在BeanB试图获取BeanA时在beforeSingletonCreation方法抛出异常。</li>
<li>如果BeanA非构造器依赖BeanB，并且BeanA先创建，BeanB即使构造器依赖BeanA，也可以进行解决循环依赖。 因为这种情况BeanB可以拿到BeanA提前暴露的引用。</li>
</ul>
</li>
</ul>
<h2 id="那些Aware究竟是什么"><a href="#那些Aware究竟是什么" class="headerlink" title="那些Aware究竟是什么"></a>那些Aware究竟是什么</h2><p>Spring中有很多XXXAware接口，从字面意思上很容易理解：就是bean能够“感知”XXX。通常这些接口的方法都是setXXX。在项目里做一个工具类实现ApplicationContextAware接口，里面可以塞一个ApplicationContext实例到静态域中，在代码中就可以很方便获取到Spring上下文进行一些操作。</p>
<p>那么Spring对于这些Aware接口是在哪一步调用的呢？答案其实在上面的源码分析中已经提到。在AbstractAutowireCapableBeanFactory#initializeBean方法中，Spring默认会对实现BeanNameAware, BeanClassLoaderAware, BeanFactoryAware进行回调，为它们注入beanName, classLoader, beanFactory等。</p>
<p>而对于更多的一些扩展，Spring基于那些processor实现了很强的可拓展性与可插拔性。比如我们非常熟悉的ApplicationContextAware接口实际上是通过ApplicationContextAwareProcessor来实际调用的，它继承了BeanPostProcessor，其中postProcessBeforeInitialization方法中会对EnvironmentAware, EmbeddedValueResolverAware, ApplicationContextAware等等一系列Aware接口的子类Bean进行回调，为其注入相关资源。</p>
<p>那么ApplicationContextAwareProcessor是什么时候出现在BeanPostProcessor集合中的呢？在AbstractApplicationContext#prepareBeanFactory方法中，Spring有如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure>

<p>也就是当Spring上下文在初始化prepareBeanFactory的时候就已经添加了ApplicationContextAwareProcessor。</p>
<h2 id="Spring加载过程"><a href="#Spring加载过程" class="headerlink" title="Spring加载过程"></a>Spring加载过程</h2><p><img src="/2020/03/16/spring-mian-shi-zong-jie/springboot%E5%90%AF%E5%8A%A8%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Springboot启动结构图"></p>
<p><a href="https://blog.csdn.net/hfmbook/article/details/100507083" target="_blank" rel="noopener">参考文章</a></p>
<h2 id="spring与springmvc的关系"><a href="#spring与springmvc的关系" class="headerlink" title="spring与springmvc的关系"></a>spring与springmvc的关系</h2><p>Spring是IOC和AOP的容器框架，SpringMVC是基于Spring功能之上添加的Web框架，想用SpringMVC必须先依赖Spring。</p>
<h2 id="SpringBoot与SSM-SpringMVC-Spring-MyBatis-框架区别"><a href="#SpringBoot与SSM-SpringMVC-Spring-MyBatis-框架区别" class="headerlink" title="SpringBoot与SSM(SpringMVC + Spring + MyBatis)框架区别"></a>SpringBoot与SSM(SpringMVC + Spring + MyBatis)框架区别</h2><p><strong>回答：</strong></p>
<ul>
<li>springboot是什么？有什么作用？什么场景下使用？</li>
<li>SSM是什么？有什么作用？什么场景下使用？</li>
<li>两个相比较，各自的优缺点</li>
</ul>
<h3 id="什么是SpringBoot"><a href="#什么是SpringBoot" class="headerlink" title="什么是SpringBoot?"></a>什么是SpringBoot?</h3><p>从本质上来说，Spring Boot就是Spring,它做了那些没有它你也会去做的Spring Bean配置。</p>
<h4 id="SpringBoot的作用？"><a href="#SpringBoot的作用？" class="headerlink" title="SpringBoot的作用？"></a>SpringBoot的作用？</h4><p>它使用“<strong>习惯优于配置</strong>”（项目中存在大量的配置，此外还内置了一个习惯性的配置，让你无需手动进行配置）的理念让你的项目快速运行起来。使用SpringBoot很容易创建一个<strong>独立运行（运行jar,内嵌Servlet容器）、准生产级别的基于Spring框架的项目</strong>，使用SpringBoot你可以不用或者只需要很少的Spring配置。</p>
<h4 id="SpringBoot的优点？"><a href="#SpringBoot的优点？" class="headerlink" title="SpringBoot的优点？"></a>SpringBoot的优点？</h4><ul>
<li>Spring由于其繁琐的配置，一度被人认为“配置地狱”，各种XML、Annotation配置，让人眼花缭乱，而且如果出错了也很难找出原因。</li>
<li>SpringBoot帮助开发者快速启动一个Web容器；</li>
<li>SpringBoot继承了原有Spring框架的优秀基因；</li>
<li>SpringBoot简化了使用Spring的过程。</li>
</ul>
<h3 id="SpringBoot的缺点？"><a href="#SpringBoot的缺点？" class="headerlink" title="SpringBoot的缺点？"></a>SpringBoot的缺点？</h3><p><strong>SpringBoot作为一个微框架，离微服务的实现还是有距离的。</strong>没有提供相应的<strong>服务发现和注册</strong>的配套功能，自身的acturator所提供的监控功能，也需要与现有的监控对接。没有配套的安全管控方案，对于REST的落地，还需要自行结合实际进行URI的规范化工作。</p>
<h3 id="什么是SSM？"><a href="#什么是SSM？" class="headerlink" title="什么是SSM？"></a>什么是SSM？</h3><p>SSM（Spring+SpringMVC+MyBatis）框架集由Spring、SpringMVC、MyBatis三个开源框架整合而成，常作为数据源较简单的web项目的框架。</p>
<ul>
<li>spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。</li>
<li>SpringMVC分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。</li>
<li>MyBatis是一个支持普通SQL查询，存储过程和高级映射的优秀持久层框架。</li>
</ul>
<h3 id="SSM有什么用？"><a href="#SSM有什么用？" class="headerlink" title="SSM有什么用？"></a>SSM有什么用？</h3><ul>
<li><p>SpringMVC：</p>
<ul>
<li>1.客户端发送请求到DispacherServlet（分发器）</li>
<li>2.由DispacherServlet控制器查询HanderMapping，找到处理请求的Controller</li>
<li>3.Controller调用业务逻辑处理后，返回ModelAndView</li>
<li>4.DispacherSerclet查询视图解析器，找到ModelAndView指定的视图</li>
<li>5.视图负责将结果显示到客户端</li>
</ul>
</li>
<li><p>Spring：IOC、AOP、事务管理<br>我们平时开发接触最多的估计就是IOC容器，它可以装载bean（也就是我们Java中的类，当然也包括service dao里面的），有了这个机制，我们就不用在每次使用这个类的时候为它初始化，很少看到关键字new。另外spring的aop，事务管理等等都是我们经常用到的。</p>
</li>
<li><p>Mybatis：</p>
<ul>
<li>mybatis是对jdbc的封装，它让数据库底层操作变的透明。</li>
<li>mybatis的操作都是围绕一个sqlSessionFactory实例展开的。</li>
<li>mybatis通过配置文件关联到各实体类的Mapper文件，Mapper文件中配置了每个类对数据库所需进行的sql语句映射。</li>
<li>在每次与数据库交互时，通过sqlSessionFactory拿到一个sqlSession，再执行sql命令。</li>
</ul>
</li>
</ul>
<h3 id="SSM的优缺点？"><a href="#SSM的优缺点？" class="headerlink" title="SSM的优缺点？"></a>SSM的优缺点？</h3><p>SSM优缺点应该分开来说的，比如</p>
<ul>
<li>1）spring 不说了，核心ioc、aop技术，ioc解耦，使得代码复用，可维护性大幅度提升，aop提供切面编程，同样的增强了生产力。</li>
<li>2）spring mvc嘛，是对比struts2等mvc框架来说的，不说struts2爆出的那么多安全漏洞，而且是类拦截，所有Action变量共享，同时是filter入口的，而spring mvc是方法拦截，controller独享request response数据，采用的serlvet入口，与spring无缝对接。开发而言，spring mvc更加轻量和低入门。</li>
<li>3）mybatis嘛，看业务场景，主要是mybatis的sql可以由开发者去掌控和调优，相对hibernate等orm框架来说，更加直观。在业务场景比较复杂，sql好多联合关联的情况下，mybatis谁用谁知道。当然缺点就是对sql不熟悉的开发者就不太友好了。</li>
</ul>
<h3 id="二者相比较优缺点？"><a href="#二者相比较优缺点？" class="headerlink" title="二者相比较优缺点？"></a>二者相比较优缺点？</h3><p>这两者对比起来有点奇怪。因为<strong>SSM是WEB应用框架，涵盖整个应用层</strong>，而<strong>springboot你可以看做一个启动、配置、快速开发的辅助框架，本身针对的是微服务</strong>。</p>
<p>springboot只是为了提高开发效率，是为了提升生产力的：</p>
<ul>
<li>1、springboot一个应用是一个可执行jar（启动类main方法启动web应用），而不像传统的war，内嵌tomcat容器，可以jar形式启动一个服务，可以快速部署发布web服务，微服务最好不过了。</li>
<li>2、将原有的xml配置，简化为java配置</li>
<li>3、当然结构可能跟一般的ssm有一定区别，但其实主要是在资源文件。</li>
</ul>
<h2 id="SpringBoot可以借鉴的设计模式"><a href="#SpringBoot可以借鉴的设计模式" class="headerlink" title="SpringBoot可以借鉴的设计模式"></a>SpringBoot可以借鉴的设计模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式，主要目的是保证实例的独一无二，提高资源的重复利用。单例模式的难点就在于需要通过代码来维护系统中实例的唯一性，需要确保各种线程不安全环境下实例的独一性。</p>
<p>常用于配置文件的读取，监控程序，IOC容器等，spring中最常用的单例实现方式就是注册登记式的单例模式，这个后面看源码的时候，会深入了解</p>
<p>一句话总结：保证独一无二</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>原型模式其实就是针对复制而言的一种模式，原型模式中需要弄清<strong>浅复制和深复制</strong>的区别。</p>
<ul>
<li>浅复制：对于数据类型是基本数据类型的成员变量，浅复制直接进行值的传递，即将原始对象中属性的值复制一份给新对象；对于引用数据类型的成员变量，浅复制就只是传递引用，这样使得两个对象之间其实操作的是同一份数据</li>
<li>深复制：就是在浅复制的基础上，完成对象引用的深层次的复制。深复制不仅要复制对象所有的基本数据类型，还要在复制过程中为原有的引用数据类型开辟新的存储空间，将引用对象的数据拷贝到新开辟的存储空间中。一定程度上来说，对象进行深复制就是要对整个对象图进行复制。</li>
</ul>
<p>更为形象的图形解释可以参考这篇博客——深复制与浅复制的区别</p>
<p><strong>原型模式主要就是应用于对象间的复制。spring中我们在配置对象的scope的时候，将scope配置成为prototype，即将bean配置成多例的，其中就会用到原型模式。</strong></p>
<p>一句话总结：复制作用</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>从总体来看代理模式的作用就是在某一个类中某一指定的方法执行之前和执行之后，织入一些增强逻辑，这个理解依旧有点绕，但是结合AOP来理解就不难了，AOP的主要作用就是在目标方法的执行前和执行后织入一些增强的逻辑。</p>
<p>代理通常分为<strong>静态代理和动态代理</strong>，由于静态代理在扩展性方面的不足才引出了动态代理。</p>
<blockquote>
<p>引申：静态代理需要目标对象与代理对象均要实现同一接口，当接口添加新方法时，代理对象与目标对象都要实现该方法，从而导致扩展性不足。</p>
</blockquote>
<p>动态代理的实现方式常见的有两种：<strong>一种是JDK Proxy，另一种是CgLib</strong>，前者是动态植入，后者是继承；前者要求目标类要实现一个接口，目的就是方便获取方法信息，方便JDK利用反射动态调用。使用JDK动态代理的时候，增强的逻辑类需要实现InvocationHandler接口，在其中的invoke方法中去编写增强逻辑。CGLib相对来说就容易的多，具体可以见上文。</p>
<p><strong>动态代理在spring中用的较多，典型的AOP就是用的代理。除此之外，结合实际来看，如果针对原有的目标需要动态进行增强都可以利用动态代理模式</strong></p>
<p>一句话总结：买票找黄牛，办事找代理。</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式是比较好理解的一种设计模式，该模式就是封装了一些算法供用户选择，根据用户的选择如何确定到指定的算法策略的过程中，为了避免使用if…else或者switch这种选择语句，就需要结合工厂模式进行使用，因此策略模式一定程度上并不单独使用</p>
<p><strong>使用场景：支付方式的选择</strong></p>
<p>一句话总结：我走那条路，我做主</p>
<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>模板方法模式也是一个比较好理解的设计模式，无非就是在估计的流程中，加入一些不同的算法实现，最终产生出不同的结果而已，<strong>提供的模板一般采用抽象类来实现，需要加入自己的算法的时候，就通过继承这个抽象类来完成。</strong></p>
<p><strong>使用场景：JdbcTemplate，工作流，spring-orm</strong></p>
<p>一句话总结：流程标准化，原料自己加</p>
<h3 id="委派模式"><a href="#委派模式" class="headerlink" title="委派模式"></a>委派模式</h3><p><strong>委派模式某一种程度上是代理和策略模式的结合</strong>，在实现过程中，最重要的就是对委派列表的维护，这在之前的博客中实现的比较简单，直接值委派者中维护了引用。</p>
<p><strong>使用场景：spring中的DispatcherServlet、Delegate命名结尾的都是委派模式</strong></p>
<p>一句话总结：项目经理委派活给普通员工</p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p><strong>适配器模式从命名来看也能理解其意思，需要和装饰者模式区分开来。</strong>针对两者的区别还是列出一个类图吧。</p>
<p><img src="/2020/03/16/spring-mian-shi-zong-jie/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE%E5%AF%B9%E6%AF%94.png" alt="适配器模式与装饰者模式类图对比"></p>
<p>使用场景：DataAdapter</p>
<p>一句话总结：转换头</p>
<h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>一定程度上来讲，装饰者模式与适配器模式有点类似，两者的具体区别上面的图中已经很好的展示出来了</p>
<p><strong>使用场景：spring中以Decorate结尾的都是使用的装饰者模式，IO流的设计，数据源</strong></p>
<p>一句话总结：同宗同源的增强</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>只需要理清楚两个角色，<strong>消息发布者和消息订阅者</strong>，难点在于消息发布者如何维护多个消息订阅者的信息</p>
<p><strong>使用场景：消息队列，swing中的监听器，spring中的监听器</strong></p>
<p>一句话总结：完成时通知一下。</p>
<h2 id="Springboot请求处理过程"><a href="#Springboot请求处理过程" class="headerlink" title="Springboot请求处理过程"></a>Springboot请求处理过程</h2><p><a href="https://blog.csdn.net/sinat_37255539/article/details/103838784?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener"><strong>参考文章</strong></a></p>
]]></content>
      <categories>
        <category>求职</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程面试总结</title>
    <url>/2020/03/16/bing-fa-bian-cheng-mian-shi-zong-jie/</url>
    <content><![CDATA[<h2 id="什么是指令重排序？"><a href="#什么是指令重排序？" class="headerlink" title="什么是指令重排序？"></a>什么是指令重排序？</h2><p>为了提高性能，编译器和处理器通常会对指令进行重排序，重排序指从源代码到指令序列的重排序，分为三种：① 编译器优化的重排序，编译器在不改变单线程程序语义的前提下可以重排语句的执行顺序。② 指令级并行的重排序，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。③ 内存系统的重排序。</p>
<h2 id="as-if-serial-是什么？"><a href="#as-if-serial-是什么？" class="headerlink" title="as-if-serial 是什么？"></a>as-if-serial 是什么？</h2><p>不管怎么重排序，单线程程序的执行结果不能改变，编译器和处理器必须遵循as-if-serial语义。</p>
<p>为了遵循 as-if-serial，编译器和处理器不会对存在数据依赖关系的操作重排序，因为这种重排序会改变执行结果。但是如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。</p>
<p>as-if-serial 把单线程程序保护起来，给程序员一种幻觉：单线程程序是按程序的顺序执行的。</p>
<h2 id="happens-before-是什么？"><a href="#happens-before-是什么？" class="headerlink" title="happens-before 是什么？"></a>happens-before 是什么？</h2><p>先行发生原则，JMM定义的两项操作间的偏序关系，是判断数据是否存在竞争的重要手段。</p>
<p>JMM 将 happens-before 要求禁止的重排序按是否会改变程序执行结果分为两类。对于会改变结果的重排序 JMM 要求编译器和处理器必须禁止，对于不会改变结果的重排序，JMM 不做要求。</p>
<p>JMM 存在一些天然的 happens-before 关系，无需任何同步器协助就已经存在。如果两个操作的关系不在此列，并且无法从这些规则推导出来，它们就没有顺序性保障，虚拟机可以对它们随意进行重排序。</p>
<ul>
<li>程序次序规则：一个线程内写在前面的操作先行发生于后面的。</li>
<li>管程锁定规则： unlock 操作先行发生于后面对同一个锁的 lock 操作。</li>
<li>volatile 规则：对 volatile 变量的写操作先行发生于后面的读操作。</li>
<li>线程启动规则：线程的 start 方法先行发生于线程的每个动作。</li>
<li>线程终止规则：线程中所有操作先行发生于对线程的终止检测。</li>
<li>对象终结规则：对象的初始化先行发生于 finalize 方法。</li>
<li>传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C 。</li>
</ul>
<h2 id="as-if-serial-和-happens-before-有什么区别？"><a href="#as-if-serial-和-happens-before-有什么区别？" class="headerlink" title="as-if-serial 和 happens-before 有什么区别？"></a>as-if-serial 和 happens-before 有什么区别？</h2><p>as-if-serial 保证单线程程序的执行结果不变，happens-before 保证正确同步的多线程程序的执行结果不变。</p>
<p>这两种语义的目的都是为了在不改变程序执行结果的前提下尽可能提高程序执行并行度。</p>
<a id="more"></a>

<h2 id="进程、线程和协程"><a href="#进程、线程和协程" class="headerlink" title="进程、线程和协程"></a>进程、线程和协程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是系统资源分配的最小单位, 系统由一个个进程(程序)组成。一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。</p>
<ul>
<li>文本区域存储处理器执行的代码</li>
<li>数据区域存储变量和进程执行期间使用的动态分配的内存；</li>
<li>堆栈区域存储着活动过程调用的指令和本地变量。</li>
</ul>
<p>因此进程的创建和销毁都是相对于系统资源,所以是一种比较昂贵的操作。</p>
<p>进程有三个状态:</p>
<ul>
<li>等待态：等待某个事件的完成；</li>
<li>就绪态：等待系统分配处理器以便运行；</li>
<li>运行态：占有处理器正在运行。</li>
</ul>
<p>进程是抢占式的争夺CPU运行自身,而CPU单核的情况下同一时间只能执行一个进程的代码,但是多进程的实现则是通过CPU飞快的切换不同进程,因此使得看上去就像是多个进程在同时进行.</p>
<p><strong>通信问题:</strong>由于进程间是隔离的,各自拥有自己的内存内存资源, 因此相对于线程比较安全, 所以不同进程之间的数据只能通过 IPC(Inter-Process Communication) 进行通信共享.</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul>
<li><strong>线程属于进程</strong></li>
<li><strong>线程共享进程的内存地址空间</strong></li>
<li><strong>线程几乎不占有系统资源</strong></li>
<li><strong>通信问题:</strong>进程相当于一个容器,而线程而是运行在容器里面的,因此对于容器内的东西,线程是共同享有的,因此线程间的通信可以直接通过全局变量进行通信,但是由此带来的例如多个线程读写同一个地址变量的时候则将带来不可预期的后果,因此这时候引入了各种锁的作用,例如互斥锁等。</li>
<li>多线程是不安全的,当一个线程崩溃了,会导致整个进程也崩溃了,即其他线程也挂了。但多进程而不会,一个进程挂了,另一个进程依然照样运行。</li>
<li>进程是系统分配资源的最小单位，线程是CPU调度的最小单位。由于默认进程内只有一个线程,所以多核CPU处理多进程就像是一个进程一个核心</li>
</ul>
<h3 id="线程和进程的上下文切换"><a href="#线程和进程的上下文切换" class="headerlink" title="线程和进程的上下文切换"></a>线程和进程的上下文切换</h3><p><strong>进程切换分3步:</strong></p>
<ul>
<li>切换页目录以使用新的地址空间</li>
<li>切换内核栈</li>
<li>切换硬件上下文</li>
</ul>
<p><strong>而线程切换只需要第2、3步,因此进程的切换代价比较大</strong></p>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><ul>
<li>协程是属于线程的。协程程序是在线程里面跑的，因此协程又称微线程和纤程等</li>
<li>协没有线程的上下文切换消耗。协程的调度切换是用户(程序员)手动切换的,因此更加灵活,因此又叫用户空间线程.</li>
<li>原子操作性。由于协程是用户调度的，所以不会出现执行一半的代码片段被强制中断了，因此无需原子操作锁。</li>
</ul>
<h3 id="协程的实现：迭代器和生成器"><a href="#协程的实现：迭代器和生成器" class="headerlink" title="协程的实现：迭代器和生成器"></a>协程的实现：迭代器和生成器</h3><ul>
<li>迭代器： 实现了迭代接口的类,接口函数例如:current,key,next,rewind,valid。迭代器最基本的规定了对象可以通过next返回下一个值，而不是像数组，列表一样一次性返回。语言实现：在Java的foreach遍历迭代器对(数组)，Python的for遍历迭代器对象(tuple，list，dist)。</li>
<li>生成器： 使用 yield 关键字的函数,可以多次返回值，生成器实际上也算是实现了迭代器接口(协议)。即生成器也可通过next返回下一个值。</li>
</ul>
<p><strong>协程举例：</strong>在Python中，使用了yield的函数为生成器函数，即可以多次返回值。则生成器可以暂停一下，转而执行其他代码，再回来继续执行函数往下的代码。</p>
<h2 id="Synchronized实现原理，原子操作实现原理"><a href="#Synchronized实现原理，原子操作实现原理" class="headerlink" title="Synchronized实现原理，原子操作实现原理"></a>Synchronized实现原理，原子操作实现原理</h2><p><a href="https://juejin.im/post/5cee325e6fb9a07ee85c0c49" target="_blank" rel="noopener">参考文章</a></p>
<p><strong>jdk对synchronized做了哪些优化：</strong></p>
<ul>
<li><p>适应性自旋锁：为了减少线程状态的改变带来的消耗，不停地执行当前线程</p>
</li>
<li><p>锁消除：对于不可能存在共享资源竞争的锁进行消除</p>
</li>
<li><p>锁粗化：对于连续多次加锁，精简到只有一次。</p>
</li>
<li><p>轻量级锁：无竞争条件下，通过CAS消除同步互斥</p>
</li>
<li><p>偏向锁：无竞争条件下消除同步互斥，连CAS操作都不需要</p>
</li>
</ul>
<p>原子操作实现原理：总线锁 缓存锁 CAS</p>
<p>那么<strong>CAS不足之处</strong>：</p>
<ul>
<li><p>ABA</p>
</li>
<li><p>循环时间长会导致消耗大</p>
</li>
<li><p>只能保证一个共享变量原子操作</p>
</li>
</ul>
<h2 id="线程间同步方式"><a href="#线程间同步方式" class="headerlink" title="线程间同步方式"></a>线程间同步方式</h2><p><a href="https://www.cnblogs.com/xhjt/p/3897440.html" target="_blank" rel="noopener">看看看看</a></p>
<ul>
<li><p>1.<code>synchronized</code>修饰方法和方法块</p>
</li>
<li><p>2.使用特殊域变量<code>volatile</code></p>
<ul>
<li>volatile关键字为域变量的访问提供了一种免锁机制，</li>
<li>使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，</li>
<li>因此每次使用该域就要重新计算，而不是使用寄存器中的值</li>
<li>volatile不会提供任何原子操作，它也不能用来修饰final类型的变量</li>
</ul>
</li>
<li><p>3.使用重入锁<code>RetrentLock</code></p>
<p>在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力</p>
<p>ReenreantLock类的常用方法有：</p>
<ul>
<li>ReentrantLock() : 创建一个ReentrantLock实例</li>
<li>lock() : 获得锁</li>
<li>unlock() : 释放锁</li>
</ul>
<p>注：ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用</p>
</li>
<li><p>4.使用<code>ThreadLocal</code><br>如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。</p>
<p>ThreadLocal与同步机制:</p>
<ul>
<li>a.ThreadLocal与同步机制都是为了解决多线程中相同变量的访问冲突问题。</li>
<li>b.前者采用以”空间换时间”的方法，后者采用以”时间换空间”的方式</li>
</ul>
</li>
<li><p>5.<a href="https://www.jianshu.com/p/9394b257fdde" target="_blank" rel="noopener">使用阻塞队列<code>LinkedBlockingQueue</code></a></p>
<ul>
<li>(1) LinkedBlockingQueue继承于AbstractQueue，它本质上是一个FIFO(先进先出)的队列。</li>
<li>(2) LinkedBlockingQueue实现了BlockingQueue接口，它支持多线程并发。当多线程竞争同一个资源时，某线程获取到该资源之后，其它线程需要阻塞等待。</li>
<li>(3) LinkedBlockingQueue是通过<strong>单链表</strong>实现的。<ul>
<li>a) head是链表的表头。取出数据时，都是从表头head处插入。</li>
<li>b) last是链表的表尾。新增数据时，都是从表尾last处插入。</li>
<li>c) count是链表的实际大小，即当前链表中包含的节点个数。</li>
<li>d) capacity是列表的容量，它是在创建链表时指定的。</li>
<li>e) putLock是插入锁，takeLock是取出锁；notEmpty是“非空条件”，notFull是“未满条件”。通过它们对链表进行并发控制。</li>
</ul>
</li>
</ul>
<p>LinkedBlockingQueue在实现“多线程对竞争资源的互斥访问”时，对于“插入”和“取出(删除)”操作分别使用了不同的锁。对于插入操作，通过“插入锁putLock”进行同步；对于取出操作，通过“取出锁takeLock”进行同步。 此外，插入锁putLock和“非满条件notFull”相关联，取出锁takeLock和“非空条件notEmpty”相关联。通过notFull和notEmpty更细腻的控制锁。</p>
<ul>
<li>若某线程(线程A)要取出数据时，队列正好为空，则该线程会执行notEmpty.await()进行等待；当其它某个线程(线程B)向队列中插入了数据之后，会调用notEmpty.signal()唤醒“notEmpty上的等待线程”。此时，线程A会被唤醒从而得以继续运行。 此外，线程A在执行取操作前，会获取takeLock，在取操作执行完毕再释放takeLock。</li>
<li>若某线程(线程H)要插入数据时，队列已满，则该线程会它执行notFull.await()进行等待；当其它某个线程(线程I)取出数据之后，会调用notFull.signal()唤醒“notFull上的等待线程”。此时，线程H就会被唤醒从而得以继续运行。 此外，线程H在执行插入操作前，会获取putLock，在插入操作执行完毕才释放putLock。</li>
</ul>
</li>
<li><p>6.使用原子变量<br>需要使用线程同步的根本原因在于对普通变量的操作不是原子的。</p>
<p>那么什么是原子操作呢？</p>
<p>原子操作就是指将读取变量值、修改变量值、保存变量值看成一个整体来操作即这几种行为要么同时完成，要么都不完成。</p>
</li>
</ul>
<h2 id="线程间通信方式"><a href="#线程间通信方式" class="headerlink" title="线程间通信方式"></a>线程间通信方式</h2><p>场景题: “编写两个线程，一个线程打印1<del>25，另一个线程打印字母A</del>Z，打印顺序为12A34B56C……5152Z，要求使用线程间的通信。”</p>
<p><a href="https://blog.csdn.net/u011514810/article/details/77131296" target="_blank" rel="noopener"><strong>参考文章</strong></a></p>
<ul>
<li>用共享变量的形式完成线程间通信<ul>
<li>利用synchronized和wait、notify</li>
<li>利用Lock、Condition</li>
<li>利用volatile</li>
<li>利用原子类型 </li>
</ul>
</li>
<li>利用CyclicBarrier API</li>
<li>利用PipedInputStream API</li>
<li>利用BlockingQueue</li>
</ul>
<h2 id="创建线程的几种方式"><a href="#创建线程的几种方式" class="headerlink" title="创建线程的几种方式"></a>创建线程的几种方式</h2><ul>
<li>1.实现Runnable接口</li>
<li>2.实现Callable接口：带返回值 FutureTask</li>
<li>3.继承Thread类：由于一般类都有继承，这种方式代价太高，导致类无法继承</li>
</ul>
<h2 id="线程池原理及参数含义"><a href="#线程池原理及参数含义" class="headerlink" title="线程池原理及参数含义"></a>线程池原理及参数含义</h2><h3 id="线程池好处"><a href="#线程池好处" class="headerlink" title="线程池好处"></a>线程池好处</h3><ul>
<li>降低资源消耗：可以利用已创建的线程，降低创建线程和消耗线程带来的资源消耗</li>
<li>提高响应速度：当请求到达时，可以不需要重新创建线程而直接执行</li>
<li>提高线程可管理性：线程是类稀缺资源，无限制地创建线程会消耗过多资源并且会造成系统不稳定，利用线程池可以对线程进行统一的<strong>分配、调优和监控</strong></li>
</ul>
<h3 id="线程池工作原理-核心线程-gt-等待队列-gt-线程池是否已满-gt-饱和策略"><a href="#线程池工作原理-核心线程-gt-等待队列-gt-线程池是否已满-gt-饱和策略" class="headerlink" title="线程池工作原理(核心线程-&gt;等待队列-&gt;线程池是否已满-&gt;饱和策略)"></a>线程池工作原理(核心线程-&gt;等待队列-&gt;线程池是否已满-&gt;饱和策略)</h3><ul>
<li>1.首先判断核心线程是否均在工作，如果均在工作则进入第2步，如果未均在工作，则创建一个新的线程来执行任务</li>
<li>2.当核心线程均在执行任务时，对于新的任务则判断等待队列是否已满，如果满了则执行第3步，否则，将任务放入等待队列</li>
<li>3.判断线程池线程是否均在执行任务(注意此时是所有线程而不只是核心线程)，如果均在执行任务，则交给饱和策略来处理任务，否则创建线程执行任务。</li>
</ul>
<h3 id="线程池饱和策略"><a href="#线程池饱和策略" class="headerlink" title="线程池饱和策略"></a>线程池饱和策略</h3><ul>
<li>1.AbortPolicy：为java线程池默认的阻塞策略，不执行此任务，而且直接抛出一个运行时异常，切记ThreadPoolExecutor.execute需要try catch，否则程序会直接退出。</li>
<li>2.DiscardPolicy：直接抛弃，任务不执行，空方法</li>
<li>3.DiscardOldestPolicy：从队列里面抛弃head的一个任务，并再次execute 此task。</li>
<li>4.CallerRunsPolicy：在调用execute的线程里面执行此command，会阻塞入口 </li>
<li>5.用户自定义拒绝策略（最常用）：实现RejectedExecutionHandler，并自己定义策略模式</li>
</ul>
<p><a href="https://juejin.im/post/5c33400c6fb9a049fe35503b" target="_blank" rel="noopener">看看源码吧！！</a></p>
<h2 id="死锁产生条件以及解决策略"><a href="#死锁产生条件以及解决策略" class="headerlink" title="死锁产生条件以及解决策略"></a>死锁产生条件以及解决策略</h2><h3 id="死锁产生的四个条件"><a href="#死锁产生的四个条件" class="headerlink" title="死锁产生的四个条件"></a>死锁产生的四个条件</h3><ul>
<li><ol>
<li>互斥条件：一个资源每次只能被一个线程持有</li>
</ol>
</li>
<li><ol start="2">
<li>请求与保持条件：一个进程因请求资源而等待时，不会释放已分配的资源。</li>
</ol>
</li>
<li><ol start="3">
<li>不可剥夺条件：线程持有的资源，在未使用前不可剥夺</li>
</ol>
</li>
<li><ol start="4">
<li>循环等待条件：若干个线程形成头尾相连的等待资源的关系</li>
</ol>
</li>
</ul>
<p>只要产生死锁，这四个条件必定成立，若破坏其中一个条件，死锁就不会发生了。</p>
<h3 id="解决死锁的策略"><a href="#解决死锁的策略" class="headerlink" title="解决死锁的策略"></a>解决死锁的策略</h3><p><a href="https://zhuanlan.zhihu.com/p/61221667" target="_blank" rel="noopener">死锁检测与解除</a></p>
<ul>
<li><strong>预防死锁</strong><ul>
<li><strong>资源一次性分配</strong>：破坏请求和保持条件。　当某个资源只在进程结束时使用一小会，那么在进程运行期间，这个资源都被占用，资源利用率很低。比较好的方法是，进程开始时，只申请和使用进程启动的资源，在运行过程中不断申请新的资源，同时释放已经使用完的资源。</li>
<li><strong>可剥夺资源</strong>：当进程新申请的资源不满足时，释放已经分配的资源。破坏不可剥夺条件。　在使用某些资源，比如打印机时，当强制剥夺已分配资源的时候，会导致打印机资源打印的信息不连续的问题。</li>
<li><strong>资源有序分配</strong>：系统给进程编号，按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ul>
</li>
<li><strong>避免死锁</strong><br><strong>银行家算法</strong>：分配资源前先评估风险，会不会在分配后导致死锁。　即分配给一个进程资源的时候，该进程能否全部返还占用的资源。</li>
<li><strong>检测死锁</strong><br>建立资源分配表和进程等待表。</li>
<li><strong>解除死锁</strong><br>从其他进程强制剥夺资源给死锁进程。可以直接撤销死锁进程，或撤销代价最小的进程。</li>
</ul>
<h2 id="死锁与饥饿的区别"><a href="#死锁与饥饿的区别" class="headerlink" title="死锁与饥饿的区别"></a>死锁与饥饿的区别</h2><p><strong>饥饿：</strong>一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。</p>
<h3 id="Java-中导致饥饿的原因："><a href="#Java-中导致饥饿的原因：" class="headerlink" title="Java 中导致饥饿的原因："></a>Java 中导致饥饿的原因：</h3><ul>
<li>1、高优先级线程吞噬所有的低优先级线程的CPU时间。</li>
<li>2、线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。</li>
<li>3、线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的wait方法)，因为其他线程总是被持续地获得唤醒。</li>
</ul>
<h3 id="解决饥饿的办法："><a href="#解决饥饿的办法：" class="headerlink" title="解决饥饿的办法："></a>解决饥饿的办法：</h3><ul>
<li>1.公平锁</li>
<li>2.读线程可以允许其他读写程并发访问，但禁止写线程。写线程禁止其他线程并发访问。当某个线程正在进行读操作，此时有个写线程进行申请资源，则应禁止其他读线程访问资源。</li>
</ul>
<h3 id="什么是活锁"><a href="#什么是活锁" class="headerlink" title="什么是活锁"></a>什么是活锁</h3><p>活锁：是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。</p>
<h2 id="JUC下源码分析-偶尔带着看吧"><a href="#JUC下源码分析-偶尔带着看吧" class="headerlink" title="JUC下源码分析(偶尔带着看吧)"></a>JUC下源码分析(偶尔带着看吧)</h2><h2 id="什么是可重入锁，如何实现一个可重入锁？"><a href="#什么是可重入锁，如何实现一个可重入锁？" class="headerlink" title="什么是可重入锁，如何实现一个可重入锁？"></a>什么是可重入锁，如何实现一个可重入锁？</h2><h3 id="可重入锁的定义"><a href="#可重入锁的定义" class="headerlink" title="可重入锁的定义"></a>可重入锁的定义</h3><p>广义上可重入锁是指可重复递归调用的锁，同一个对象或类的前提下，在外层使用锁之后，在内层仍然可以用，并且不发生死锁。</p>
<p><strong><code>synchronized</code>和<code>ReentrantLock</code></strong>均是可重入锁</p>
<h3 id="synchronized可重入示例"><a href="#synchronized可重入示例" class="headerlink" title="synchronized可重入示例"></a><code>synchronized</code>可重入示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        set();<span class="comment">//还可以获得锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantTest rt = <span class="keyword">new</span> ReentrantTest();</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(rt).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不可重入锁示例"><a href="#不可重入锁示例" class="headerlink" title="不可重入锁示例"></a>不可重入锁示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnreentrantLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; owner = <span class="keyword">new</span> AtomicReference&lt;Thread&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="comment">//这句是很经典的“自旋”语法，AtomicInteger中也有</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!owner.compareAndSet(<span class="keyword">null</span>, current)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        owner.compareAndSet(current, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改为可重入锁"><a href="#修改为可重入锁" class="headerlink" title="修改为可重入锁"></a>修改为可重入锁</h3><p>在执行每次操作之前，判断当前锁持有者是否是当前对象，采用state计数，不用每次去释放锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnreentrantLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; owner = <span class="keyword">new</span> AtomicReference&lt;Thread&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state=<span class="number">0</span>;<span class="comment">//记录重入次数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span>(owner.get()==current)&#123;</span><br><span class="line">            <span class="comment">//该线程已经获得该锁</span></span><br><span class="line">            state++;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这句是很经典的“自旋”语法，AtomicInteger中也有</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!owner.compareAndSet(<span class="keyword">null</span>, current)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span>(current==owner.get())&#123;</span><br><span class="line">            <span class="keyword">if</span>(state!=<span class="number">0</span>)&#123;</span><br><span class="line">                state--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                owner.compareAndSet(current, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ReentrantLock可重入锁实现"><a href="#ReentrantLock可重入锁实现" class="headerlink" title="ReentrantLock可重入锁实现"></a><code>ReentrantLock</code>可重入锁实现</h3><p>这里看非公平获得锁实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//就是这里</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在AQS中维护了一个private volatile int state来计数重入次数，避免了频繁的持有释放操作，这样既提升了效率，又避免了死锁。</p>
<h2 id="Lock接口下实现的锁和synchronized关键字比较，各自优缺点"><a href="#Lock接口下实现的锁和synchronized关键字比较，各自优缺点" class="headerlink" title="Lock接口下实现的锁和synchronized关键字比较，各自优缺点"></a>Lock接口下实现的锁和<code>synchronized</code>关键字比较，各自优缺点</h2><ul>
<li><code>synchronized</code>是Java内置的，且不需要手动释放锁，代码可读性较高</li>
<li><code>Lock</code>接口实现的锁具有以下优势：<ul>
<li>等待线程可以响应中断</li>
<li>可以解决读读冲突</li>
<li>可以实现公平锁</li>
<li>加锁释放锁操作灵活</li>
<li>ReentrantLock下的Condition可以灵活实现线程间的协作，而不像<code>synchronized</code>修饰的临界区域只能通过Object类的wait/notify进行</li>
</ul>
</li>
</ul>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p><a href="http://njustwh2014.github.io/2019/11/05/shen-ru-li-jie-abstractqueuedsynchronizer-aqs/"><strong>之前写的，没事看看</strong></a></p>
<p>AQS则实现了对同步状态的管理，以及对阻塞线程进行排队，等待通知等等一些底层的实现处理。AQS的核心也包括了这些方面:同步队列，独占式锁的获取和释放，共享锁的获取和释放以及可中断锁，超时等待锁获取这些特性的实现</p>
<h2 id="哪些地方用到了CAS"><a href="#哪些地方用到了CAS" class="headerlink" title="哪些地方用到了CAS"></a>哪些地方用到了CAS</h2><h2 id="高并发解决超卖少卖的情况"><a href="#高并发解决超卖少卖的情况" class="headerlink" title="高并发解决超卖少卖的情况"></a>高并发解决超卖少卖的情况</h2><p><a href="http://www.linuxmysql.com/17/2019/1035.htm" target="_blank" rel="noopener">参考连接</a></p>
]]></content>
      <categories>
        <category>求职</category>
      </categories>
  </entry>
  <entry>
    <title>JVM面试总结</title>
    <url>/2020/03/16/jvm-mian-shi-zong-jie/</url>
    <content><![CDATA[<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>JVM即java虚拟机，可以屏蔽具体硬件平台执行java语言或其他jvm支持的语言编译而出的字节码，<strong>jvm实现了java语言重要的特征：平台无关性，一次编译到处运行。</strong> </p>
<p>原理：编译后的java程序指令并不是直接在CPU上执行，而是由JVM执行。JVM屏蔽了具体的硬件平台，使Java语言只需要编译生成在JVM上运行的目标字节码(.class)，就可以不加修改的在各个平台上执行。</p>
<p><strong>JVM=类加载器+执行引擎+运行时数据区域</strong></p>
<h2 id="JVM-类加载机制"><a href="#JVM-类加载机制" class="headerlink" title="JVM: 类加载机制"></a>JVM: 类加载机制</h2><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是<strong>虚拟机的加载机制</strong>。</p>
<p><a href="https://juejin.im/post/5a810b0e5188257a5c606a85#heading-1" target="_blank" rel="noopener">要看看哦</a></p>
<a id="more"></a>
<h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><p>类从被虚拟机加载到内存中开始，到卸载出内存为止，它的生命周期经历了<strong>加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）</strong>，一共七个阶段，其中验证、准备、解析部分统称为连接。</p>
<p><strong>加载、验证、准备、初始化这个5个阶段的顺序是固定的</strong>，也就是说类的加载过程必须按照这种顺序按部就班开始；<strong>解析阶段则不一定，解析阶段的工作完全可能在初始化之后才开始</strong>，之所以这么设计，就是为了<strong>支持Java语言的动态绑定</strong>。还有一点需要注意的是，虽然上述的5个阶段可能按照顺序开始，但是并不是说一个接一个阶段完成后才开始，一个阶段的进行完全可能激活另一个阶段的进行，<strong>交叉混合式</strong>的进行。</p>
<h4 id="何时类开始加载"><a href="#何时类开始加载" class="headerlink" title="何时类开始加载"></a>何时类开始加载</h4><p>那么什么情况下需要开始类加载过程的第一个阶段，加载到内存中呢？这就不得不涉及两个概念：<strong>主动引用和被动引用</strong>。</p>
<p><strong>根据Java虚拟机的规范，只有5中情况属于主动引用：</strong></p>
<ul>
<li>遇到new（使用new 关键字实例化一个对象）、getstatic（读取一个类的静态字段）、putstatic或者invokestatic（设置一个类的静态字段）这4条指令的时候，如果累没有进行过初始化。则需要先触发其初始化。</li>
<li>使用反射进行反射调用的时候，如果类没有初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果其父类没有初始化，则需要先触发其父类的初始化</li>
<li>程序启动需要触发main方法的时候，虚拟机会先触发这个类的初始化</li>
<li>当使用jdk1.7的动态语言支持的时候，如果一个java.lang.invoke.MethodHandler实例最后的解析结果为REF_getStatic、REF_pusStatic、REF_invokeStatic的方法句柄（句柄中包含了对象的实例数据和类型数据，句柄是访问对象的一种方法。句柄存储在堆中），并且句柄对应的类没有被初始化，那么需要先触发这个类的初始化。</li>
</ul>
<p><strong>5种之外情况就是被动引用。被动引用的经典例子有：</strong></p>
<ul>
<li>通过子类引用父类的静态字段<br>这种情况不会导致子类的初始化，因为对于静态字段，只有直接定义静态字段的类才会被触发初始化，子类不是定义这个静态字段的类，自然不能被实例化。</li>
<li>通过数组定义来引用类，不会触发该类的初始化<br>例如， Clazz[] arr = new Clazz[10];并不会触发。</li>
<li>常量不会触发定义常量的类的初始化<br>因为常量在编译阶段会存入调用常量的类的常量池中，本质上并没有引用定义这个常量的类，所以不会触发定义这个常量的类的初始化。</li>
</ul>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>在加载阶段虚拟机需要完成以下三件事：</p>
<ul>
<li>通过一个类的全限定名称来获取此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ul>
<p>这三件事在Java虚拟机中并没有说的很详细，比如类的全限定名称是如何加载进来的，以及从哪里加载进来的。通常来讲，一个类的全限定名称可以从zip、jar包中加载，也可以从网络中获取，也可以在运行的时候生成（这点最明显的技术体现就是反射机制）。</p>
<p>对于类的加载，可以分为数组类型和非数组类型，<strong>对于非数组类型可以通过系统的引导类加载器进行加载，也可以通过自定义的类加载器进行加载</strong>。这点是比较灵活的。而对于<strong>数组类型，数组类本身不通过类加载器进行加载，而是通过Java虚拟机直接进行加载的</strong>，那么是不是数组类型的类就不需要类加载器了呢？答案是否定的。因为当数组去除所有维度之后的类型最终还是要依靠类加载器进行加载的，所以数组类型的类与类加载器的关系还是很密切的。</p>
<p>通常一个<strong>数组类型的类</strong>进行加载需要遵循以下的原则：</p>
<ul>
<li>如果数组的组件类型（也就是数组类去除一个维度之后的类型，比如对于二维数组，去除一个维度之后是一个一维数组）是引用类型，那么递归采用上面的过程加载这个组件类型</li>
<li>如果数组类的组件类型不是引用类型，比如是基本数据类型，Java虚拟机将把数组类标记为与引导类加载器关联</li>
</ul>
<p>数组类的可见性与组件类型的可见性是一致的。如果组件类型不是引用类型，那么数组类的可见性是public，意味着组件类型的可见性也是public。</p>
<p>前面已经介绍过，<strong>加载阶段与连接阶段是交叉进行的，所以可能加载阶段还没有完成，连接阶段就已经开始</strong>。但是即便如此，记载阶段与连接阶段之间的开始顺序仍然保持着固定的顺序。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p><strong>验证阶段的目的是为了确保Class字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的安全。</strong></p>
<p>我们知道Java语言具有相对的安全性（这里的安全性体现为两个方面：<strong>一是Java语言本身特性，比如Java去除指针，这点可以避免对内存的直接操作；二是Java所提供的沙箱运行机制，Java保证所运行的机制都是在沙箱之内运行的，而沙箱之外的操作都不可以运行</strong>）。但是需要注意的是JVM处理的Class文件并不一定是是从Java代码编译而来，完全可能是来自其他的语言，甚至可以直接通过十六进制编辑器书写Class文件（当然前提是编写的Class文件符合规范）。从这个角度讲，其他来源的Class文件是不可能都保证其安全性的。所以如果Java虚拟机都信任其加载进来的Class文件，那么很有可能会造成对虚拟机自身的危害。</p>
<p>虚拟机的验证阶段主要完后以下4项验证：<strong>文件格式验证、元数据验证、字节码验证、符号引用验证</strong>。</p>
<h4 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h4><p>这里的文件格式是指Class的文件规范，这一步的验证主要保证加载的字节流（在计算机中不可能是整个Class文件，只有0和1，也就是字节流）符合Class文件的规范（根据前面对Class类文件的描述，Class文件的每一个字节表示的含义都是确定的。比如前四个字节是否是一个魔数等）以及保证这个字节流可以被虚拟机接受处理。</p>
<p>在Hotspot的规范中，对文件格式的验证远不止这些，但是只有通过文件格式的验证才能进入方法区中进行存储。所以自然也就知道，后面阶段的验证工作都是在方法区中进行的。</p>
<h4 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h4><p>元数据可以理解为描述数据的数据，更通俗的说，元数据是描述类之间的依赖关系的数据，比如Java语言中的注解使用（使用@interface创建一个注解）。元数据验证主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范（Java语法）的元数据信息。</p>
<p>具体的验证信息包括以下几个方面：</p>
<ul>
<li>这个类是否有父类（除了java.lang.Object外其余的类都应该有父类）</li>
<li>这个类的父类是否继承了不允许被继承的类（比如被final修饰的类）</li>
<li>如果这个类不是抽象类，是否实现了其父类或者接口中要求实现的方法</li>
<li>类中的字段、方法是否与父类产生矛盾（比如是否覆盖了父类的final字段）</li>
</ul>
<h4 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h4><p>这个阶段主要对类的方法体进行校验分析。通过了字节码的验证并不代表就是没有问题的，但是如果没有通过验证就一定是有问题的。整个字节码的验证过程比这个复杂的多，由于字节码验证的高度复杂性，在jdk1.6版本之后的虚拟机增加了一项优化，Class类文件结构这篇文章中说到过有一个属性：StackMapTable属性。可以简单理解这个属性是用于检查类型是否匹配。</p>
<h4 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h4><p>这个验证是最后阶段的验证，符号引用是Class文件的逻辑符号，直接引用指向的方法区中某一个地址，在解析阶段，将符号引用转为直接引用，这里只进行转化前的匹配性校验。符号引用验证主要是对类自身以外的信息进行匹配性校验。比如符号引用是否通过字符串描述的全限定名是否能够找到对应点类。</p>
<h5 id="符号引用（Symbolic-Reference）"><a href="#符号引用（Symbolic-Reference）" class="headerlink" title="符号引用（Symbolic Reference）"></a>符号引用（Symbolic Reference）</h5><p>符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可（符号字面量，还没有涉及到内存）。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载在内存中。各种虚拟机实现的内存布局可以各不相同，但是他们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</p>
<h5 id="直接引用（Direct-Reference）"><a href="#直接引用（Direct-Reference）" class="headerlink" title="直接引用（Direct Reference）"></a>直接引用（Direct Reference）</h5><p>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄（可以理解为内存地址）。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般都不相同，如果有了直接引用，那引用的目标必定已经在内存中存在。</p>
<p><strong>进行符号引用验证的目的在于确保解析动作能够正常执行</strong>，如果无法通过符号引用验证那么将会抛出java.lang.IncomingChangeError异常的子类。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>完成了验证阶段之后，就进入准备阶段。准备阶段是正式为变量分配内存空间并且设置类变量初始值。</p>
<p>需要注意的是，这时候进行内存分配的仅仅是类变量（也就是被static修饰的变量），实例变量是不包括的，实例变量的初始化是在对象实例化的时候进行初始化，而且分配的内存区域是Java堆。这里的初始值也就是在编程中默认值，也就是零值。</p>
<p>例如public static int value = 123 ；value在准备阶段后的初始值是0而不是123，因为此时尚未执行任何的Java方法，而把value赋值为123的putStatic指令是程序被编译后，存放在类构造器clinit()方法之中，把value赋值为123的动作将在初始化阶段才会执行。</p>
<p>特殊情况：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量就会被初始化为ConstantValue属性所指定的值，例如public static final int value = 123 编译时javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将变量赋值为123。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p><strong>解析阶段是将常量池中的符号引用替换为直接引用的过程</strong>。在进行解析之前需要对符号引用进行解析，不同虚拟机实现可以根据需要判断到底是在类被加载器加载的时候对常量池的符号引用进行解析（也就是初始化之前），还是等到一个符号引用被使用之前进行解析（也就是在初始化之后）。</p>
<p>到现在我们已经明白解析阶段的时机，那么还有一个问题是：<strong>如果一个符号引用进行多次解析请求，虚拟机中除了invokedynamic指令外，虚拟机可以对第一次解析的结果进行缓存（在运行时常量池中记录引用，并把常量标识为一解析状态），这样就避免了一个符号引用的多次解析。</strong></p>
<p><strong>解析动作主要针对的是类或者接口、字段、类方法、方法类型、方法句柄和调用点限定符7类符号引用</strong>。这里主要说明前四种的解析过程。</p>
<h4 id="类或者接口解析"><a href="#类或者接口解析" class="headerlink" title="类或者接口解析"></a>类或者接口解析</h4><p>要把一个类或者接口的符号引用解析为直接引用，需要以下三个步骤：</p>
<ul>
<li>如果该符号引用不是一个数组类型，那么虚拟机将会把该符号代表的全限定名称传递给调用这个符号引用的类。这个过程由于涉及验证过程所以可能会触发其他相关类的加载</li>
<li>如果该符号引用是一个数组类型，并且该数组的元素类型是对象。我们知道符号引用是存在方法区的常量池中的，该符号引用的描述符会类似”[java/lang/Integer”的形式（描述符的概念详见前文【深入理解JVM】：Class类文件结构），将会按照上面的规则进行加载，虚拟机将会生成一个代表此数组对象的直接引用</li>
<li>如果上面的步骤都没有出现异常，那么该符号引用已经在虚拟机中产生了一个直接引用，但是在解析完成之前需要对符号引用进行验证，主要是确认当前调用这个符号引用的类是否具有访问权限，如果没有访问权限将抛出java.lang.IllegalAccess异常</li>
</ul>
<h4 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h4><p>对字段的解析需要首先对其所属的类进行解析，因为字段是属于类的，只有在正确解析得到其类的正确的直接引用才能继续对字段的解析。对字段的解析主要包括以下几个步骤：</p>
<ul>
<li>如果该字段符号引用（后面简称符号）就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，解析结束</li>
<li>否则，如果在该符号的类实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果在接口中包含了简单名称和字段描述符都与目标相匹配的字段，那么久直接返回这个字段的直接引用，解析结束</li>
<li>否则，如果该符号所在的类不是Object类的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都相匹配的字段，那么直接返回这个字段的直接引用，解析结束</li>
<li>否则，解析失败，抛出java.lang.NoSuchFieldError异常<br>如果最终返回了这个字段的直接引用，就进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError异常</li>
</ul>
<h4 id="类方法解析"><a href="#类方法解析" class="headerlink" title="类方法解析"></a>类方法解析</h4><p>进行类方法的解析仍然需要先解析此类方法的类，在正确解析之后需要进行如下的步骤：</p>
<p>类方法和接口方法的符号引用是分开的，所以如果在类方法表中发现class_index（类中方法的符号引用）的索引是一个接口，那么会抛出java.lang.IncompatibleClassChangeError的异常</p>
<ul>
<li>如果class_index的索引确实是一个类，那么在该类中查找是否有简单名称和描述符都与目标字段相匹配的方法，如果有的话就返回这个方法的直接引用，查找结束</li>
<li>否则，在该类的父类中递归查找是否具有简单名称和描述符都与目标字段相匹配的字段，如果有，则直接返回这个字段的直接引用，查找结束</li>
<li>否则，在这个类的接口以及它的父接口中递归查找，如果找到的话就说明这个方法是一个抽象类，查找结束，返回java.lang.AbstractMethodError异常（因为抽象类是没有实现的）</li>
<li>否则，查找失败，抛出java.lang.NoSuchMethodError异常<br>如果最终返回了直接引用，还需要对该符号引用进行权限验证，如果没有访问权限，就抛出java.lang.IllegalAccessError异常</li>
</ul>
<h4 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a>接口方法解析</h4><p>同类方法解析一样，也需要先解析出该方法的类或者接口的符号引用，如果解析成功，就进行下面的解析工作：</p>
<p>如果在接口方法表中发现class_index的索引是一个类而不是一个接口，那么也会抛出java.lang.IncompatibleClassChangeError的异常</p>
<p>否则，在该接口方法的所属的接口中查找是否具有简单名称和描述符都与目标字段相匹配的方法，如果有的话就直接返回这个方法的直接引用。查找结束</p>
<p>否则，在该接口以及其父接口中查找，直到Object类，如果找到则直接返回这个方法的直接引用<br>否则，查找失败</p>
<p>接口的所有方法都是public，所以不存在访问权限问题</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>到了初始化阶段，虚拟机才开始真正执行Java程序代码</strong>，前文讲到对类变量的初始化，但那是仅仅赋初值，用户自定义的值还没有赋给该变量。只有到了初始化阶段，才开始真正执行这个自定义的过程，所以也可以说初始化阶段是执行类构造器方法clinit() 的过程。那么这个clinit() 方法是这么生成的呢？</p>
<p>clinit() 是编译器自动收集类中所有类变量的赋值动作和静态语句块合并生成的。编译器收集的顺序是由语句在源文件中出现的顺序决定的。静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。<br>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        i =<span class="number">0</span>;          <span class="comment">//给变量赋值可以正常编译通过</span></span><br><span class="line">        System.out.println(i);  <span class="comment">//这句编译器会提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>clinit() 方法与类的构造器方法不同，因为前者不需要显式调用父类构造器，因为虚拟机会保证在子类的clinit() 方法执行之前，父类的clinit() 方法已经执行完毕</p>
<p>由于父类的clinit() 方法会先执行，所以就表示父类的static方法会先于子类的clinit() 方法执行。如下面的例子所示，输出结果为2而不是1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">static</span>&#123;  </span><br><span class="line">       A = <span class="number">2</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;  </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">       System.out.println(Sub.B);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>clinit()方法对于类或者接口来说并不是必需的，如果一个类中没有静态语句块也没有对变量的赋值操作，那么编译器可以不为这个类生成clinit()方法。</p>
<p>接口中不能使用静态语句块，但仍然有变量赋值的初始化操作，因此接口也会生成clinit()方法。但是接口与类不同，执行接口的clinit()方法不需要先执行父接口的clini&gt;()方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也不会执行接口的clinit()方法。</p>
<p>虚拟机会保证一个类的clinit()方法在多线程环境中被正确地加锁和同步。如果有多个线程去同时初始化一个类，那么只会有一个线程去执行这个类的clinit()方法，其它线程都需要阻塞等待，直到活动线程执行clinit()方法完毕。如果在一个类的clinit()方法中有耗时很长的操作，那么就可能造成多个进程阻塞。</p>
<h2 id="JVM双亲委派机制"><a href="#JVM双亲委派机制" class="headerlink" title="JVM双亲委派机制"></a>JVM双亲委派机制</h2><p><a href="https://blog.csdn.net/u011080472/article/details/51332866" target="_blank" rel="noopener">参考文章</a></p>
<p>Java虚拟机中的一个类由其类加载器和二进制字节流class文件唯一确定。</p>
<blockquote>
<p>什么是JVM双亲委派机制？</p>
</blockquote>
<p>所谓双亲委派机制是Java推荐的类加载机制，其实现流程就是当需要加载一个类的时候，首先将该加载需求委托给父类加载器，如果父类不能完成类加载，则再调用子类加载器。</p>
<p>类加载器的继承关系：</p>
<p>启动类加载器&lt;-扩展类记载器&lt;-应用/系统类加载器&lt;-用户自定义类加载器</p>
<blockquote>
<p>为什么需要双亲委派模型？</p>
</blockquote>
<p>举个例子来说明，例如<code>java.lang.Object</code>类在<code>rt.jar</code>中，是由启动类加载器加载，在双亲委派机制下，无论哪个类加载器要加载该类，最终都会委托给启动类加载器来加载，因此得到都是同一个类。相反，如果没有双亲委派机制，开发者在自己的classpath下定义一个<code>Object</code>类，并由自己的类加载器或者应用类加载器加载，得到是不同的<code>Object</code>类，程序就会存在好几个<code>Object</code>类，导致程序混乱。</p>
<blockquote>
<p>什么时候需要破坏双亲委派机制？</p>
</blockquote>
<p>JNDI服务：JNDI的目的就是对资源进行集中管理和查找，它需要调用独立厂商实现部部署在应用程序的classpath下的JNDI接口提供者(SPI, Service Provider Interface)的代码。</p>
<p>因此，为了破坏这种双亲委派机制，在<strong>启动类里也能够使用系统类加载器对类进行加载</strong>，Java设计了<strong>线程上下文加载器</strong>。在核心类进行类加载时，可以读取当前线程的线程上下文加载器，使用该加载器加载实现了SPI接口的类。</p>
<p>Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI,JDBC,JCE,JAXB和JBI等</p>
<h2 id="对象实例化过程："><a href="#对象实例化过程：" class="headerlink" title="对象实例化过程："></a>对象实例化过程：</h2><ul>
<li>当JVM遇到字节码new指令时，首先检查该指令参数能否在常量池中定位到一个具体的类的符号引用，并检查该类<br>是否经过加载、验证、解析和初始化，如果没有则进行类加载</li>
<li>虚拟机在堆区分配空间</li>
<li>分配空间完成后，虚拟机为对象成员变量赋零值，这样可以保证对象不赋初值也可以调用。</li>
<li>设置对象头，包括哈希值、GC信息、锁信息、对象所属类的类元信息</li>
<li>执行init方法，初始化成员变量，执行实例化代码块，调用类的构造方法，<strong>并把堆内对象的首地址赋值给引用变量</strong>。</li>
</ul>
<h2 id="对象分配内存是否线程安全"><a href="#对象分配内存是否线程安全" class="headerlink" title="对象分配内存是否线程安全"></a>对象分配内存是否线程安全</h2><p>对象创建十分频繁，即使修改一个指针的位置在并发下也不是线程安全的，可能正给对象A分配内存，指针还没来得及修改，对象B又使用了指针来分配内存。</p>
<p>解决方法：① CAS 加失败重试保证更新原子性。② 把内存分配按线程划分在不同空间，即每个线程在 Java 堆中预先分配一小块内存，叫做本地线程分配缓冲TLAB(Thread Local Allocation Buffer)，哪个线程要分配内存就在对应的TLAB分配，TLAB用完了再进行同步</p>
<h2 id="对象的内存布局了解吗？"><a href="#对象的内存布局了解吗？" class="headerlink" title="对象的内存布局了解吗？"></a>对象的内存布局了解吗？</h2><p>对象在堆内存的存储布局可分为<strong>对象头、实例数据和对齐填充</strong>。</p>
<p><strong>对象头占12B</strong>，包括对象标记和类型指针。对象标记存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁标志、偏向线程 ID 等，这部分占 8B，称为 Mark Word。Mark Word 被设计为动态数据结构，以便在极小的空间存储更多数据，根据对象状态复用存储空间。</p>
<p><strong>类型指针是对象指向它的类型元数据的指针</strong>，占 4B。JVM 通过该指针来确定对象是哪个类的实例。</p>
<p><strong>实例数据是对象真正存储的有效信息，即本类对象的实例成员变量和所有可见的父类成员变量</strong>。存储顺序会受到虚拟机分配策略参数和字段在源码中定义顺序的影响。相同宽度的字段总是被分配到一起存放，在满足该前提条件的情况下父类中定义的变量会出现在子类之前。</p>
<p><strong>对齐填充不是必然存在的，仅起占位符作用。</strong>虚拟机的自动内存管理系统要求任何对象的大小必须是 8B 的倍数，对象头已被设为 8B 的 1 或 2 倍，如果对象实例数据部分没有对齐，需要对齐填充补全。</p>
<h2 id="JVM-运行时数据区"><a href="#JVM-运行时数据区" class="headerlink" title="JVM 运行时数据区"></a>JVM 运行时数据区</h2><p>JVM = 类加载器(classloader) + 执行引擎(execution engine) + 运行时数据区域(runtime data area)</p>
<p><img src="/2020/03/16/jvm-mian-shi-zong-jie/JVM_RUNTIME_DATA_AREA.png" alt></p>
<h3 id="栈区：栈区需要内存连续，线程私有，可以避免GC"><a href="#栈区：栈区需要内存连续，线程私有，可以避免GC" class="headerlink" title="栈区：栈区需要内存连续，线程私有，可以避免GC"></a>栈区：栈区需要内存连续，线程私有，可以避免GC</h3><ul>
<li><p>程序计数器：记录正在执行的虚拟机字节码指令地址(如果是本地方法则为空)</p>
</li>
<li><p>Java虚拟机栈：每一个Java方法在执行的同时会创建一个栈帧用于存放<strong>局部变量表、操作数栈、常量池引用</strong>等信息，方法的调用直至执行完成对应着栈帧入栈和出栈过程。</p>
<ul>
<li><p>可以通过<code>-Xss</code>这个参数来描述Java虚拟机栈的内存大小，JDK1.4默认256k，而JDK1.5+默认为1M</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -Xss2M HackTheJava</span><br></pre></td></tr></table></figure>
</li>
<li><p>该区域可能抛出如下异常：</p>
<ul>
<li><p>线程请求的栈深度超过最大值，抛出<code>StackOverflowError</code></p>
</li>
<li><p>栈进行动态扩展时无法申请到足够内存时，抛出<code>OutOfMemoryError</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>本地方法栈：本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。</li>
</ul>
<p>本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</p>
<h3 id="堆区：堆区不需要连续的内存，可动态增加内存，增加内存失败会抛出OutOfMemoryError"><a href="#堆区：堆区不需要连续的内存，可动态增加内存，增加内存失败会抛出OutOfMemoryError" class="headerlink" title="堆区：堆区不需要连续的内存，可动态增加内存，增加内存失败会抛出OutOfMemoryError"></a>堆区：堆区不需要连续的内存，可动态增加内存，增加内存失败会抛出<code>OutOfMemoryError</code></h3><p><img src="/2020/03/16/jvm-mian-shi-zong-jie/JVM_RUNTIME_DATA.png" alt></p>
<p>被<strong>所有线程共享</strong>，在虚拟机启动时创建，用来存放对象实例，<strong>几乎所有的对象实例都在这里分配内存</strong>。</p>
<p>对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。</p>
<p><strong>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。</strong></p>
<p>如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：<strong>新生代和老年代；新生代又有Eden空间、From Survivor空间、To Survivor空间三部分。</strong></p>
<p><strong>Java 堆不需要连续内存，并且可以通过动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。</strong></p>
<p>现在的垃圾收集器都采用分代收集算法，其主要思想采用不同类型的对象采用不同的垃圾收集算法，可以将堆分成两块：</p>
<ul>
<li>新生代</li>
<li>老年代</li>
</ul>
<p>可以通过 <code>-Xms</code> 和 <code>-Xmx</code> 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -Xms1M -Xmx2M HackTheJava</span><br></pre></td></tr></table></figure>

<h4 id="新生代："><a href="#新生代：" class="headerlink" title="新生代："></a>新生代：</h4><ul>
<li>大多数新生的对象在Eden区分配，<strong>当Eden区没有足够空间进行分配时，虚拟机就会进行一次MinorGC。</strong></li>
<li>在方法中new一个对象，方法调用完毕，对象就无用，这就是典型的新生代对象。（新生对象在Eden区经历过一次MinorGC并且Survivor容纳的话，对象年龄为1，并且每熬过一次MinorGC，年龄就会加1，直到15，就会晋升到老年代）</li>
<li>注意动态对象的判定：Survivor空间中相同年龄的对象大小总和大于Survivor空间的一半，大于或者等于该年龄的对象就可以直接进入老年代。</li>
</ul>
<h4 id="老年代："><a href="#老年代：" class="headerlink" title="老年代："></a>老年代：</h4><ul>
<li>在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到老年代中，而且大对象（占用大量连续内存空间的java对象如很长的字符串及数组）直接进入老年代。</li>
<li>当survivor空间不够用时，需要依赖老年代进行分配担保。</li>
</ul>
<h4 id="永久代："><a href="#永久代：" class="headerlink" title="永久代："></a>永久代：</h4><ul>
<li>方法区</li>
<li>主要存放Class和Meta的信息，Class在被加载的时候被放入永久代。它和存放对象的堆区域不同，GC(Garbage Collection)不会在主程序运行期对永久代进行清理，所以如果你的应用程序会加载很多Class的话,就很可能出现PermGen space错误。</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>用于存放<strong>已被加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。</p>
<p>和<strong>堆一样不需要连续的内存</strong>，并且可以动态扩展，动态扩展失败一样会抛出 <code>OutOfMemoryError</code> 异常。</p>
<p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</p>
<p>HotSpot虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出<code>OutOfMemoryError</code>异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间(metaspace)，它位于本地内存中，而不是虚拟机内存中。</p>
<p>方法区是一个JVM规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。</p>
<ul>
<li><p>运行时常量池</p>
<p><strong>运行时常量池是方法区的一部分</strong>。</p>
<p>Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。</p>
<p>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。</p>
</li>
</ul>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。</p>
<h2 id="JVM-常见GC算法"><a href="#JVM-常见GC算法" class="headerlink" title="JVM: 常见GC算法"></a>JVM: 常见GC算法</h2><h3 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h3><ul>
<li>MinorGC：是指清理新生代 <strong>当Eden区满时，触发Minor GC。</strong></li>
<li>MajorGC：是指清理老年代（很多MajorGC是由MinorGC触发的）</li>
<li>FullGC：是指清理整个堆空间包括年轻代和永久代</li>
</ul>
<h3 id="MinorGC与FullGC触发条件"><a href="#MinorGC与FullGC触发条件" class="headerlink" title="MinorGC与FullGC触发条件"></a>MinorGC与FullGC触发条件</h3><ul>
<li>Minor GC触发条件：当Eden区满时，触发Minor GC。</li>
<li>Full GC触发条件：<ul>
<li>（1）调用System.gc时，系统建议执行Full GC，但是不必然执行</li>
<li>（2）老年代空间不足</li>
<li>（3）方法区空间不足</li>
<li>（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>
<li>（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>
</ul>
</li>
</ul>
<h3 id="Java四种引用类型"><a href="#Java四种引用类型" class="headerlink" title="Java四种引用类型"></a>Java四种引用类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object ref=<span class="keyword">new</span> Object();<span class="comment">//ref是Object对象的强引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个软引用指向Object对象，此时Object对象有两个引用</span></span><br><span class="line">SoftReference&lt;Object&gt; sf=<span class="keyword">new</span> SoftReference&lt;Object&gt;(ref);</span><br><span class="line"></span><br><span class="line">ref=<span class="keyword">null</span>;<span class="comment">//移除强引用</span></span><br><span class="line"></span><br><span class="line">Object object=ref.get();<span class="comment">//获取目标对象</span></span><br><span class="line"></span><br><span class="line">System.gc();<span class="comment">//gc只有在内存不足时才会移除软引用对象</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>引用类型</th>
<th>取得目标方法</th>
<th>垃圾回收条件</th>
<th>是否可能内存泄漏</th>
</tr>
</thead>
<tbody><tr>
<td>强引用</td>
<td>直接调用</td>
<td>不回收</td>
<td>可能</td>
</tr>
<tr>
<td>软引用</td>
<td>get()</td>
<td>视内存情况</td>
<td>不可能</td>
</tr>
<tr>
<td>弱引用</td>
<td>get()</td>
<td>gc即回收</td>
<td>不可能</td>
</tr>
<tr>
<td>虚引用</td>
<td>无法取得</td>
<td>不回收</td>
<td>可能</td>
</tr>
</tbody></table>
<p><a href="https://zhang0peter.com/2020/02/13/java-gc/" target="_blank" rel="noopener">不记得时，就看看吧</a></p>
<h3 id="标记算法"><a href="#标记算法" class="headerlink" title="标记算法"></a>标记算法</h3><ul>
<li><p>引用计数法</p>
<p>通过在对象中分配一个字段用来存储对象引用计数，一旦对象被引用，则引用计数加一，引用失效则减一，一旦引用计数为0，可以被回收</p>
<ul>
<li><p>优点：实现简单，过程高效，具有实时性</p>
</li>
<li><p>缺点：需要额外资源维护，且无法解决对象循环依赖问题(Python中解决方法是采用标记-清除算法)</p>
</li>
</ul>
</li>
<li><p>可达性分析法</p>
<p>维护一系列<code>GC Root</code>对象作为根，当一个对象经过引用链到达根节点时没有任何引用，则表明该对象不可用，可以被GC回收。</p>
<p><strong>可以当作<code>GC Root</code>的对象包括但不限于:</strong></p>
<ul>
<li>1.虚拟机栈（栈帧中的本地变量表）中引用的对象；// 方法中的局部变量</li>
<li>2.方法区中的类静态属性引用的对象；</li>
<li>3.方法区中常量引用的对象；</li>
<li>4.本地方法栈中JNI（即一般说的Native方法）中引用的对象</li>
</ul>
<p>需要注意的是，在可达性分析算法中被判定不可达的对象还未真的判『死刑』，至少要经历两次标记过程：判断对象是否有必要执行finalize()方法；若被判定为有必要执行finalize()方法，之后还会对对象再进行一次筛选，如果对象能在finalize()中重新与引用链上的任何一个对象建立关联，将被移除出“即将回收”的集合。</p>
</li>
</ul>
<h3 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h3><ul>
<li><p>标记清除算法: 会产生空间碎片，当出现连续空间不足够时，虚拟机会感知内存不足，则再次触发GC，而且标记清除算法效率不高，会导致GC时间占用过多，影响程序运行。</p>
</li>
<li><p>复制算法：以空间换时间的算法，每次只用一半空间，且不存在空间碎片。在虚拟机内存的新生代中，大批对象死去只保留少数对象，因此适用于复制算法。</p>
</li>
<li><p>标记整理算法：是在标记清除算法基础上加上对象移动这个整理过程，从而解决了空间碎片问题，但效率比标记清除还低，适用于老年代。</p>
</li>
<li><p>分代收集算法</p>
<p>  从上面三种 GC 算法可以看到，并没有一种空间与时间效率都是比较完美的算法，所以只能做的是综合利用各种算法特点将其作用到不用的内存区域。</p>
<p>  js的V8引擎，Python, HotSpot 都采用了分代收集算法。</p>
<p>  目前JVM虚拟机根据对象存活周期不同划分内存区域，一般分为新生代，老年代。新对象一般情况都会优先分配在新生代，新生代对象若存活时间大于一定阈值之后，将会移到至老年代。新生代的对象都是存活时间短，老年代的对象存活时间长。</p>
<p>  新生代每次 GC 之后都可以回收大批量对象，所以比较适合复制算法，只需要付出少量复制存活对象的成本。这里内存划分并没有按照 1:1 划分，默认将会按照 8:1:1 划分成 Eden 与两块 Survivor 空间。每次使用 Eden 与一块 Survivor 空间，这样我们只是闲置 10% 内存空间。不过我们每次回收并不能保证存活对象小于 10%,在这种情况下就需要依靠老年代的内存分配担保。当 Survivor 空间并不能保存剩余存活对象，就将这些对象通过分配担保进制移动至老年代。</p>
<p>  老年代中对象存活率将会特别高，且没有额外空间进行分配担保，所以并不适合复制算法，所以需要使用标记-清除或标记-整理算法。</p>
<p>  大多数情况下，新的对象都分配在Eden区，当 Eden 区没有空间进行分配时，将进行一次 Minor GC，清理 Eden 区中的无用对象。清理后，Eden 和 From Survivor 中的存活对象如果小于To Survivor 的可用空间则进入To Survivor，否则直接进入老年代；Eden 和 From Survivor 中还存活且能够进入 To Survivor 的对象年龄增加 1 岁（虚拟机为每个对象定义了一个年龄计数器，每执行一次 Minor GC 年龄加 1），当存活对象的年龄到达一定程度（默认 15 岁）后进入老年代，可以通过 -XX:MaxTenuringThreshold 来设置年龄的值。</p>
<p>  当进行了 Minor GC 后，Eden 还不足以为新对象分配空间（那这个新对象肯定很大），新对象直接进入老年代。</p>
<p>  占 To Survivor 空间一半以上且年龄相等的对象，大于等于该年龄的对象直接进入老年代，比如 Survivor 空间是 10M，有几个年龄为 4 的对象占用总空间已经超过 5M，则年龄大于等于 4 的对象都直接进入老年代，不需要等到 MaxTenuringThreshold 指定的岁数。</p>
<p>  在进行 Minor GC 之前，会判断老年代最大连续可用空间是否大于新生代所有对象总空间，如果大于，说明 Minor GC 是安全的，否则会判断是否允许担保失败，如果允许，判断老年代最大连续可用空间是否大于历次晋升到老年代的对象的平均大小，如果大于，则执行 Minor GC，否则执行 Full GC。</p>
<p>  大对象（需要大量连续内存的对象）例如很长的数组，会直接进入老年代，如果老年代没有足够的连续大空间来存放，则会进行 Full GC。</p>
</li>
</ul>
<h2 id="JVM-GC收集器特点"><a href="#JVM-GC收集器特点" class="headerlink" title="JVM GC收集器特点"></a>JVM GC收集器特点</h2><p><a href="https://crowhawk.github.io/2017/08/15/jvm_3/" target="_blank" rel="noopener">参考文章</a></p>
<h3 id="新生代收集器"><a href="#新生代收集器" class="headerlink" title="新生代收集器"></a>新生代收集器</h3><table>
<thead>
<tr>
<th>收集器名称</th>
<th>垃圾回收算法</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>复制算法</td>
<td>+ HotSpot虚拟机运行在Client模式下的默认的新生代收集器<br> + 会暂停所有用户线程(stop the world)<br> + 简单而高效（与其他收集器的单线程相比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得更高的单线程收集效率。</td>
</tr>
<tr>
<td>Parnew</td>
<td>复制算法</td>
<td>+ 是Serial收集器的多线程版本<br> + 同样会暂停所有用户线程<br> + Server模式下首选的虚拟机新生代收集器<br> + 多CPU下性能会优于Serial收集器<br> + 只有Serial和Parnew能和CMS（Concurrent Mark Sweep收集器配合</td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>复制算法</td>
<td>+ 并行的多线程新生代GC收集器<br> + CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标是达到一个可控制的吞吐量（Throughput）<br> + GC自适应的调节策略（GC Ergonomics）<br> + Parallel Scavenge收集器无法与CMS收集器配合使用，所以在JDK 1.6推出Parallel Old之前，如果新生代选择Parallel Scavenge收集器，老年代只有Serial Old收集器能与之配合使用。</td>
</tr>
</tbody></table>
<h3 id="老年代收集器"><a href="#老年代收集器" class="headerlink" title="老年代收集器"></a>老年代收集器</h3><table>
<thead>
<tr>
<th>收集器名称</th>
<th>垃圾回收算法</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>Serial Old</td>
<td>标记-整理算法</td>
<td>+ 工作流程与新生代Serial收集器类似<br> + 也会暂停所有用户线程</td>
</tr>
<tr>
<td>Parallel Old</td>
<td>标记-整理算法</td>
<td>+ 多线程标记-整理算法<br> + 应用于<strong>注重吞吐量以及CPU资源敏感</strong>场合<br> + 配合新生代Parrallel Scavenge收集器</td>
</tr>
<tr>
<td>CMS收集器</td>
<td>标记-清除算法</td>
<td>+ 一种以获取<strong>最短回收停顿时间</strong>为目标的收集器，它非常符合那些集中在互联网站或者B/S系统的服务端上的Java应用，这些应用都非常重视服务的响应速度<br></td>
</tr>
</tbody></table>
<p><strong>CMS(Concurrent Mark Swap)收集器</strong></p>
<ul>
<li>工作流程：<ul>
<li>初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。</li>
<li>并发标记：(不暂停用户线程)进行GC Roots Tracing的过程，在整个过程中耗时最长。</li>
<li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要“Stop The World”。</li>
<li>标记清除：并发</li>
</ul>
</li>
<li>优点<br>CMS是一款优秀的收集器，它的主要优点在名字上已经体现出来了：<strong>并发收集、低停顿</strong>，因此CMS收集器也被称为并发低停顿收集器（Concurrent Low Pause Collector）。</li>
<li>缺点<ul>
<li>对<strong>CPU资源非常敏感</strong> 其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（CPU数量+3）/4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个时（比如2个），CMS对用户程序的影响就可能变得很大，如果本来CPU负载就比较大，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，其实也让人无法接受。</li>
<li><strong>无法处理浮动垃圾（Floating Garbage）</strong> 可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。这一部分垃圾出现在标记过程之后，CMS无法再当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就被称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。</li>
<li><strong>标记-清除算法导致的空间碎片</strong> CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象。</li>
</ul>
</li>
</ul>
<p><strong>G1(Garbage First)收集器</strong></p>
<ul>
<li>并行与并发</li>
<li>空间整合</li>
<li>分代收集</li>
<li>可预测停顿</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>收集器</th>
<th>串行、并行or并发</th>
<th>新生代or老年代</th>
<th>算法</th>
<th>目标</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>串行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>单CPU环境下的Client模式</td>
</tr>
<tr>
<td>Serial Old</td>
<td>串行</td>
<td>老年代</td>
<td>标记-整理算法</td>
<td>响应速度优先</td>
<td>单CPU环境下的Client模式、CMS的后备预案</td>
</tr>
<tr>
<td>Parnew</td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>多CPU环境时在Server模式下与CMS配合</td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>吞吐量优先</td>
<td>在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td>Parallel old</td>
<td>并行</td>
<td>老年代</td>
<td>标记-整理算法</td>
<td>吞吐量优先</td>
<td>在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td>CMS</td>
<td>并发</td>
<td>老年代</td>
<td>标记-清除算法</td>
<td>响应速度优先</td>
<td>集中在互联网站或B/S系统服务端上的Java应用</td>
</tr>
<tr>
<td>G1</td>
<td>并发</td>
<td>both</td>
<td>标记-整理算法+复制算法</td>
<td>响应速度优先</td>
<td>面向服务端应用，将来替换CMS</td>
</tr>
</tbody></table>
<h2 id="常见的启动参数"><a href="#常见的启动参数" class="headerlink" title="常见的启动参数"></a>常见的启动参数</h2><table>
<thead>
<tr>
<th align="left">启动参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-Xms</td>
<td align="left">设置堆的最小值</td>
</tr>
<tr>
<td align="left">-Xmx</td>
<td align="left">设置堆的最大值</td>
</tr>
<tr>
<td align="left">-Xmn</td>
<td align="left">设置新生代的大小</td>
</tr>
<tr>
<td align="left">-Xss</td>
<td align="left">设置每个线程的栈大小</td>
</tr>
<tr>
<td align="left">-XX:NewSize</td>
<td align="left">设置新生代的初始值</td>
</tr>
<tr>
<td align="left">-XX:MaxNewSize</td>
<td align="left">设置新生代的最大值</td>
</tr>
<tr>
<td align="left">-XX:PermSize</td>
<td align="left">设置永久代的初始值</td>
</tr>
<tr>
<td align="left">-XX:MaxPermSize</td>
<td align="left">设置永久代的最大值</td>
</tr>
<tr>
<td align="left">-XX:SurvivorRatio</td>
<td align="left">年轻代中Eden区与Survivor区的大小比值</td>
</tr>
<tr>
<td align="left">-XX:PretenureSizeThreshold</td>
<td align="left">令大于这个设置值的对象直接在老年代分配</td>
</tr>
</tbody></table>
<h2 id="内存溢出的分析过程"><a href="#内存溢出的分析过程" class="headerlink" title="内存溢出的分析过程"></a>内存溢出的分析过程</h2><h2 id="JVM：synchronized和volatile关键字在JVM中的行为"><a href="#JVM：synchronized和volatile关键字在JVM中的行为" class="headerlink" title="JVM：synchronized和volatile关键字在JVM中的行为"></a>JVM：<code>synchronized</code>和<code>volatile</code>关键字在JVM中的行为</h2><h2 id="你熟悉的JVM调优参数，使用过哪些调优工具？"><a href="#你熟悉的JVM调优参数，使用过哪些调优工具？" class="headerlink" title="你熟悉的JVM调优参数，使用过哪些调优工具？"></a>你熟悉的JVM调优参数，使用过哪些调优工具？</h2><ul>
<li>jps：虚拟机进程状况工具</li>
</ul>
<p>功能和 ps 命令类似：可以列出正在运行的虚拟机进程，显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一 ID（LVMID)。LVMID 与操作系统的进程 ID（PID）一致，使用 Windows 的任务管理器或 UNIX 的 ps 命令也可以查询到虚拟机进程的 LVMID，但如果同时启动了多个虚拟机进程，必须依赖 jps 命令。</p>
<ul>
<li>jstat：虚拟机统计信息监视工具</li>
</ul>
<p>用于监视虚拟机各种运行状态信息。可以显示本地或远程虚拟机进程中的类加载、内存、垃圾收集、即时编译器等运行时数据，在没有 GUI 界面的服务器上是运行期定位虚拟机性能问题的常用工具。</p>
<p>参数含义：S0 和 S1 表示两个 Survivor，E 表示新生代，O 表示老年代，YGC 表示 Young GC 次数，YGCT 表示 Young GC 耗时，FGC 表示 Full GC 次数，FGCT 表示 Full GC 耗时，GCT 表示 GC 总耗时。</p>
<ul>
<li>jinfo：Java 配置信息工具</li>
</ul>
<p>实时查看和调整虚拟机各项参数，使用 jps 的 -v 参数可以查看虚拟机启动时显式指定的参数，但如果想知道未显式指定的参数值只能使用 jinfo 的 -flag 查询。</p>
<ul>
<li>jmap：Java 内存映像工具</li>
</ul>
<p>用于生成堆转储快照，还可以查询 finalize 执行队列、Java 堆和方法区的详细信息，如空间使用率，当前使用的是哪种收集器等。和 jinfo 一样，部分功能在 Windows 受限，除了生成堆转储快照的 -dump 和查看每个类实例的 -histo 外，其余选项只能在 Linux 使用。</p>
<ul>
<li>jhat：虚拟机堆转储快照分析工具</li>
</ul>
<p>JDK 提供 jhat 与 jmap 搭配使用分析 jmap 生成的堆转储快照。jhat 内置了一个微型的 HTTP/Web 服务器，生成堆转储快照的分析结果后可以在浏览器查看。</p>
<ul>
<li>jstack：Java 堆栈跟踪工具</li>
</ul>
<p>用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的目的通常是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起等。线程出现停顿时通过 jstack 查看各个线程的调用堆栈，可以获知没有响应的线程在后台做什么或等什么资源。</p>
]]></content>
      <categories>
        <category>求职</category>
      </categories>
  </entry>
  <entry>
    <title>Mysql面试汇总</title>
    <url>/2020/03/13/mysql-mian-shi-hui-zong/</url>
    <content><![CDATA[<h2 id="相关概念理解"><a href="#相关概念理解" class="headerlink" title="相关概念理解"></a>相关概念理解</h2><h3 id="联合主键和复合主键"><a href="#联合主键和复合主键" class="headerlink" title="联合主键和复合主键"></a>联合主键和复合主键</h3><p>联合主键体现在多个表上，复合主键体现在一个表中的多个字段</p>
<p>联合主键：</p>
<a id="more"></a>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 学生表：student</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line"><span class="keyword">id</span> mediumint  auto_increment <span class="keyword">comment</span> <span class="string">'主键id'</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">comment</span> <span class="string">'姓名'</span>,</span><br><span class="line">age <span class="built_in">smallint</span> <span class="keyword">comment</span> <span class="string">'年龄'</span>,</span><br><span class="line">primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">engine</span> = myisam,</span><br><span class="line"><span class="keyword">charset</span> = utf8,</span><br><span class="line"><span class="keyword">comment</span> = <span class="string">'学生'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 课程表：course</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> course(</span><br><span class="line"><span class="keyword">id</span> mediumint  auto_increment <span class="keyword">comment</span> <span class="string">'主键id'</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">comment</span> <span class="string">'课程名称'</span>,</span><br><span class="line">primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">engine</span> = myisam,</span><br><span class="line"><span class="keyword">charset</span> = utf8,</span><br><span class="line"><span class="keyword">comment</span> = <span class="string">'课程'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 学生课程表：stu_cour</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> stu_cour(</span><br><span class="line"><span class="keyword">id</span> mediumint  auto_increment <span class="keyword">comment</span> <span class="string">'主键id'</span>,</span><br><span class="line">stu_id mediumint <span class="keyword">comment</span> <span class="string">'学生表id'</span>,</span><br><span class="line">cour_id mediumint <span class="keyword">comment</span> <span class="string">'课程表id'</span>,</span><br><span class="line">primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">engine</span> = myisam,</span><br><span class="line"><span class="keyword">charset</span> = utf8,</span><br><span class="line"><span class="keyword">comment</span> = <span class="string">'学生课程表'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 此时stu_cour中id就表示联合主键，通过id可以获取学生和课程的一条记录</span></span><br></pre></td></tr></table></figure>
<p>复合主键：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">comment</span> <span class="string">'姓名'</span>,</span><br><span class="line">age <span class="built_in">smallint</span> <span class="keyword">comment</span> <span class="string">'年龄'</span>,</span><br><span class="line">sex enum(<span class="string">'男'</span>,<span class="string">'女'</span>) <span class="keyword">comment</span> <span class="string">'性别'</span>,</span><br><span class="line">primary <span class="keyword">key</span>(<span class="keyword">name</span>,age)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">engine</span> = myisam,</span><br><span class="line"><span class="keyword">charset</span> = utf8,</span><br><span class="line"><span class="keyword">comment</span> = <span class="string">'学生'</span></span><br></pre></td></tr></table></figure>

<h2 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h2><p>一般地，在进行数据库设计时，应遵循三大原则，也就是我们通常说的三大范式：</p>
<ul>
<li><p>第一范式要求确保表中每列的原子性，也就是不可拆分；</p>
</li>
<li><p>第二范式要求确保表中每列与主键相关，而不能只与主键的某部分相关（主要针对联合主键[什么是联合主键]），主键列与非主键列遵循完全函数依赖关系，也就是完全依赖；</p>
</li>
<li><p>第三范式确保主键列之间没有传递函数依赖关系，也就是消除传递依赖。</p>
<p>实体中的属性不能是其他实体中的非主属性。因为这样会出现冗余。即：属性不依赖于其他非主属性。</p>
<p>如果一个实体中出现其他实体的非主属性，可以将这两个实体用外键关联，而不是将另一张表的非主属性直接写在当前表中。</p>
<p>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</p>
<p>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。</p>
</li>
</ul>
<h2 id="Mysql索引"><a href="#Mysql索引" class="headerlink" title="Mysql索引"></a>Mysql索引</h2><h3 id="Mysql索引目的"><a href="#Mysql索引目的" class="headerlink" title="Mysql索引目的"></a>Mysql索引目的</h3><p>索引的目的在于<strong>提高查询效率</strong>，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。如果没有索引，那么你可能需要把所有单词看一遍才能找到你想要的，如果我想找到m开头的单词呢？或者ze开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？</p>
<h3 id="索引有哪几种"><a href="#索引有哪几种" class="headerlink" title="索引有哪几种"></a>索引有哪几种</h3><ul>
<li>hash：可以快速精确查询，但不能范围查询</li>
<li>平衡二叉树：完全平衡二叉树是有序的，所以也是支持范围查找的。</li>
<li>B树：一个节点可以存储多个元素，相对于完全平衡二叉树所以整棵树的高度就降低了，磁盘IO效率提高了。</li>
<li>B+树：</li>
</ul>
<h3 id="“为什么底层数据结构使用B-树，而不是B树？”"><a href="#“为什么底层数据结构使用B-树，而不是B树？”" class="headerlink" title="“为什么底层数据结构使用B+树，而不是B树？”"></a>“为什么底层数据结构使用B+树，而不是B树？”</h3><ul>
<li>B-树（B类树）的特定就是每层节点数目非常多，层数很少，目的就是为了就少磁盘IO次数，当查询数据的时候，最好的情况就是很快找到目标索引，然后读取数据，使用B+树就能很好的完成这个目的，但是B-树的每个节点都有data域（指针），这无疑增大了节点大小，说白了增加了磁盘IO次数（<strong>磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时啊！</strong>），而B+树除了叶子节点其它节点并不存储数据，节点小，磁盘IO次数就少。这是优点之一。</li>
<li>B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串起来。这样遍历叶子节点就能获得全部数据，这样就能进行区间访问啦。</li>
</ul>
<p><strong>数据库索引采用B+树的主要原因是 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）</strong></p>
<h3 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h3><p><a href="https://www.jianshu.com/p/54c6d5db4fe6" target="_blank" rel="noopener"><strong>参考文章</strong></a></p>
<p>聚簇索引也称为主键索引，其索引树的叶子节点中存的是整行数据，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。因为索引（目录）只能按照一种方法进行排序。</p>
<p>非聚簇索引（普通索引）的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）。</p>
<blockquote>
<p>MySQL回表：</p>
</blockquote>
<ul>
<li>如果语句是 <code>select * from User where id=3</code>，即主键查询方式，则只需要搜索 主键索引树。</li>
<li>如果语句是 <code>select * from User where uid=23</code>，即普通索引查询方式，则需要先搜索 普通索引树，得到其对应的主键值为 3，再到主键索引树搜索一次。这个过程称为回表。</li>
</ul>
<p>聚集索引与非聚集索引的区别是：叶节点是否存放一整行记录</p>
<p>InnoDB 主键使用的是聚簇索引，MyISAM 不管是主键索引，还是二级索引使用的都是非聚簇索引。</p>
<ul>
<li>1.对于<strong>非聚簇索引</strong>表来说，表数据和索引是分成两部分存储的，主键索引和二级索引存储上没有任何区别。使用的是B+树作为索引的存储结构，所有的节点都是索引，叶子节点存储的是索引+索引对应的记录的数据。</li>
<li>2.对于<strong>聚簇索引</strong>表来说，表数据是和主键一起存储的，<strong>主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值</strong>。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)。</li>
</ul>
<p><strong>聚簇索引的优点</strong></p>
<ul>
<li>1.当你需要取出一定范围内的数据时，用聚簇索引也比用非聚簇索引好。</li>
<li>2.当通过聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引定位到对应主键时还要多一次目标记录寻址,即多一次I/O。</li>
<li>3.使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</li>
</ul>
<p><strong>聚簇索引的缺点</strong></p>
<ul>
<li>1.插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。</li>
<li>2.更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。</li>
<li>3.二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。二级索引的叶节点存储的是主键值，而不是行指针（非聚簇索引存储的是指针或者说是地址），这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。</li>
<li>4.采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。</li>
</ul>
<h3 id="索引的底层实现-B-树和红黑树、B树比较"><a href="#索引的底层实现-B-树和红黑树、B树比较" class="headerlink" title="索引的底层实现 B+树和红黑树、B树比较"></a>索引的底层实现 B+树和红黑树、B树比较</h3><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><h4 id="1-索引不存储null值"><a href="#1-索引不存储null值" class="headerlink" title="1.索引不存储null值"></a>1.索引不存储null值</h4><p>更准确的说，单列索引不存储null值，复合索引不存储全为null的值。索引不能存储Null，所以对这列采用is null条件时，因为索引上根本</p>
<p>没Null值，不能利用到索引，只能全表扫描。</p>
<p>为什么索引列不能存Null值？</p>
<p>将索引列值进行建树，其中必然涉及到诸多的比较操作。Null值的特殊性就在于参与的运算大多取值为null。</p>
<p>这样的话，null值实际上是不能参与进建索引的过程。也就是说，null值不会像其他取值一样出现在索引树的叶子节点上。</p>
<h4 id="2-不适合键值较少的列（重复数据较多的列）"><a href="#2-不适合键值较少的列（重复数据较多的列）" class="headerlink" title="2.不适合键值较少的列（重复数据较多的列）"></a>2.不适合键值较少的列（重复数据较多的列）</h4><p>假如索引列TYPE有5个键值，如果有1万条数据，那么 WHERE TYPE = 1将访问表中的2000个数据块。</p>
<p>再加上访问索引块，一共要访问大于2000个的数据块。</p>
<p>如果全表扫描，假设10条数据一个数据块，那么只需访问1000个数据块，既然全表扫描访问的数据块</p>
<p>少一些，肯定就不会利用索引了。</p>
<h4 id="3-前导模糊查询不能利用索引-like-‘-XX’或者like-‘-XX-’"><a href="#3-前导模糊查询不能利用索引-like-‘-XX’或者like-‘-XX-’" class="headerlink" title="3.前导模糊查询不能利用索引(like ‘%XX’或者like ‘%XX%’)"></a>3.前导模糊查询不能利用索引(like ‘%XX’或者like ‘%XX%’)</h4><p>假如有这样一列code的值为’AAA’,’AAB’,’BAA’,’BAB’ ,如果where code like ‘%AB’条件，由于前面是模糊的，所以不能利用索引的顺序，必须一个个去找，看是否满足条件。这样会导致全索引扫描或者全表扫描。如果是这样的条件where code like ‘A % ‘，就可以查找CODE中A开头的CODE的位置，当碰到B开头的数据时，就可以停止查找了，因为后面的数据一定不满足要求。这样就可以利用索引了。</p>
<h4 id="4-索引失效的几种情况"><a href="#4-索引失效的几种情况" class="headerlink" title="4.索引失效的几种情况"></a>4.索引失效的几种情况</h4><ul>
<li>1.如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)<br>要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</li>
<li>2.对于多列索引，不是使用的第一部分，则不会使用索引</li>
<li>3.like查询以%开头</li>
<li>4.如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</li>
<li>5.如果mysql估计使用全表扫描要比使用索引快,则不使用索引</li>
</ul>
<h4 id="5-MySQL主要提供2种方式的索引：B-Tree索引，Hash索引"><a href="#5-MySQL主要提供2种方式的索引：B-Tree索引，Hash索引" class="headerlink" title="5.MySQL主要提供2种方式的索引：B-Tree索引，Hash索引"></a>5.MySQL主要提供2种方式的索引：B-Tree索引，Hash索引</h4><p>B树索引具有范围查找和前缀查找的能力，对于有N节点的B树，检索一条记录的复杂度为O(LogN)。相当于二分查找。</p>
<p>哈希索引只能做等于查找，但是无论多大的Hash表，查找复杂度都是O(1)。</p>
<p>显然，如果值的差异性大，并且以等值查找（=、 &lt;、&gt;、in）为主，Hash索引是更高效的选择，它有O(1)的查找复杂度。</p>
<p>如果值的差异性相对较差，并且以范围查找为主，B树是更好的选择，它支持范围查找。</p>
<p>此外，查看索引的使用情况</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> ‘Handler_read%<span class="string">';</span></span><br></pre></td></tr></table></figure>
<p>大家可以注意：</p>
<ul>
<li>handler_read_key:这个值越高越好，越高表示使用索引查询到的次数</li>
<li>handler_read_rnd_next:这个值越高，说明查询低效</li>
</ul>
<h3 id="建索引的几大原则"><a href="#建索引的几大原则" class="headerlink" title="建索引的几大原则"></a>建索引的几大原则</h3><ul>
<li>1.最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li>
<li>2.=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</li>
<li>3.尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。</li>
<li>4.索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。</li>
<li>5.尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li>
</ul>
<h3 id="索引优化策略"><a href="#索引优化策略" class="headerlink" title="索引优化策略"></a>索引优化策略</h3><h3 id="explain慢查询优化"><a href="#explain慢查询优化" class="headerlink" title="explain慢查询优化"></a><code>explain</code>慢查询优化</h3><p>步骤：</p>
<ul>
<li>0.先运行看看是否真的很慢，注意设置SQL_NO_CACHE</li>
<li>1.where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高</li>
<li>2.explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）</li>
<li>3.order by limit 形式的sql语句让排序的表优先查</li>
<li>4.了解业务方使用场景</li>
<li>5.加索引时参照建索引的几大原则</li>
<li>6.观察结果，不符合预期继续从0分析</li>
</ul>
<h2 id="Mysql事务"><a href="#Mysql事务" class="headerlink" title="Mysql事务"></a>Mysql事务</h2><h3 id="事务特性-ACID-及其实现"><a href="#事务特性-ACID-及其实现" class="headerlink" title="事务特性(ACID)及其实现"></a>事务特性(ACID)及其实现</h3><p><a href="https://www.cnblogs.com/kismetv/p/10331633.html" target="_blank" rel="noopener">参考</a></p>
<ul>
<li>原子性（atomicity，或稱不可分割性）</li>
<li>一致性（consistency）</li>
<li>隔离性（isolation，又称独立性）</li>
<li>持久性（durability）</li>
</ul>
<p>按照严格的标准，只有同时<strong>满足ACID特性才是事务</strong>；但是在各大数据库厂商的实现中，真正满足ACID的事务少之又少。例如MySQL的NDB Cluster事务不满足持久性和隔离性；<strong>InnoDB默认事务隔离级别是可重复读，不满足隔离性；</strong>Oracle默认的事务隔离级别为READ COMMITTED，不满足隔离性……因此与其说ACID是事务必须满足的条件，不如说它们是衡量事务的四个维度。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h4><p>原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做；如果事务中一个sql语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。</p>
<h4 id="实现原理：undo-log"><a href="#实现原理：undo-log" class="headerlink" title="实现原理：undo log"></a>实现原理：undo log</h4><p>在说明原子性原理之前，首先介绍一下MySQL的事务日志。<strong>MySQL的日志有很多种，如二进制日志、错误日志、查询日志、慢查询日志等，此外InnoDB存储引擎还提供了两种事务日志：redo log(重做日志)和undo log(回滚日志)。其中redo log用于保证事务持久性；undo log则是事务原子性和隔离性实现的基础。</strong></p>
<p>下面说回undo log。实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的sql语句。<strong>InnoDB实现回滚，靠的是undo log：</strong>当事务对数据库进行修改时，InnoDB会生成对应的undo log；如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。</p>
<p><strong>undo log属于逻辑日志，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作：对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去。</strong></p>
<p>以update操作为例：当事务执行update时，其生成的undo log中会包含被修改行的主键(以便知道修改了哪些行)、修改了哪些列、这些列在修改前后的值等信息，回滚时便可以使用这些信息将数据还原到update之前的状态。</p>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</p>
<h4 id="实现原理：redo-log"><a href="#实现原理：redo-log" class="headerlink" title="实现原理：redo log"></a>实现原理：redo log</h4><p>redo log和undo log都属于InnoDB的事务日志。下面先聊一下redo log存在的背景。</p>
<p><strong>InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。</strong>为此，InnoDB提供了缓存(Buffer Pool)，Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为<strong>刷脏</strong>）。</p>
<p><strong>Buffer Pool的使用大大提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。</strong></p>
<p>于是，<strong>redo log被引入来解决这个问题：当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作；</strong>当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是WAL（Write-ahead logging，预写式日志），<strong>所有修改先写入日志，再更新到Buffer Pool</strong>，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。</p>
<p><strong>既然redo log也需要在事务提交时将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘(即刷脏)要快呢？主要有以下两方面的原因：</strong></p>
<ul>
<li>（1）刷脏是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO。</li>
<li>（2）刷脏是以数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入；而redo log中只包含真正需要写入的部分，无效IO大大减少。</li>
</ul>
<h4 id="redo-log与binlog"><a href="#redo-log与binlog" class="headerlink" title="redo log与binlog"></a>redo log与binlog</h4><p>我们知道，在MySQL中还存在binlog(二进制日志)也可以记录写操作并用于数据的恢复，但二者是有着根本的不同的：</p>
<ul>
<li><p>（1）作用不同：redo log是用于crash recovery的，保证MySQL宕机也不会影响持久性；binlog是用于point-in-time recovery的，保证服务器可以基于时间点恢复数据，此外binlog还用于主从复制。</p>
</li>
<li><p>（2）层次不同：<strong>redo log是InnoDB存储引擎实现的</strong>，而<strong>binlog是MySQL的服务器层实现的</strong>，同时支持InnoDB和其他存储引擎。</p>
</li>
<li><p>（3）内容不同：redo log是物理日志，内容基于磁盘的Page；binlog的内容是二进制的，根据binlog_format参数的不同，可能基于sql语句、基于数据本身或者二者的混合。</p>
</li>
<li><p>（4）写入时机不同：binlog在事务提交时写入；redo log的写入时机相对多元：<br>前面曾提到：当事务提交时会调用fsync对redo log进行刷盘；这是默认情况下的策略，修改innodb_flush_log_at_trx_commit参数可以改变该策略，但事务的持久性将无法保证。</p>
<p>除了事务提交时，还有其他刷盘时机：如master thread每秒刷盘一次redo log等，这样的好处是不一定要等到commit时刷盘，commit速度大大加快。</p>
</li>
</ul>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p><strong>乐观锁在数据库中就是MVCC，悲观锁就是行锁和表锁。</strong></p>
<h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p><strong>与原子性、持久性侧重于研究事务本身不同，隔离性研究的是不同事务之间的相互影响</strong>。<strong>隔离性是指，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰</strong>。严格的隔离性，对应了事务隔离级别中的Serializable (可串行化)，但实际应用中出于性能方面的考虑很少会使用可串行化。</p>
<p>隔离性追求的是并发情形下事务之间互不干扰。简单起见，我们仅考虑最简单的读操作和写操作(暂时不考虑带锁读等特殊操作)，那么隔离性的探讨，主要可以分为两个方面：</p>
<ul>
<li>(一个事务)写操作对(另一个事务)写操作的影响：锁机制保证隔离性</li>
<li>(一个事务)写操作对(另一个事务)读操作的影响：MVCC保证隔离性</li>
</ul>
<h4 id="事务的隔离级别-读未提交、读已提交、重复读、序列化"><a href="#事务的隔离级别-读未提交、读已提交、重复读、序列化" class="headerlink" title="事务的隔离级别(读未提交、读已提交、重复读、序列化)"></a>事务的隔离级别(读未提交、读已提交、重复读、序列化)</h4><p><a href="https://blog.csdn.net/JIESA/article/details/51317164" target="_blank" rel="noopener">参考文章</a></p>
<ul>
<li>读未提交：可以读到另外事务未提交的写，会造成脏读</li>
<li>读已提交：可以读到另外事务已提交的写，但可能造成不可重复读</li>
<li>重复读：在事务写的时候，别的事务不可写。可能造成幻读。Mysql默认隔离级别，通过Next-Key锁(行锁与GAP锁结合)解决幻读</li>
<li>序列化：事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读，通过加X锁，开销太大。(<a href="https://blog.csdn.net/yuwei19840916/article/details/3245107" target="_blank" rel="noopener">X锁-排他锁，S锁-共享锁</a>)</li>
</ul>
<h4 id="通过锁的方式实现隔离性"><a href="#通过锁的方式实现隔离性" class="headerlink" title="通过锁的方式实现隔离性"></a>通过锁的方式实现隔离性</h4><ul>
<li><p>读写锁：<br>读写锁的概念很平常，当你在读取数据的时候，应该先加读锁，读取完之后的某个时间再解开读锁，那么加了读锁的数据，应该需要有什么特性呢，应该只能读，不能写，因为加了读锁，说明有事务准备读取这个数据，如果被别的事务重写这个事务，那数据就不准确了。所以一个事务给这个数据加了读锁，别的事务也可以对这个数据加读锁，因为大家都是只读不写。</p>
<p><strong>写锁则具有排他性</strong>（exclusive lock），当一个事务准备对一个数据进行写操作的时候，先要对数据加写锁，那么数据就是可变的，这时候，其他事务就无法对这个数据加读锁了，除非这个写锁释放。</p>
</li>
<li><p>两端式提交锁（Two-phase locking）<br>两段式提交分为两步：</p>
<ul>
<li>加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁（共享锁，其它事务可以继续加共享锁，但不能加排它锁），在进行写操作之前要申请并获得X锁（排它锁，其它事务不能再获得任何锁）。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。</li>
<li>解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>事务</th>
<th>加锁/解锁处理</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>insert into test…</td>
<td>加insert对应的锁</td>
</tr>
<tr>
<td>update test set…</td>
<td>加update对应的锁</td>
</tr>
<tr>
<td>delete from test…</td>
<td>加delete对应的锁</td>
</tr>
<tr>
<td>commit;</td>
<td>事务提交时，同时释放insert、update、delete对应的锁</td>
</tr>
</tbody></table>
<h4 id="MVCC在MySQL的InnoDB中的实现"><a href="#MVCC在MySQL的InnoDB中的实现" class="headerlink" title="MVCC在MySQL的InnoDB中的实现"></a>MVCC在MySQL的InnoDB中的实现</h4><p><a href="https://www.jianshu.com/p/f692d4f8a53e" target="_blank" rel="noopener">参考文章</a></p>
<ul>
<li>数据行版本号</li>
<li>删除版本号</li>
</ul>
<p>在InnoDB中，会在每行数据后添加两个额外的隐藏的值来实现MVCC，这两个值<strong>一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）</strong>。 在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。 在可重读Repeatable reads事务隔离级别下：</p>
<ul>
<li>SELECT时，读取创建版本号&lt;=当前事务版本号，删除版本号为空或&gt;当前事务版本号。</li>
<li>INSERT时，保存当前事务版本号为行的创建版本号</li>
<li>DELETE时，保存当前事务版本号为行的删除版本号</li>
<li>UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行</li>
</ul>
<p>通过MVCC，虽然每行记录都需要额外的存储空间，更多的行检查工作以及一些额外的维护工作，但可以减少锁的使用，大多数读操作都不用加锁，读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，也只锁住必要行。</p>
<h4 id="Innodb的RR级别如何解决幻读问题"><a href="#Innodb的RR级别如何解决幻读问题" class="headerlink" title="Innodb的RR级别如何解决幻读问题"></a>Innodb的RR级别如何解决幻读问题</h4><p><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener">参考</a></p>
<p>在RC级别中，事务A修改了所有teacher_id=30的数据，但是当事务B insert进新数据后，事务A发现莫名其妙多了一行teacher_id=30的数据，而且没有被之前的update语句所修改，这就是“当前读”的幻读。</p>
<p>RR级别中，事务A在update后加锁，事务B无法插入新数据，这样事务A在update前后读的数据保持一致，避免了幻读。这个锁，就是<strong>Gap锁。</strong></p>
<p>MySQL是这么实现的：</p>
<p>在class_teacher这张表中，teacher_id是个索引，那么它就会维护一套B+树的数据关系，为了简化，我们用链表结构来表达（实际上是个树形结构，但原理相同）</p>
<p><img src="/2020/03/13/mysql-mian-shi-hui-zong/GAP.png" alt></p>
<p>如果使用的是没有索引的字段，比如<code>update class_teacher set teacher_id=7 where class_name=‘初三八班（即使没有匹配到任何数据）’</code>,那么会给全表加入gap锁。同时，它不能像上文中行锁一样经过MySQL Server过滤自动解除不满足条件的锁，因为没有索引，则这些字段也就没有排序，也就没有区间。除非该事务提交，否则其它事务无法插入任何数据。</p>
<p><strong>行锁防止别的事务修改或删除，GAP锁防止别的事务新增，行锁和GAP锁结合形成的的Next-Key锁共同解决了RR级别在写数据时的幻读问题。</strong></p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>一致性是指事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。数据库的完整性约束包括但不限于：实体完整性（如行的主键存在且唯一）、列完整性（如字段的类型、大小、长度要符合要求）、外键约束、用户自定义完整性（如转账前后，两个账户余额的和应该不变）。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>可以说，一致性是事务追求的最终目标：前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性。此外，除了数据库层面的保障，一致性的实现也需要应用层面进行保障。</p>
<p>实现一致性的措施包括：</p>
<p>保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证<br>数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等<br>应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致</p>
<p><a href="https://www.cnblogs.com/kismetv/p/10331633.html" target="_blank" rel="noopener">https://www.cnblogs.com/kismetv/p/10331633.html</a></p>
<h3 id="事务的隔离级别分别解决哪些问题-脏读、不可重复读、幻读丢失修改"><a href="#事务的隔离级别分别解决哪些问题-脏读、不可重复读、幻读丢失修改" class="headerlink" title="事务的隔离级别分别解决哪些问题(脏读、不可重复读、幻读丢失修改)"></a>事务的隔离级别分别解决哪些问题(脏读、不可重复读、幻读丢失修改)</h3><table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>RU读为提交</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>RC读已提交</td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>RR可重复读</td>
<td>不可能</td>
<td>不可能</td>
<td>可能</td>
</tr>
<tr>
<td>序列化</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
</tbody></table>
<p>Innodb在RR级别解决幻读采用Next-Key锁(GAP锁和行锁)方法</p>
<h3 id="事务的回滚-undo、redo日志"><a href="#事务的回滚-undo、redo日志" class="headerlink" title="事务的回滚(undo、redo日志)"></a>事务的回滚(undo、redo日志)</h3><p><a href="https://blog.csdn.net/u012732259/article/details/39524405" target="_blank" rel="noopener">MYSQL 之DDL、DML、DCL、TCL的区别</a></p>
<ul>
<li>DDL:操作表结构的命令 如: CREATE、ALTER、DROP</li>
<li>DML：操作数据的命令 如select update delete insert</li>
</ul>
<p>事务的回滚适用于DML，不适用于DDL</p>
<p>那么DDL事务回滚</p>
<p>先DCL 再 DDL 最后将DML放入事务中</p>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="MyISAM与InnoDB的区别"><a href="#MyISAM与InnoDB的区别" class="headerlink" title="MyISAM与InnoDB的区别"></a>MyISAM与InnoDB的区别</h3><p>两种类型最主要的差别就是<strong>Innodb支持事务处理与外键和行级锁</strong>。而MyISAM不支持.所以MyISAM往往就容易被人认为只适合在小项目中使用。<strong>MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快</strong>。</p>
<p>以下是一些细节和具体实现的差别：</p>
<ul>
<li>1.InnoDB不支持FULLTEXT类型的索引。</li>
<li>2.InnoDB中不保存表的具体行数，也就是说，执行<code>select count(*) from table</code>时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(*)语句包含 where条件时，两种表的操作是一样的。</li>
<li>3.对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。</li>
<li>4.<code>DELETE FROM table</code>时，InnoDB不会重新建立表，而是一行一行的删除。</li>
<li>5.<code>LOAD TABLE FROM MASTER</code>操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。</li>
<li>另外，InnoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如<code>update table set num=1 where name like “%aaa%”</code></li>
</ul>
<p>作为使用MySQL的用户角度出发，Innodb和MyISAM都是比较喜欢的，<strong>如果数据库平台要达到需求：99.9%的稳定性，方便的扩展性和高可用性来说的话，MyISAM绝对是首选。</strong></p>
<p>原因如下：</p>
<ul>
<li>1、平台上承载的大部分项目是读多写少的项目，而MyISAM的读性能是比Innodb强不少的。</li>
<li>2、MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。</li>
<li>3、经常隔1，2个月就会发生应用开发人员不小心update一个表where写的范围不对，导致这个表没法正常用了，这个时候MyISAM的优越性就体现出来了，随便从当天拷贝的压缩包取出对应表的文件，随便放到一个数据库目录下，然后dump成sql再导回到主库，并把对应的binlog补上。如果是Innodb，恐怕不可能有这么快速度，别和我说让Innodb定期用导出xxx.sql机制备份，因为最小的一个数据库实例的数据量基本都是几十G大小。</li>
<li>4、从接触的应用逻辑来说，select count(*) 和order by 是最频繁的，大概能占了整个sql总语句的60%以上的操作，而这种操作Innodb其实也是会锁表的，很多人以为Innodb是行级锁，那个只是where对它主键是有效，非主键的都会锁全表的。</li>
<li>5、还有就是经常有很多应用部门需要我给他们定期某些表的数据，MyISAM的话很方便，只要发给他们对应那表的frm.MYD,MYI的文件，让他们自己在对应版本的数据库启动就行，而Innodb就需要导出xxx.sql了，因为光给别人文件，受字典数据文件的影响，对方是无法使用的。</li>
<li>6、如果和MyISAM比insert写操作的话，Innodb还达不到MyISAM的写性能，如果是针对基于索引的update操作，虽然MyISAM可能会逊色Innodb,但是那么高并发的写，从库能否追的上也是一个问题，还不如通过多实例分库分表架构来解决。</li>
<li>7、如果是用MyISAM的话，merge引擎可以大大加快应用部门的开发速度，他们只要对这个merge表做一些select count(*)操作，非常适合大项目总量约几亿的rows某一类型(如日志，调查统计)的业务表。</li>
<li>当然Innodb也不是绝对不用，用事务的项目就用Innodb的。另外，可能有人会说你MyISAM无法抗太多写操作，但是可以通过架构来弥补。</li>
</ul>
<h3 id="上述存储引擎在索引结构方面的区别"><a href="#上述存储引擎在索引结构方面的区别" class="headerlink" title="上述存储引擎在索引结构方面的区别"></a>上述存储引擎在索引结构方面的区别</h3><h3 id="各自的使用场景"><a href="#各自的使用场景" class="headerlink" title="各自的使用场景"></a>各自的使用场景</h3><h2 id="锁-共享锁、排他锁、行锁、表锁、间隙锁"><a href="#锁-共享锁、排他锁、行锁、表锁、间隙锁" class="headerlink" title="锁(共享锁、排他锁、行锁、表锁、间隙锁)"></a>锁(共享锁、排他锁、行锁、表锁、间隙锁)</h2><p><a href="https://zhuanlan.zhihu.com/p/29150809" target="_blank" rel="noopener">总结的很好</a></p>
<h3 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h3><h2 id="SQL语句-常见为聚类函数的使用、表连接查询"><a href="#SQL语句-常见为聚类函数的使用、表连接查询" class="headerlink" title="SQL语句(常见为聚类函数的使用、表连接查询)"></a>SQL语句(常见为聚类函数的使用、表连接查询)</h2><h2 id="分库分表策略"><a href="#分库分表策略" class="headerlink" title="分库分表策略"></a>分库分表策略</h2><h2 id="SQL注入原理-常用SQL防注入框架"><a href="#SQL注入原理-常用SQL防注入框架" class="headerlink" title="SQL注入原理(常用SQL防注入框架)"></a>SQL注入原理(常用SQL防注入框架)</h2><h2 id="Mysql的sql处理过程"><a href="#Mysql的sql处理过程" class="headerlink" title="Mysql的sql处理过程"></a>Mysql的sql处理过程</h2><h3 id="Mysql逻辑分层"><a href="#Mysql逻辑分层" class="headerlink" title="Mysql逻辑分层"></a>Mysql逻辑分层</h3><ul>
<li><strong>第一层：Connect层</strong></li>
</ul>
<p><strong>负责连接管理、授权认证、安全等等</strong></p>
<p>每个客户端的连接都对应着服务器上的一个线程。服务器上维护了一个线程池，避免为每个连接都创建销毁一个线程。当客户端连接到MySQL服务器时，服务器对其进行认证。可以通过用户名和密码的方式进行认证，也可以通过SSL证书进行认证。登录认证通过后，服务器还会验证该客户端是否有执行某个查询的权限。</p>
<ul>
<li><strong>第二层：Service层</strong></li>
</ul>
<p><strong>负责解析查询(编译SQL)，并对其进行优化(如调整表的读取顺序，选择合适的索引等)</strong>。对于SELECT语句，在解析查询前，服务器会先检查查询缓存，如果能在其中找到对应的查询结果，则无需再进行查询解析、优化等过程，直接返回查询结果。存储过程、触发器、视图等都在这一层实现。</p>
<ul>
<li><strong>第三层：存储引擎</strong></li>
</ul>
<p><strong>存储引擎负责在MySQL中存储数据、提取数据、开启一个事务等等</strong>。存储引擎通过API与上层进行通信，这些API屏蔽了不同存储引擎之间的差异，使得这些差异对上层查询过程透明。存储引擎不会去解析SQL。</p>
<h3 id="Mysql组件："><a href="#Mysql组件：" class="headerlink" title="Mysql组件："></a>Mysql组件：</h3><ul>
<li><ol>
<li>线程池组件（Connection Pool）：处理connetor发起的请求，处理用户登录、线程复用、连接数控制、内存检测和缓冲等功能</li>
</ol>
</li>
<li><ol start="2">
<li>管理服务和工具组件（Mangerment Services &amp; Utilities）主要是完成数据备份和恢复、复制、集群管理、配置、迁移和元数据</li>
</ol>
</li>
<li><ol start="3">
<li>SQL接口组件（Sql Interface）：进行DML、DLL、视图、存储过程、触发器等操作和管理，通过sql命令来获取查询结果</li>
</ol>
</li>
<li><ol start="4">
<li>查询分析器组件（Parser）：这里接受并通过解析器来解析sql接口组件传递过来的sql语句，解析器通过词法分析和语法分析等步骤来验证sql的正确性，解析器是由Lex和YACC实现的，是一个很长的脚本<br>主要功能：</li>
</ol>
<ul>
<li>a . 将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的 </li>
<li>b.  如果在分解构成中遇到错误，那么就说明这个sql语句是不合理的</li>
</ul>
</li>
<li><ol start="5">
<li>优化器组件（Optimizer）：用于优化查询sql</li>
</ol>
</li>
<li><ol start="6">
<li>缓冲组件（Cache&amp;Buffer）：将各个组件得出的结果缓冲起来，可以是查询结果，查询sql等等</li>
</ol>
</li>
<li><ol start="7">
<li>插件式存储引擎（Storage Engines）：各种存储引擎插件，如myisam、innodb</li>
</ol>
</li>
<li><ol start="8">
<li>物理文件（Files &amp; Logs）：用于存储真正的数据，日志、索引和缓存等数据</li>
</ol>
</li>
</ul>
<h2 id="sql查询慢的原因"><a href="#sql查询慢的原因" class="headerlink" title="sql查询慢的原因"></a>sql查询慢的原因</h2><ul>
<li>1、没有索引或者没有用到索引（这是查询慢最常见的问题，是程序设计的缺陷）</li>
<li>2、I/O 吞吐量小，形成了瓶颈效应。</li>
<li>3、没有创建计算列导致查询不优化。</li>
<li>4、内存不足</li>
<li>5、网络速度慢</li>
<li>6、查询出的数据量过大（可采用多次查询，其他的方法降低数据量）</li>
<li>7、锁或者死锁（这是查询慢最常见的问题，是程序设计的缺陷）</li>
<li>8、sp_lock,sp_who,活动的用户查看,原因是读写竞争资源。</li>
<li>9、返回了不必要的行和列</li>
<li>10、查询语句不好，没有优化</li>
</ul>
<h2 id="待回答问题"><a href="#待回答问题" class="headerlink" title="待回答问题"></a>待回答问题</h2><p>MySQL存储与索引有关问题<br>Float、Decimal 存储金额的区别？<br>Datetime、Timestamp 存储时间的区别？<br>Char、Varchar、Varbinary 存储字符的区别？<br>什么是索引？<br>对比一下B+树索引和 Hash索引？<br>MySQL索引类型有？<br>如何管理 MySQL索引？<br>对Explain参数及重要参数的理解？<br>索引利弊是什么及索引分类？<br>二叉树的转置是什么？<br>聚簇索引和非聚簇索引的区别？<br>B+tree 如何进行优化？索引遵循哪些原则？存储引擎会进行哪些自动优化？到底何时索引会失效？<br>索引与锁有什么关系？<br>还有什么其他的索引类型，各自索引有哪些优缺点？<br>MySQL事务和锁有关问题<br>谈谈对Innodb事务的理解？<br>说说数据库事务特点及潜在问题？<br>什么是MySQL隔离级别？<br>有多少种事务失效的场景，如何解决？<br>一致性非锁定读和一致性锁定读是什么？<br>Innodb如何解决幻读？<br>讲讲Innodb行锁？<br>死锁及监控是什么？<br>自增长与锁 ，锁的算法，锁问题，锁升级是什么？<br>乐观锁的线程如何做失败补偿？<br>高并发场景（领红包）如何防止死锁，保证数据一致性？<br>谈谈MySQL的锁并发？<br>MySQL性能优化有关问题<br>回表和集群因子是什么？<br>讲讲表与表之间的关系？<br>了解查询优化器模块；<br>查询优化的基本思路是什么？<br>说说MySQL读写分离、分库分表？<br>Query语句对数据库性能有什么影响？<br>Schema设计对系统性能有什么影响？<br>硬件环境对数据库的性能有什么影响？<br>表结构对性能有什么影响?<br>浅谈索引优化？<br>JOIN的原理是什么？<br>说说Sql优化的几点原则？<br>MySQL表设计及规范？<br>说说MySQL几种存储引擎应用场景？<br>MySQL常用优化方式有哪些？<br>MySQL常用监控？<br>MySQL瓶颈分析？<br>MySQL的系统学习方法</p>
]]></content>
      <categories>
        <category>求职</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式题汇总</title>
    <url>/2020/03/13/she-ji-mo-shi-ti-hui-zong/</url>
    <content><![CDATA[<h2 id="设计原则有哪些？"><a href="#设计原则有哪些？" class="headerlink" title="设计原则有哪些？"></a>设计原则有哪些？</h2><ul>
<li>单一职责原则：让类或接口职责单一</li>
<li>里氏替换原则：子类去替换父类，做到通用编程</li>
<li>依赖倒置原则：面向接口编程</li>
<li>接口隔离原则：接口的设计要精简单一</li>
<li>迪米特法则：最少知识原则，降低依赖间的耦合</li>
<li>开闭原则：对扩展开放，对修改关闭</li>
</ul>
<h2 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h2><a id="more"></a>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ul>
<li>懒汉式（线程安全问题）</li>
<li>饿汉式</li>
</ul>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.md" target="_blank" rel="noopener"><strong>简单工厂模式</strong></a></h3><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.md" target="_blank" rel="noopener"><strong>工厂方法</strong></a></h3><p>定义一个创建对象的接口，但由子类决定实例化哪个类。工厂方法把实例化推迟到子类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Product product=factoryMethod();</span><br><span class="line">        <span class="comment">//do something with product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.md" target="_blank" rel="noopener"><strong>抽象工厂</strong></a></h3><p>提供一个接口，用于创建<strong>相关的对象家族</strong>。</p>
<p>抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。</p>
<p>抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory中的createProductA()和createProductB()方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。</p>
<p>至于创建对象的家族这一概念是在Client体现，Client要通过AbstractFactory同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client需要同时创建出这两个对象。</p>
<p>从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。</p>
<h3 id="生成器（Builder）"><a href="#生成器（Builder）" class="headerlink" title="生成器（Builder）"></a><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%94%9F%E6%88%90%E5%99%A8.md" target="_blank" rel="noopener"><strong>生成器（Builder）</strong></a></h3><p>封装一个对象的构造过程，并允许按步骤构造。</p>
<p><code>java.lang.StringBuilder</code></p>
<h3 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式(Prototype)"></a><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener"><strong>原型模式(Prototype)</strong></a></h3><p>使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。</p>
<h2 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h2><h3 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E8%B4%A3%E4%BB%BB%E9%93%BE.md" target="_blank" rel="noopener"><strong>责任链</strong></a></h3><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%91%BD%E4%BB%A4.md" target="_blank" rel="noopener"><strong>命令</strong></a></h3><p>看到这</p>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%8A%B6%E6%80%81.md" target="_blank" rel="noopener"><strong>状态</strong></a></h3><p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。</p>
<h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%AD%96%E7%95%A5.md" target="_blank" rel="noopener"><strong>策略</strong></a></h3><p>定义一系列算法，封装每个算法，并使它们可以互换。</p>
<p>策略模式可以让算法独立于使用它的客户端。</p>
<p><strong>策略模式与状态模式的比较</strong></p>
<p>状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。</p>
<p>状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。</p>
<h2 id="SpringBoot可以借鉴的设计模式"><a href="#SpringBoot可以借鉴的设计模式" class="headerlink" title="SpringBoot可以借鉴的设计模式"></a>SpringBoot可以借鉴的设计模式</h2><h3 id="单例模式-1"><a href="#单例模式-1" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式，主要目的是保证实例的独一无二，提高资源的重复利用。单例模式的难点就在于需要通过代码来维护系统中实例的唯一性，需要确保各种线程不安全环境下实例的独一性。</p>
<p>常用于配置文件的读取，监控程序，IOC容器等，spring中最常用的单例实现方式就是注册登记式的单例模式，这个后面看源码的时候，会深入了解</p>
<p>一句话总结：保证独一无二</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>原型模式其实就是针对复制而言的一种模式，原型模式中需要弄清<strong>浅复制和深复制</strong>的区别。</p>
<ul>
<li>浅复制：对于数据类型是基本数据类型的成员变量，浅复制直接进行值的传递，即将原始对象中属性的值复制一份给新对象；对于引用数据类型的成员变量，浅复制就只是传递引用，这样使得两个对象之间其实操作的是同一份数据</li>
<li>深复制：就是在浅复制的基础上，完成对象引用的深层次的复制。深复制不仅要复制对象所有的基本数据类型，还要在复制过程中为原有的引用数据类型开辟新的存储空间，将引用对象的数据拷贝到新开辟的存储空间中。一定程度上来说，对象进行深复制就是要对整个对象图进行复制。</li>
</ul>
<p>更为形象的图形解释可以参考这篇博客——深复制与浅复制的区别</p>
<p><strong>原型模式主要就是应用于对象间的复制。spring中我们在配置对象的scope的时候，将scope配置成为prototype，即将bean配置成多例的，其中就会用到原型模式。</strong></p>
<p>一句话总结：复制作用</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>从总体来看代理模式的作用就是在某一个类中某一指定的方法执行之前和执行之后，织入一些增强逻辑，这个理解依旧有点绕，但是结合AOP来理解就不难了，AOP的主要作用就是在目标方法的执行前和执行后织入一些增强的逻辑。</p>
<p>代理通常分为<strong>静态代理和动态代理</strong>，由于静态代理在扩展性方面的不足才引出了动态代理。</p>
<blockquote>
<p>引申：静态代理需要目标对象与代理对象均要实现同一接口，当接口添加新方法时，代理对象与目标对象都要实现该方法，从而导致扩展性不足。</p>
</blockquote>
<p>动态代理的实现方式常见的有两种：<strong>一种是JDK Proxy，另一种是CgLib</strong>，前者是动态植入，后者是继承；前者要求目标类要实现一个接口，目的就是方便获取方法信息，方便JDK利用反射动态调用。使用JDK动态代理的时候，增强的逻辑类需要实现InvocationHandler接口，在其中的invoke方法中去编写增强逻辑。CGLib相对来说就容易的多，具体可以见上文。</p>
<p><strong>动态代理在spring中用的较多，典型的AOP就是用的代理。除此之外，结合实际来看，如果针对原有的目标需要动态进行增强都可以利用动态代理模式</strong></p>
<p>一句话总结：买票找黄牛，办事找代理。</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式是比较好理解的一种设计模式，该模式就是封装了一些算法供用户选择，根据用户的选择如何确定到指定的算法策略的过程中，为了避免使用if…else或者switch这种选择语句，就需要结合工厂模式进行使用，因此策略模式一定程度上并不单独使用</p>
<p><strong>使用场景：支付方式的选择</strong></p>
<p>一句话总结：我走那条路，我做主</p>
<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>模板方法模式也是一个比较好理解的设计模式，无非就是在估计的流程中，加入一些不同的算法实现，最终产生出不同的结果而已，<strong>提供的模板一般采用抽象类来实现，需要加入自己的算法的时候，就通过继承这个抽象类来完成。</strong></p>
<p><strong>使用场景：JdbcTemplate，工作流，spring-orm</strong></p>
<p>一句话总结：流程标准化，原料自己加</p>
<h3 id="委派模式"><a href="#委派模式" class="headerlink" title="委派模式"></a>委派模式</h3><p><strong>委派模式某一种程度上是代理和策略模式的结合</strong>，在实现过程中，最重要的就是对委派列表的维护，这在之前的博客中实现的比较简单，直接值委派者中维护了引用。</p>
<p><strong>使用场景：spring中的DispatcherServlet、Delegate命名结尾的都是委派模式</strong></p>
<p>一句话总结：项目经理委派活给普通员工</p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p><strong>适配器模式从命名来看也能理解其意思，需要和装饰者模式区分开来。</strong>针对两者的区别还是列出一个类图吧。</p>
<p><img src="/2020/03/13/she-ji-mo-shi-ti-hui-zong/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE%E5%AF%B9%E6%AF%94.png" alt="适配器模式与装饰者模式类图对比"></p>
<p>使用场景：DataAdapter</p>
<p>一句话总结：转换头</p>
<h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>一定程度上来讲，装饰者模式与适配器模式有点类似，两者的具体区别上面的图中已经很好的展示出来了</p>
<p><strong>使用场景：spring中以Decorate结尾的都是使用的装饰者模式，IO流的设计，数据源</strong></p>
<p>一句话总结：同宗同源的增强</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>只需要理清楚两个角色，<strong>消息发布者和消息订阅者</strong>，难点在于消息发布者如何维护多个消息订阅者的信息</p>
<p><strong>使用场景：消息队列，swing中的监听器，spring中的监听器</strong></p>
<p>一句话总结：完成时通知一下。</p>
]]></content>
      <categories>
        <category>求职</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议面试题汇总</title>
    <url>/2020/03/13/wang-luo-xie-yi-mian-shi-ti-hui-zong/</url>
    <content><![CDATA[<h2 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h2><h3 id="Get和Post比较"><a href="#Get和Post比较" class="headerlink" title="Get和Post比较"></a>Get和Post比较</h3><p><a href="https://learnku.com/articles/25881" target="_blank" rel="noopener">看这篇装逼文章</a></p>
<ul>
<li>Get发送一次数据包 Post发送两次数据包<ul>
<li>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</li>
<li>对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</li>
</ul>
</li>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>
<li>GET产生的URL地址可以被Bookmark，而POST不可以。</li>
<li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li>
<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>
<li>GET参数通过URL传递，POST放在Request body中。<a id="more"></a>
<blockquote>
<p>Session和Cookie比较</p>
</blockquote>
</li>
</ul>
<p>session是存储在服务器端,cookie是存储在客户端的,所以安全来讲session的安全性要比cookie高,然后我们获取session里的信息是通过存放在<strong>会话cookie</strong>里的sessionid获取的。又由于session是存放在服务器的内存中,所以session里的东西不断增加会造成服务器的负担,所以会把很重要的信息存储在session中,而把一些次要东西存储在客户端的cookie里。</p>
<p>cookie确切的说分为两大类分为<strong>会话cookie和持久化cookie</strong>,会话cookie确切的说是存放在客户端浏览器的内存中,所以说他的生命周期和浏览器是一致的,浏览器关了会话cookie也就消失了,然而持久化cookie是存放在客户端硬盘中,而持久化cookie的生命周期就是我们在设置cookie时候设置的那个保存时间,然后我们考虑一问题当浏览器关闭时session会不会丢失,从上面叙述分析session的信息是通过sessionid获取的,而sessionid是存放在会话cookie当中的,当浏览器关闭的时候会话cookie消失所以我们的sessionid也就消失了,但是session的信息还存在服务器端,这时我们只是查不到所谓的session但它并不是不存在。那么,session在什么情况下丢失,就是在服务器关闭的时候,或者是sessio过期,再或者调用了invalidate()的或者是我们想要session中的某一条数据消失调用session.removeAttribute()方法,然后session在什么时候被创建呢,确切的说是通过调用session.getsession来创建,这就是session与cookie的区别。</p>
<blockquote>
<p>常用HTTP的头部</p>
</blockquote>
<table>
<thead>
<tr>
<th>头部</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept: text/html,image/*</td>
<td>浏览器接受的数据类型</td>
</tr>
<tr>
<td>Accept-Charset: ISO-8859-1</td>
<td>浏览器接受的编码格式</td>
</tr>
<tr>
<td>Accept-Encoding: gzip,compress</td>
<td>浏览器接受的数据压缩格式</td>
</tr>
<tr>
<td>Accept-Language: en-us,zh-</td>
<td>浏览器接受的语言</td>
</tr>
<tr>
<td>Host: <a href="http://www.it315.org:80" target="_blank" rel="noopener">www.it315.org:80</a></td>
<td>（必须的）当前请求访问的目标地址（主机:端口）</td>
</tr>
<tr>
<td>If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT</td>
<td>浏览器最后的缓存时间</td>
</tr>
<tr>
<td>Referer: <a href="http://www.it315.org/index.jsp" target="_blank" rel="noopener">http://www.it315.org/index.jsp</a></td>
<td>当前请求来自于哪里</td>
</tr>
<tr>
<td>User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)</td>
<td>浏览器类型</td>
</tr>
<tr>
<td>Cookie:name=eric</td>
<td>浏览器保存的cookie信息</td>
</tr>
<tr>
<td>Connection: close/Keep-Alive</td>
<td>浏览器跟服务器连接状态。close: 连接关闭  keep-alive：保存连接。</td>
</tr>
<tr>
<td>Date: Tue, 11 Jul 2000 18:23:51 GMT</td>
<td>请求发出的时间</td>
</tr>
</tbody></table>
<h3 id="常用的HTTP状态码"><a href="#常用的HTTP状态码" class="headerlink" title="常用的HTTP状态码"></a>常用的HTTP状态码</h3><p><a href="https://www.cnblogs.com/starof/p/5035119.html" target="_blank" rel="noopener">参考文章</a></p>
<p>100 200 201 202 3xx 4xx 5xx</p>
<blockquote>
<p>HTTP1.0、1.1、2.0三个版本各自的特性</p>
</blockquote>
<p><a href="https://www.jianshu.com/p/52d86558ca57" target="_blank" rel="noopener">参考文章</a></p>
<ul>
<li>HTTP1.0与1.1区别<ul>
<li>缓存处理</li>
<li>带宽优化及网络连接的使用</li>
<li>错误通知的管理</li>
<li>消息在网络中的发送</li>
<li>互联网地址的维护</li>
<li>安全性及完整性</li>
</ul>
</li>
<li>HTTP2.0<ul>
<li>多路复用</li>
<li>二进制分帧</li>
<li>首部压缩</li>
<li>服务器推送</li>
<li></li>
</ul>
</li>
</ul>
<h3 id="HTTPS中的SSL握手过程"><a href="#HTTPS中的SSL握手过程" class="headerlink" title="HTTPS中的SSL握手过程"></a>HTTPS中的SSL握手过程</h3><p><a href="https://www.jianshu.com/p/7158568e4867" target="_blank" rel="noopener">参考文章</a></p>
<p>RSA/DH</p>
<p><a href="https://zhuanlan.zhihu.com/p/43789231" target="_blank" rel="noopener">非对称加密-&gt; 对称加密</a></p>
<p><strong>由于RSA非对称加密以幂模运算的存在，导致其比ASE对称加密慢。</strong></p>
<h3 id="CSRF、XSS攻击，避免的方法"><a href="#CSRF、XSS攻击，避免的方法" class="headerlink" title="CSRF、XSS攻击，避免的方法"></a>CSRF、XSS攻击，避免的方法</h3><p><a href="https://www.jianshu.com/p/64a413ada155" target="_blank" rel="noopener">参考文章</a></p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h3><p>记住常用部分占用多少字节</p>
<h3 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h3><ul>
<li>三次握手<ul>
<li>客户端发送请求报文给服务端，SYN=1 这个包序号为x </li>
<li>服务端给客户端发送确认报文ACK=1，SYN=1 这个包序号为y 确认号为x+1 此次握手表明 服务端可以接收客户端，但不确定客户端能否接收</li>
<li>客户端给服务端发送确认报文 ACK=1 序号为x+1 确认号为y+1 此次握手告诉服务端，客户端也可以接收</li>
</ul>
</li>
<li>四次挥手<ul>
<li>客户端发送释放报文，FIN=1给服务端 此时客户端进入半关闭FIN-WAIT状态</li>
<li>服务端返回确认报文ACK=1，此时服务端进入CLOSE-WAIT状态，接着服务端发送剩余的数据</li>
<li>服务端发送完数据后发送释放报文给客户端，FIN=1，ACK=1</li>
<li>客户端返回确认报文给服务端，后进入TIME-WAIT状态 经过2MSL时间后关闭，此时若再次接收服务端释放报文，则重发确认报文。</li>
</ul>
</li>
</ul>
<h3 id="关于第三次握手的解释"><a href="#关于第三次握手的解释" class="headerlink" title="关于第三次握手的解释"></a>关于第三次握手的解释</h3><p>我们可以假设没有第三次握手机制。当客户端向服务端发送请求建立报文A，由于网络延迟等原因导致超时后客户端重新发送请求建立连接报文B，请求建立连接报文B到达服务端后，服务端返回确认报文给客户端建立连接并传输数据。此时请求报文A也到达服务端，服务端会认为这是新的建立连接请求，并依旧返回确认报文给客户端，客户端没有建立连接需求，自然不会发送数据给服务端，而此时服务端会认为连接已经建立，会始终等待客户端发送数据，直到超出保活计数器的设定值，而将客户端判定为出了问题，才会关闭这个连接。这样就浪费了很多服务器的资源。而如果有第三次握手，客户端不会返回确认，服务端收不到确认报文会认为客户端没有建立连接请求，从而不建立该连接。</p>
<h3 id="第三次握手挥手失败的处理"><a href="#第三次握手挥手失败的处理" class="headerlink" title="第三次握手挥手失败的处理"></a>第三次握手挥手失败的处理</h3><p>第三次握手失败时，由于第二次握手时，服务端返回SYN+ACK给客户端，因此客户端进入成功建立连接状态，而此时服务端由于未收到客户端的ACK，这就要分为以下几种情况讨论：</p>
<ul>
<li>第一种情况是客户端发出的确认报文丢失，但是下一个数据包未丢失，此数据包中也含有ACK信息，服务端能够进入ESTABLISHED状态。</li>
<li>第二种情况是客户端和服务端均没有发送数据，或者服务端想发送数据，但由于未接收到客户端ACK，从而不能发送数据，服务器端会有定时器，重新发送SYN+ACK数据包给客户端，客户端再次返回ACK数据包，则成功建立连接。</li>
<li>第三种情况是一直不成功，一般是五次重传以后，服务器端会有超时设置，如果超时，服务端发送RTS报文，进入CLOSED状态，避免SYN洪泛攻击。</li>
</ul>
<h3 id="SYN洪泛攻击"><a href="#SYN洪泛攻击" class="headerlink" title="SYN洪泛攻击"></a>SYN洪泛攻击</h3><p><a href="https://zhuanlan.zhihu.com/p/29539671" target="_blank" rel="noopener">康康</a></p>
<p>SYN Flood（半开放攻击）是一种拒绝服务（DDoS）攻击，其目的是通过消耗所有可用的服务器资源使服务器不可用于合法流量。通过重复发送初始连接请求（SYN）数据包，攻击者能够压倒目标服务器机器上的所有可用端口，导致目标设备根本不响应合法流量。</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p><a href="https://juejin.im/entry/5b7fcd13f265da4372473199" target="_blank" rel="noopener">这个写的不错</a></p>
<p>TCP 拥塞控制算法发展的过程中出现了如下几种不同的思路：</p>
<ul>
<li><p>基于<strong>丢包</strong>的拥塞控制：将丢包视为出现拥塞，采取缓慢探测的方式，逐渐增大拥塞窗口，当出现丢包时，将拥塞窗口减小，如 Reno、Cubic 等。</p>
</li>
<li><p>基于<strong>时延</strong>的拥塞控制：将时延增加视为出现拥塞，延时增加时增大拥塞窗口，延时减小时减小拥塞窗口，如 Vegas、FastTCP 等。</p>
</li>
<li><p>基于<strong>链路容量</strong>的拥塞控制：实时测量网络带宽和时延，认为网络上报文总量大于带宽时延乘积时出现了拥塞，如 BBR。</p>
</li>
<li><p>基于<strong>学习</strong>的拥塞控制：没有特定的拥塞信号，而是借助<strong>评价函数</strong>，基于训练数据，使用机器学习的方法形成一个控制策略，如 Remy。</p>
</li>
</ul>
<p><strong>Reno算法：慢开始、拥塞避免、快重传、快恢复</strong> 慢开始指数增长，到达慢开始阈值ssthresh时，进入拥塞避免，线性增长，如果出现超时，则进入重新慢开始，此时ssthresh变为当前cnwd的一半。如果出现丢包，则进入快重传阶段，直接进入拥塞避免，但ssthresh变为当前cnwd的一半。</p>
<p><strong>Vegas算法</strong>：将时延 RTT 的增加作为网络出现拥塞的信号，RTT 增加，拥塞窗口减小，RTT 减小，拥塞窗口增加。</p>
<blockquote>
<p>流量控制(零窗口含义、接受窗口的协商)</p>
</blockquote>
<p><strong>什么是流量控制？流量控制的目的？</strong></p>
<p>如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。</p>
<p><strong>如何实现流量控制？</strong></p>
<p>由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的 ACK中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。</p>
<p><strong>流量控制引发的死锁？怎么避免死锁的发生？</strong></p>
<p>当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。</p>
<p>为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。</p>
<p><strong>拥塞控制作用于网络，防止大量数据进入网络导致阻塞，流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。</strong></p>
<h3 id="Nagle"><a href="#Nagle" class="headerlink" title="Nagle"></a>Nagle</h3><p><a href="https://blog.csdn.net/ce123_zhouwei/article/details/9050797" target="_blank" rel="noopener">参考文章</a></p>
<h3 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h3><ul>
<li>1、基于连接与无连接； why？</li>
<li>2、对系统资源的要求（TCP较多，UDP少）； why?</li>
<li>3、UDP程序结构较简单； why?</li>
<li>4、流模式与数据报模式 ； why?</li>
<li>5、TCP保证数据正确性，UDP可能丢包； why?</li>
<li>6、TCP保证数据顺序，UDP不保证。why?</li>
</ul>
<h2 id="描述数据从网卡至内核空间最后至用户空间的过程"><a href="#描述数据从网卡至内核空间最后至用户空间的过程" class="headerlink" title="描述数据从网卡至内核空间最后至用户空间的过程"></a>描述数据从网卡至内核空间最后至用户空间的过程</h2><p>数据通过网线进入网卡后，进行模数转换写入网卡缓存，通过DMA写入计算机内存，一个内核线程根据TCP协议进行拆包，最后将数据写入每个socket对应的sync/accept队列中，供应用程序使用(应用程序需要进行组包操作，对应着分包操作)。</p>
<h2 id="url到获取页面过程"><a href="#url到获取页面过程" class="headerlink" title="url到获取页面过程"></a>url到获取页面过程</h2><p>在浏览器中输入一个网址，首先要做的就是域名的解析，也就是域名-&gt;ip的解析，依次查看了浏览器缓存，系统缓存，hosts文件，路由器缓存，递归搜索根域名服务器，直到找到最终的ip地址。</p>
<p>然后就是TCP协议的三次握手建立连接，过程我们已经阐述了。由浏览器发送一个HTTP请求；经过路由器的转发，通过服务器的防火墙，该HTTP请求到达了服务器；服务器处理该HTTP请求，返回一个HTML文件；浏览器解析该HTML文件，并且渲染显示在浏览器端。</p>
<p>这里，我们可以来具体阐述下HTTP协议和TCP协议的关系与区别。</p>
<h2 id="介绍TCP-IP头，其中哪些首部涉及滑动窗口，以及拥塞控制"><a href="#介绍TCP-IP头，其中哪些首部涉及滑动窗口，以及拥塞控制" class="headerlink" title="介绍TCP/IP头，其中哪些首部涉及滑动窗口，以及拥塞控制"></a>介绍TCP/IP头，其中哪些首部涉及滑动窗口，以及拥塞控制</h2><h2 id="http与https的区别"><a href="#http与https的区别" class="headerlink" title="http与https的区别"></a>http与https的区别</h2><h2 id="CDN的关键技术"><a href="#CDN的关键技术" class="headerlink" title="CDN的关键技术"></a>CDN的关键技术</h2><p><a href="https://blog.csdn.net/moakun/article/details/80690536" target="_blank" rel="noopener">参考连接</a></p>
<p>CDN网络是在用户和服务器之间增加Cache层，如何将用户的请求引导到Cache上获得源服务器的数据，主要是通过接管DNS实现，这就是CDN的最基本的原理。</p>
<ul>
<li>1.用户向浏览器输入<a href="http://www.web.com这个域名，浏览器第一次发现本地没有dns缓存，则向网站的DNS服务器请求；" target="_blank" rel="noopener">www.web.com这个域名，浏览器第一次发现本地没有dns缓存，则向网站的DNS服务器请求；</a></li>
<li>2.网站的DNS域名解析器设置了CNAME，指向了<a href="http://www.web.51cdn.com,请求指向了CDN网络中的智能DNS负载均衡系统；" target="_blank" rel="noopener">www.web.51cdn.com,请求指向了CDN网络中的智能DNS负载均衡系统；</a></li>
<li>3.智能DNS负载均衡系统解析域名，把对用户响应速度最快的IP节点返回给用户；</li>
<li>4.用户向该IP节点（CDN服务器）发出请求；</li>
<li>5.由于是第一次访问，CDN服务器会向原web站点请求，并缓存内容；</li>
<li>6.请求结果发给用户。</li>
</ul>
]]></content>
      <categories>
        <category>求职</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>redis面试题汇总</title>
    <url>/2020/03/13/redis-mian-shi-ti-hui-zong/</url>
    <content><![CDATA[<h2 id="常见应用"><a href="#常见应用" class="headerlink" title="常见应用"></a>常见应用</h2><p><a href="https://zhuanlan.zhihu.com/p/29665317" target="_blank" rel="noopener">参考连接</a></p>
<p>这一题要结合着Redis特性来回答，首先得明确Redis有哪些特性。</p>
<blockquote>
<p>应用1：读写性能优异可以当作缓存</p>
</blockquote>
<p>缓存是Redis最常见的应用场景。</p>
<p>这里面试官可能会问，Redis和memcached比较以及如何保证缓存一致。</p>
<a id="more"></a>
<p>缓存可能会问到Redis缓存实现方式,主要有两种</p>
<ul>
<li>方案1：读取前会先查询Redis，如果没有命中数据则会去查询数据库比如Mysql，然后拉取数据进Redis</li>
</ul>
<p>可能会存在缓存击穿以及实时性差的问题，那么如何避免缓存击穿呢？</p>
<ul>
<li>方案2：插入数据时同时插入Redis，这种实时性强</li>
</ul>
<p>开发时不便于于统一处理</p>
<p>总结起来就是方案1适合用于对数据实时性要求不高的场合，方案2适合用于数据量不大的场合，如字典表</p>
<blockquote>
<p>丰富的数据类型</p>
</blockquote>
<ul>
<li><p>String：适合最简单Key-value存储，类似于Memcached存储结构，可以存短信验证码、配置信息等</p>
</li>
<li><p>hash：一般key为ID或其他唯一标识，value为详情等</p>
</li>
<li><p>list：list适合存储有序且数据相对固定，如省市区表、字典表等 因为list有序，可以根据输入时间排序 如 最新的*** 消息队列等</p>
</li>
<li><p>set：可以存放一个人的好友，set的交集、并集、差集操作，例如查找共同好友</p>
</li>
<li><p>Sorted Set：是set的增强版本，增加了Score用于排序，可以实现类似Top10而不依赖插入顺序</p>
</li>
</ul>
<blockquote>
<p>自动过期提高开发效率</p>
</blockquote>
<p>如验证码等</p>
<blockquote>
<p>单线程可以作为分布式锁 setnx</p>
</blockquote>
<blockquote>
<p>分布式和持久化有效应对高并发</p>
</blockquote>
<h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><p><a href="https://www.cnblogs.com/jaycekon/p/6227442.html" target="_blank" rel="noopener">参考文章</a></p>
<ul>
<li><p>SDS(Simple Dynamic String)</p>
</li>
<li><p>双端链表</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> * <span class="title">next</span>;</span></span><br><span class="line">      <span class="keyword">void</span> * value;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以直接操作<code>list</code>来操作链表更方便</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    <span class="comment">//表头节点</span></span><br><span class="line">    listNode  * head;</span><br><span class="line">    <span class="comment">//表尾节点</span></span><br><span class="line">    listNode  * tail;</span><br><span class="line">    <span class="comment">//链表长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup) (<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>) (<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>头节点的prev和尾节点的next都指向null</p>
<ul>
<li>字典 由hashtable实现<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">   <span class="comment">//哈希表数组</span></span><br><span class="line">   dictEntry **table;</span><br><span class="line">   <span class="comment">//哈希表大小</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">   <span class="comment">//该哈希表已有节点的数量</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>SDS、字典、跳跃表、链表、压缩列表</strong></p>
<ul>
<li>跳跃表</li>
</ul>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=509777776&idx=1&sn=e56f24bdf2de7e25515fe9f25ef57557&mpshare=1&scene=1&srcid=1010HdkIxon3icsWNmTyecI6#rd" target="_blank" rel="noopener">Redis内部数据结构详解</a></p>
<p><a href="https://juejin.im/post/57fa935b0e3dd90057c50fbc" target="_blank" rel="noopener">skiplist</a></p>
<p><code>sorted list</code>底层用到skiplist，那么为什么不用平衡树呢？</p>
<p>内存占用方面skiplist每个节点平均1.33个指针，而平衡树是2</p>
<p>范围查找实现简单</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261265&idx=1&sn=e105c4b86a5640c5fc8212cd824f750b&scene=21#wechat_redirect" target="_blank" rel="noopener">压缩列表</a></li>
</ul>
<p>因为 ziplist 节约内存的性质， 哈希键、列表键和有序集合键初始化的底层实现皆采用 ziplist</p>
<h2 id="RDB和AOF两种不同方式的比较以及优缺点"><a href="#RDB和AOF两种不同方式的比较以及优缺点" class="headerlink" title="RDB和AOF两种不同方式的比较以及优缺点"></a>RDB和AOF两种不同方式的比较以及优缺点</h2><blockquote>
<p>原理</p>
</blockquote>
<blockquote>
<p>性能</p>
</blockquote>
<blockquote>
<p>稳定性</p>
</blockquote>
<h2 id="跳表和红黑树之间的比较"><a href="#跳表和红黑树之间的比较" class="headerlink" title="跳表和红黑树之间的比较"></a>跳表和红黑树之间的比较</h2><blockquote>
<p>插入效率</p>
</blockquote>
<blockquote>
<p>实现方式</p>
</blockquote>
<blockquote>
<p>内存消耗</p>
</blockquote>
<blockquote>
<p>特殊条件查询</p>
</blockquote>
<h2 id="SDS和原始字符串比较"><a href="#SDS和原始字符串比较" class="headerlink" title="SDS和原始字符串比较"></a>SDS和原始字符串比较</h2><p><a href="https://www.cnblogs.com/jaycekon/p/6227442.html" target="_blank" rel="noopener">参考文章</a></p>
<ul>
<li><p>查询字符串长度</p>
<p>SDS的结构体如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * 保存字符串对象的结构  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span>  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// buf 中已占用空间的长度  </span></span><br><span class="line">    <span class="keyword">int</span> len;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// buf 中剩余可用空间的长度  </span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 数据空间  </span></span><br><span class="line">    <span class="keyword">char</span> buf[];  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>杜绝内存溢出</p>
</li>
<li><p>减少字符串修改带来的内存重分配次数</p>
</li>
<li><p>惰性空间释放：避免缩短字符串带来的内存重分配，也为将来扩展字符串带来优化</p>
</li>
<li><p>二进制安全</p>
</li>
</ul>
<p>不像c字符串那样通过空字符判断字符串结束，而是通过len属性</p>
<h2 id="字典和HashMap的比较"><a href="#字典和HashMap的比较" class="headerlink" title="字典和HashMap的比较"></a>字典和HashMap的比较</h2><p><strong>*扩容方式和扩容大小</strong></p>
<h2 id="单线程的Redis为何快"><a href="#单线程的Redis为何快" class="headerlink" title="单线程的Redis为何快"></a><a href="https://www.iminho.me/wiki/blog-25.html" target="_blank" rel="noopener">单线程的Redis为何快</a></h2><p><a href="https://www.iminho.me/wiki/blog-25.html" target="_blank" rel="noopener">一定要看</a></p>
<h2 id="redis同步机制"><a href="#redis同步机制" class="headerlink" title="redis同步机制"></a>redis同步机制</h2><ul>
<li>全量复制</li>
<li>增量复制</li>
</ul>
<p><a href="https://www.jianshu.com/p/41254dc5cb38" target="_blank" rel="noopener">看</a></p>
<h2 id="给了一个场景，结合redis设计一个天气数据展示接口，前端传给后台一个城市名参数，后台返回相应的天气数据"><a href="#给了一个场景，结合redis设计一个天气数据展示接口，前端传给后台一个城市名参数，后台返回相应的天气数据" class="headerlink" title="给了一个场景，结合redis设计一个天气数据展示接口，前端传给后台一个城市名参数，后台返回相应的天气数据"></a>给了一个场景，结合redis设计一个天气数据展示接口，前端传给后台一个城市名参数，后台返回相应的天气数据</h2>]]></content>
      <categories>
        <category>求职</category>
      </categories>
  </entry>
  <entry>
    <title>Java基础面试题汇总</title>
    <url>/2020/03/13/java-ji-chu-mian-shi-ti-hui-zong/</url>
    <content><![CDATA[<h2 id="PriorityQueue实现原理"><a href="#PriorityQueue实现原理" class="headerlink" title="PriorityQueue实现原理"></a>PriorityQueue实现原理</h2><ul>
<li>数组</li>
<li>扩容</li>
<li>堆排序如何实现？</li>
</ul>
<p><a href="https://blog.csdn.net/u013309870/article/details/71189189" target="_blank" rel="noopener">参考连接</a></p>
<a id="more"></a>

<h2 id="单例模式为什么需要double-check？"><a href="#单例模式为什么需要double-check？" class="headerlink" title="单例模式为什么需要double check？"></a>单例模式为什么需要double check？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingleInstance instance; <span class="comment">//使用volatile禁止命令重排序，防止获得了未被初始化的实例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> SingleInstance <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == instance)&#123;</span><br><span class="line">            <span class="comment">//第一次检查是为了避免每次都加锁，只有当instance==null时才需要加锁</span></span><br><span class="line">            synchronised(SingleInstance.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span> == instance)&#123;</span><br><span class="line">                    <span class="comment">//第二次检查是为了防止多个线程同时请求getInstance只有一个线程进行了实例化对象，其他线程获取锁以后再实例化一个对象</span></span><br><span class="line">                    instance = <span class="keyword">new</span> SingleInsatnce();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么要重写hashCode和equals方法"><a href="#为什么要重写hashCode和equals方法" class="headerlink" title="为什么要重写hashCode和equals方法"></a>为什么要重写hashCode和equals方法</h2><p>如果不重写，则会默认调用Object类的hashCode和equals方法，Object类的hashCode方法是根据对象内存首地址计算得到，equals方法也同样是根据对象内存首地址进行判断。这在很多场景下是不可用的。</p>
<h2 id="hashCode与equals区别"><a href="#hashCode与equals区别" class="headerlink" title="hashCode与equals区别"></a>hashCode与equals区别</h2><ul>
<li>规范1：若重写equals(Object obj)方法，有必要重写hashcode()方法，确保通过equals(Object obj)方法判断结果为true的两个对象具备相等的hashcode()返回值。说得简单点就是：“如果两个对象相同，那么他们的hashcode应该 相等”。不过请注意：这个只是规范，如果你非要写一个类让equals(Object obj)返回true而hashcode()返回两个不相等的值，编译和运行都是不会报错的。不过这样违反了Java规范，程序也就埋下了BUG。 </li>
<li>规范2：如果equals(Object obj)返回false，即两个对象“不相同”，并不要求对这两个对象调用hashcode()方法得到两个不相同的数。说的简单点就是：“如果两个对象不相同，他们的hashcode可能相同”。<br>根据这两个规范，可以得到如下推论： <ul>
<li>1、如果两个对象equals，Java运行时环境会认为他们的hashcode一定相等。 </li>
<li>2、如果两个对象不equals，他们的hashcode有可能相等。 </li>
<li>3、如果两个对象hashcode相等，他们不一定equals。 </li>
<li>4、如果两个对象hashcode不相等，他们一定不equals。 </li>
</ul>
</li>
</ul>
<h2 id="jdk1-8-Map接口实现类的比较"><a href="#jdk1-8-Map接口实现类的比较" class="headerlink" title="jdk1.8 Map接口实现类的比较"></a>jdk1.8 Map接口实现类的比较</h2><p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：</p>
<p><img src="/2020/03/13/java-ji-chu-mian-shi-ti-hui-zong/map.png" alt="Map接口类继承"></p>
<ul>
<li>(1) HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</li>
<li>(2) Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</li>
<li>(3) LinkedHashMap：LinkedHashMap是HashMap的一个子类，使用双向连边，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</li>
<li>(4) TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</li>
</ul>
<p>对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。</p>
<h2 id="HashMap实现原理"><a href="#HashMap实现原理" class="headerlink" title="HashMap实现原理"></a>HashMap实现原理</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。</p>
<p><img src="/2020/03/13/java-ji-chu-mian-shi-ti-hui-zong/hashmapstruct.png" alt="HashMap存储结构"></p>
<blockquote>
<p>HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。</p>
<p><a href="https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/" target="_blank" rel="noopener">https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/</a></p>
<h2 id="集合类-HashMap和HashTable、ConcurrentHashMap-源码比较-重点"><a href="#集合类-HashMap和HashTable、ConcurrentHashMap-源码比较-重点" class="headerlink" title="集合类:HashMap和HashTable、ConcurrentHashMap(源码比较) 重点"></a>集合类:HashMap和HashTable、ConcurrentHashMap(源码比较) <strong>重点</strong></h2><h3 id="HashMap是非线程安全，HashTable和ConcurrentHashMap是线程安全"><a href="#HashMap是非线程安全，HashTable和ConcurrentHashMap是线程安全" class="headerlink" title="HashMap是非线程安全，HashTable和ConcurrentHashMap是线程安全"></a>HashMap是非线程安全，HashTable和ConcurrentHashMap是线程安全</h3><h3 id="HashMap与HashTable比较"><a href="#HashMap与HashTable比较" class="headerlink" title="HashMap与HashTable比较"></a>HashMap与HashTable比较</h3><table>
<thead>
<tr>
<th>不同点</th>
<th>HashMap</th>
<th>HashTable</th>
</tr>
</thead>
<tbody><tr>
<td>实现原理</td>
<td>继承自AbstractMap类</td>
<td>继承自Dictionary(JDK1.0添加)没用过</td>
</tr>
<tr>
<td>初始化容量不同(二者负载因子均为0.75)</td>
<td>初始容量为16</td>
<td>初始容量为11</td>
</tr>
<tr>
<td>扩容机制不同(当前容量大于总容量*负载因子)</td>
<td>总容量翻倍(保持始终为2的幂)</td>
<td>总容量翻倍+1</td>
</tr>
<tr>
<td>迭代器不同</td>
<td>使用Iterator迭代器，是fail-fast的</td>
<td>使用Enumerator，不是fail-fast的</td>
</tr>
</tbody></table>
<h3 id="HashMap底层原理-关键点"><a href="#HashMap底层原理-关键点" class="headerlink" title="HashMap底层原理 关键点"></a>HashMap底层原理 关键点</h3><ul>
<li>JDK1.8引入数组加链表+红黑树</li>
<li>链表长度超过8时转成红黑树</li>
</ul>
<blockquote>
<p>Hashmap中的链表大小超过八个时会自动转化为红黑树，当删除小于六时重新变为链表，为啥呢？</p>
</blockquote>
<p>根据泊松分布，在负载因子默认为0.75的时候，单个hash槽内元素个数为8的概率小于百万分之一，所以将7作为一个分水岭，等于7的时候不转换，大于等于8的时候才进行转换，小于等于6的时候就化为链表。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><ul>
<li>JDK1.7 有segment分段锁</li>
<li>JDK1.8 放弃分段锁<a href="https://cloud.tencent.com/developer/article/1509556" target="_blank" rel="noopener">为何？</a></li>
<li>CAS和synchronied</li>
<li>get和put操作</li>
</ul>
<p><a href="https://mp.weixin.qq.com/s/AixdbEiXf3KfE724kg2YIw" target="_blank" rel="noopener">看这篇屁话</a></p>
<p>JDK1.7和JDK1.8对于二者改动及原因</p>
<h2 id="ArrayList、LinkedList、TreeMap、LinkedHashMap、HashSet"><a href="#ArrayList、LinkedList、TreeMap、LinkedHashMap、HashSet" class="headerlink" title="ArrayList、LinkedList、TreeMap、LinkedHashMap、HashSet"></a>ArrayList、LinkedList、TreeMap、LinkedHashMap、HashSet</h2><p><img src="/2020/03/13/java-ji-chu-mian-shi-ti-hui-zong/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9B%BE.jpg" alt="Java集合框架图"></p>
<p>需要了解底层数据结构和各容器之间的优劣比较</p>
<h2 id="讲一下HashMap的原理，如果链表过长怎么办，如果想让Map按照put的顺序存放键值对应该使用什么类？"><a href="#讲一下HashMap的原理，如果链表过长怎么办，如果想让Map按照put的顺序存放键值对应该使用什么类？" class="headerlink" title="讲一下HashMap的原理，如果链表过长怎么办，如果想让Map按照put的顺序存放键值对应该使用什么类？"></a>讲一下HashMap的原理，如果链表过长怎么办，如果想让Map按照put的顺序存放键值对应该使用什么类？</h2><p>HashMap在存在hash冲突的情况下，会使用链表或红黑树存储hash冲突的key，一般当链表长度超过<code>TREEIFY_THRESHOLD</code>会将链表转成红黑树。</p>
<p>Map按照元素大小排序用TreeMap</p>
<p>Map按照元素put顺序用LinkedHashMap</p>
<h2 id="Session与Cookie区别"><a href="#Session与Cookie区别" class="headerlink" title="Session与Cookie区别"></a>Session与Cookie区别</h2><p>session是存储在服务器端,cookie是存储在客户端的,所以安全来讲session的安全性要比cookie高,然后我们获取session里的信息是通过存放在<strong>会话cookie</strong>里的sessionid获取的。又由于session是存放在服务器的内存中,所以session里的东西不断增加会造成服务器的负担,所以会把很重要的信息存储在session中,而把一些次要东西存储在客户端的cookie里。</p>
<p>cookie确切的说分为两大类分为<strong>会话cookie和持久化cookie</strong>,会话cookie确切的说是存放在客户端浏览器的内存中,所以说他的生命周期和浏览器是一致的,浏览器关了会话cookie也就消失了,然而持久化cookie是存放在客户端硬盘中,而持久化cookie的生命周期就是我们在设置cookie时候设置的那个保存时间,然后我们考虑一问题当浏览器关闭时session会不会丢失,从上面叙述分析session的信息是通过sessionid获取的,而sessionid是存放在会话cookie当中的,当浏览器关闭的时候会话cookie消失所以我们的sessionid也就消失了,但是session的信息还存在服务器端,这时我们只是查不到所谓的session但它并不是不存在。那么,session在什么情况下丢失,就是在服务器关闭的时候,或者是sessio过期,再或者调用了invalidate()的或者是我们想要session中的某一条数据消失调用session.removeAttribute()方法,然后session在什么时候被创建呢,确切的说是通过调用session.getsession来创建,这就是session与cookie的区别。</p>
<blockquote>
<p>Session的生命周期</p>
</blockquote>
<ul>
<li>Session何时生效</li>
</ul>
<p>Session在用户第一次访问服务器时创建，注意只有访问JSP、Servlet等程序时才会创建Session，而访问HTML、image等静态文件时不会产生Session,可调用request.getSession(true)强制生成Session。</p>
<ul>
<li>Session何时失效<ul>
<li>服务器会把长时间没有活动的Session从服务器内存中清除，此时Session便失效。Tomcat中Session的默认失效时间为20分钟。</li>
<li>调用Session的invalidate方法。<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br><span class="line">session.invalidate();<span class="comment">//注销该request的所有session</span></span><br></pre></td></tr></table></figure></code></pre></li>
<li>session的过期时间是从什么时候开始计算的？是从一登录就开始计算还是说从停止活动开始计算？<br>从session不活动的时候开始计算，如果session一直活动，session就总不会过期。从该Session未被访问,开始计时; 一旦Session被访问,计时清0;</li>
</ul>
</li>
</ul>
<h2 id="JDK1-8新特性"><a href="#JDK1-8新特性" class="headerlink" title="JDK1.8新特性"></a>JDK1.8新特性</h2><p><a href="https://www.jianshu.com/p/5b800057f2d8" target="_blank" rel="noopener">参考文章</a></p>
<h3 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h3><ul>
<li>Lambda表达式和函数式接口</li>
<li>接口的默认方法和静态方法</li>
<li>方法引用</li>
<li>重复注解<code>@Repeatable</code></li>
<li>更好的类型推断</li>
<li>拓宽注解的应用场景</li>
</ul>
<h3 id="编译器特性"><a href="#编译器特性" class="headerlink" title="编译器特性"></a>编译器特性</h3><ul>
<li>参数名称</li>
</ul>
<h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><ul>
<li>Optional</li>
<li>Streams</li>
<li>Date/Time API</li>
<li>Nashorn JavaScript引擎</li>
<li>Base64</li>
<li>并行数组</li>
<li>并发性</li>
</ul>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul>
<li>Nashorn引擎：jjs</li>
<li>类依赖分析器：jdeps</li>
</ul>
<h3 id="运行时-JVM"><a href="#运行时-JVM" class="headerlink" title="运行时(JVM)"></a>运行时(JVM)</h3><p>使用Metaspace（JEP 122）代替持久代（PermGen space）。在JVM参数方面，使用-XX:MetaSpaceSize和-XX:MaxMetaspaceSize代替原来的-XX:PermSize和-XX:MaxPermSize。</p>
<h2 id="NIO原理"><a href="#NIO原理" class="headerlink" title="NIO原理"></a>NIO原理</h2><h3 id="NIO与传统IO比较"><a href="#NIO与传统IO比较" class="headerlink" title="NIO与传统IO比较"></a>NIO与传统IO比较</h3><ul>
<li>面向缓冲和面向流</li>
<li>非阻塞与阻塞</li>
<li>选择器(单线程管理多个通道)</li>
</ul>
<h3 id="NIO与IO适用场景不同"><a href="#NIO与IO适用场景不同" class="headerlink" title="NIO与IO适用场景不同"></a>NIO与IO适用场景不同</h3><p>由于NIO是面向缓冲的这导致数据处理前都需要处理缓冲区中数据是否完整或者读取完毕。</p>
<p>NIO适用于连接数大，但每次只传送极少数的数据，如聊天服务器</p>
<p>IO适合于连接数少，但需要传输大量数据</p>
<h2 id="NIO原理-1"><a href="#NIO原理-1" class="headerlink" title="NIO原理"></a>NIO原理</h2><p>NIO核心 buffer channal selector</p>
<p><strong>小小tips：</strong></p>
<ul>
<li>同步与异步：同步是指用户空间是主动发起IO请求的一方，内核空间被动接受，而异步相反，用户空间线程向内核空间注册各种回调函数，由内核空间调用</li>
<li>阻塞与非阻塞</li>
</ul>
<p><strong>四种IO模型</strong></p>
<p><a href="https://www.cnblogs.com/crazymakercircle/p/10225159.html#%E5%9B%9B%E7%A7%8D%E4%B8%BB%E8%A6%81%E7%9A%84io%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">参考文章</a></p>
<ul>
<li>同步阻塞(IO)</li>
<li>同步非阻塞(NIO)</li>
<li>多路复用  IO多路复用模型，就是通过一种新的系统调用，一个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是内核缓冲区可读/可写），内核kernel能够通知程序进行相应的IO系统调用。</li>
<li>异步IO模型</li>
</ul>
<h2 id="Java序列化"><a href="#Java序列化" class="headerlink" title="Java序列化"></a>Java序列化</h2><h2 id="数组内存分配"><a href="#数组内存分配" class="headerlink" title="数组内存分配"></a>数组内存分配</h2><p><a href="https://blog.csdn.net/pange1991/article/details/80898344" target="_blank" rel="noopener">参考文档</a></p>
<p><strong>对于64位操作系统，引用类型指针压缩前8字节，压缩后斩4字节</strong></p>
<ul>
<li>指针压缩前：数组对象的对象头占用24个字节（8字节MarkWord+8字节类型指针+8字节数组长度）</li>
<li>指针压缩后：启用压缩之后占用16个字节（8字节MarkWord+4字节类型指针+4字节数组长度）</li>
</ul>
<p>拿new Integer[3]来具体解释下：</p>
<ul>
<li>未开启压缩：24（对象头）+ 8*3 = 48，不需要padding；</li>
<li>开启压缩：16（对象头）+ 4*3 = 28，需要对齐填充 28 + 4(padding) = 32，其他依次类推。</li>
</ul>
]]></content>
      <categories>
        <category>求职</category>
      </categories>
  </entry>
  <entry>
    <title>面试问题汇总</title>
    <url>/2020/02/27/mian-shi-wen-ti-hui-zong/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/read/cv4150256/" target="_blank" rel="noopener">https://www.bilibili.com/read/cv4150256/</a></p>
<p><a href="https://www.processon.com/view/link/5db53025e4b0893e9a654cda#map" target="_blank" rel="noopener">学习大纲</a></p>
<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a><a href="http://njustwh2014.github.io/2020/03/13/java-ji-chu-mian-shi-ti-hui-zong/">Java基础</a></h2><h2 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a><a href="http://njustwh2014.github.io/2020/03/16/bing-fa-bian-cheng-mian-shi-zong-jie/">Java并发</a></h2><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a><a href="http://njustwh2014.github.io/2020/03/16/jvm-mian-shi-zong-jie/">JVM</a></h2><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a><a href="http://njustwh2014.github.io/2020/03/16/spring-mian-shi-zong-jie/">Spring</a></h2><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a><a href="hhttp://njustwh2014.github.io/2020/03/13/redis-mian-shi-ti-hui-zong/">redis</a></h2><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a><a href="http://njustwh2014.github.io/2020/03/13/wang-luo-xie-yi-mian-shi-ti-hui-zong/">网络协议</a></h2><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a><a href="http://njustwh2014.github.io/2020/03/13/mysql-mian-shi-hui-zong/">Mysql</a></h2><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><a href="http://njustwh2014.github.io/2020/03/13/she-ji-mo-shi-ti-hui-zong/">设计模式</a></h2><h2 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a><a href="http://njustwh2014.github.io/2020/03/17/suan-fa-yu-shu-ju-jie-gou-mian-shi-ti-hui-zong/">算法与数据结构</a></h2><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a><a href="http://njustwh2014.github.io/2020/03/16/docker-mian-shi-zong-jie/">Docker</a></h2><a id="more"></a>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="merge和rebase区别"><a href="#merge和rebase区别" class="headerlink" title="merge和rebase区别"></a>merge和rebase区别</h3><p>最开始实习的时候是使用svn，之后正式工作就一直在使用git，这样算起来，使用git也有两年的时间了。以前带我的同事，让我在拉代码的时候要我使用git pull –rebase，一直很纳闷为什么要那样做，后来遇到拉代码的时候有许多冲突要解决，然后去查找资料，才了解到其中的一些事情。今天分享一下，顺便自己也梳理一下。</p>
<h4 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h4><p>git pull 是　git fetch + git merge FETCH_HEAD 的缩写。所以，默认情况下，git pull就是先fetch，然后执行merge 操作，如果加–rebase 参数，就是使用git rebase 代替git merge。</p>
<h4 id="merge-和-rebase"><a href="#merge-和-rebase" class="headerlink" title="merge 和 rebase"></a>merge 和 rebase</h4><p>merge 是合并的意思，rebase是复位基底的意思。</p>
<p>现在我们有这样的两个分支,test和master，提交如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      D---E test</span><br><span class="line">     /</span><br><span class="line">A---B---C---F master</span><br></pre></td></tr></table></figure>

<p>在master执行git merge test,然后会得到如下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      D--------E</span><br><span class="line">     /          \</span><br><span class="line">A---B---C---F----G   test, master</span><br></pre></td></tr></table></figure>
<p>在master执行git rebase test，然后得到如下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A---B---D---E---C&apos;---F&apos; test, master</span><br></pre></td></tr></table></figure>

<p>可以看到，merge操作会生成一个新的节点，之前的提交分开显示。而rebase操作不会生成新的节点，是将两个分支融合成一个线性的提交。</p>
<h4 id="其他内容放这里"><a href="#其他内容放这里" class="headerlink" title="其他内容放这里"></a>其他内容放这里</h4><p>通过上面可以看到，想要更好的提交树，使用rebase操作会更好一点。这样可以线性的看到每一次提交，并且没有增加提交节点。</p>
<p>在我们操作过程中。merge 操作遇到冲突的时候，当前merge不能继续进行下去。手动修改冲突内容后，add 修改，commit 就可以了。</p>
<p>而rebase 操作的话，会中断rebase,同时会提示去解决冲突。解决冲突后,将修改add后执行git rebase –continue继续操作，或者git rebase –skip忽略冲突。</p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="linux熟悉吗"><a href="#linux熟悉吗" class="headerlink" title="linux熟悉吗"></a>linux熟悉吗</h3><p><a href="https://www.cnblogs.com/yzh-blog/p/11670289.html" target="_blank" rel="noopener">qnmd不熟</a></p>
<h2 id="dubbo面试题"><a href="#dubbo面试题" class="headerlink" title="dubbo面试题"></a>dubbo面试题</h2><p><a href="https://youzhixueyuan.com/dubbo-interview-question-answers.html" target="_blank" rel="noopener"><strong>参考连接</strong></a></p>
<h2 id="Rabbitmq面试题"><a href="#Rabbitmq面试题" class="headerlink" title="Rabbitmq面试题"></a>Rabbitmq面试题</h2><p><a href="https://juejin.im/" target="_blank" rel="noopener">面试问题</a></p>
<h2 id="系统设计与优化-综合性问题"><a href="#系统设计与优化-综合性问题" class="headerlink" title="系统设计与优化(综合性问题)"></a>系统设计与优化(综合性问题)</h2><h3 id="秒杀系统设计"><a href="#秒杀系统设计" class="headerlink" title="秒杀系统设计"></a>秒杀系统设计</h3><h3 id="博客网站的压力测试方法"><a href="#博客网站的压力测试方法" class="headerlink" title="博客网站的压力测试方法"></a>博客网站的压力测试方法</h3><p>找到系统性能瓶颈：</p>
<ul>
<li>应用服务器</li>
<li>数据库IO</li>
<li>建立连接</li>
<li>Java代码</li>
</ul>
<h3 id="有几次请求响应慢的原因以及解决办法"><a href="#有几次请求响应慢的原因以及解决办法" class="headerlink" title="有几次请求响应慢的原因以及解决办法"></a>有几次请求响应慢的原因以及解决办法</h3><ul>
<li>查看CPU占用、内存、IO占用情况</li>
<li>JVM参数设置是否合理</li>
<li>数据链路问题，DNS解析速度，内网广播风暴，是否跨运营商等</li>
<li>程序设计是否合理</li>
<li>检查数据库访问速度</li>
<li>是否被攻击</li>
<li>硬件故障</li>
</ul>
<h3 id="Elasticsearch倒排索引"><a href="#Elasticsearch倒排索引" class="headerlink" title="Elasticsearch倒排索引"></a>Elasticsearch倒排索引</h3><p>倒排索引是一种索引方法，被用来存储全文搜索下每个单词在一个或一组文章中的位置，是文档检索系统中常用的数据结构。</p>
<ul>
<li><p>T0=”it is what it is”</p>
</li>
<li><p>T1=”what is it”</p>
</li>
<li><p>T2=”it is a banana”</p>
</li>
<li><p>反向文件索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;a&quot;:      &#123;2&#125;</span><br><span class="line">&quot;banana&quot;: &#123;2&#125;</span><br><span class="line">&quot;is&quot;:     &#123;0, 1, 2&#125;</span><br><span class="line">&quot;it&quot;:     &#123;0, 1, 2&#125;</span><br><span class="line">&quot;what&quot;:   &#123;0, 1&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>完全反向索引</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;a&quot;:      &#123;(2, 2)&#125;</span><br><span class="line">&quot;banana&quot;: &#123;(2, 3)&#125;</span><br><span class="line">&quot;is&quot;:     &#123;(0, 1), (0, 4), (1, 1), (2, 1)&#125;</span><br><span class="line">&quot;it&quot;:     &#123;(0, 0), (0, 3), (1, 2), (2, 0)&#125; </span><br><span class="line">&quot;what&quot;:   &#123;(0, 2), (1, 0)&#125;</span><br></pre></td></tr></table></figure>


<h3 id="nginx反向代理是什么，为什么需要nginx反向代理"><a href="#nginx反向代理是什么，为什么需要nginx反向代理" class="headerlink" title="nginx反向代理是什么，为什么需要nginx反向代理"></a>nginx反向代理是什么，为什么需要nginx反向代理</h3><blockquote>
<p>反向代理</p>
</blockquote>
<p>反向代理是指以代理服务器来接收网络请求，并转发给内部网络上服务器，并将服务器处理结果返回给请求端。此时，代理服务器对外表现为一个服务器。</p>
<p>正向代理是指，由于一些网络配置导致无法直接访问某个目标服务器，使用中间服务器代为转发请求。客户端向代理服务器发送请求，并指定目标服务器，代理服务器向目标服务器请求后，并将请求结果返回给客户端。（如翻墙）</p>
<blockquote>
<p>为什么需要反向代理</p>
</blockquote>
<ul>
<li>可以起到保护网络安全作用，任何访问请求都必须经过代理服务器。</li>
<li>缓存静态资源，加速web访问</li>
<li>实现负载均衡</li>
</ul>
<h3 id="tomcat相关原理"><a href="#tomcat相关原理" class="headerlink" title="tomcat相关原理"></a>tomcat相关原理</h3><h3 id="mysql的sql处理过程"><a href="#mysql的sql处理过程" class="headerlink" title="mysql的sql处理过程"></a>mysql的sql处理过程</h3><h3 id="dubbo的原理"><a href="#dubbo的原理" class="headerlink" title="dubbo的原理"></a>dubbo的原理</h3><h3 id="dubbo序列化协议"><a href="#dubbo序列化协议" class="headerlink" title="dubbo序列化协议"></a>dubbo序列化协议</h3><h3 id="dubbo负载均衡策略"><a href="#dubbo负载均衡策略" class="headerlink" title="dubbo负载均衡策略"></a>dubbo负载均衡策略</h3><h3 id="dubbo-spi机制实现"><a href="#dubbo-spi机制实现" class="headerlink" title="dubbo spi机制实现"></a>dubbo spi机制实现</h3><h3 id="nacos原理"><a href="#nacos原理" class="headerlink" title="nacos原理"></a>nacos原理</h3><h3 id="Tomcat与Nginx、Apache-HTTP-Server"><a href="#Tomcat与Nginx、Apache-HTTP-Server" class="headerlink" title="Tomcat与Nginx、Apache HTTP Server"></a>Tomcat与Nginx、Apache HTTP Server</h3><ul>
<li>Tomcat支持Servlet和JSP(Java Server Page),与Apache HTTP Server相比，Tomcat能够动态的生成资源并返回到客户端。</li>
<li>通常使用Nginx将静态资源与动态资源分离，当请求静态资源时则转发给Nginx Web服务器，返回静态资源，当请求动态资源时，则转发请求给后续的Tomcat服务器</li>
<li>当业务压力增大时，一个Tomcat实例不足以处理业务请求时，需要对Tomcat进行水平扩展，这个时候可以利用Nginx负载均衡算法，分发请求给不同的Tomcat实例</li>
</ul>
<h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2>]]></content>
      <categories>
        <category>求职</category>
      </categories>
  </entry>
  <entry>
    <title>2020一定要拿到offer呀</title>
    <url>/2020/02/02/2020-yi-ding-yao-na-dao-offer-a/</url>
    <content><![CDATA[<h1 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h1><blockquote>
<p>将之前博客系统重启</p>
</blockquote>
<ul>
<li><p>redis、mysql部署在130虚拟机</p>
</li>
<li><p>前端部署在129机器上(nginx代理)</p>
</li>
<li><p>后端部署在131虚拟机</p>
</li>
</ul>
<blockquote>
<p>leetcode刷题</p>
</blockquote>
<a id="more"></a>

<h2 id="网站重新部署和优化工作"><a href="#网站重新部署和优化工作" class="headerlink" title="网站重新部署和优化工作"></a>网站重新部署和优化工作</h2><blockquote>
<p><a href="https://www.jianshu.com/p/2217cfed29d7" target="_blank" rel="noopener">docker-compose.yml详解</a></p>
</blockquote>
<blockquote>
<p><a href="https://juejin.im/post/5c3363bf6fb9a049e2322cdb" target="_blank" rel="noopener">docker网络模式</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/javabg/p/7976977.html" target="_blank" rel="noopener">servlet+idea环境配置参考</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/starof/p/4680083.html" target="_blank" rel="noopener">centos上安装mysql</a> </p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/zuidongfeng/p/8859229.html" target="_blank" rel="noopener">centos上部署springboot项目</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/chen3888015/article/details/70172505/" target="_blank" rel="noopener">centos上配置fdfs</a></p>
</blockquote>
<blockquote>
<p><a href="http://www.ityouknow.com/springboot/2018/01/16/spring-boot-fastdfs.html" target="_blank" rel="noopener">微笑大神： 使用fdfs</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/qq_34301871/article/details/80060235" target="_blank" rel="noopener">HTTP请求不能访问文件的原因</a></p>
</blockquote>
<blockquote>
<p><a href>出现缺少fastcommon.h修改办法</a> <a href="https://blog.csdn.net/babydavic/article/details/21240021" target="_blank" rel="noopener">https://blog.csdn.net/babydavic/article/details/21240021</a>)</p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/qq_36922927/article/details/79554806" target="_blank" rel="noopener">nginx安装</a></p>
</blockquote>
<h3 id="redis安装部署备忘"><a href="#redis安装部署备忘" class="headerlink" title="redis安装部署备忘"></a>redis安装部署备忘</h3><p>redis安装在130机器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行服务</span></span><br><span class="line">docker run -it --name redis -v /root/wanghuan/docker/redis/cfg/redis.conf:/usr/<span class="built_in">local</span>/etc/redis/redis.conf -v /root/wanghuan/docker/redis/data:/data -d -p 6379:6379 redis:latest /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it redis bash</span><br><span class="line"><span class="comment"># 加载配置</span></span><br><span class="line">redis-server /usr/<span class="built_in">local</span>/etc/redis/redis.conf</span><br><span class="line"><span class="comment"># 测试连接</span></span><br><span class="line">redis-cli -a wanghuan</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips: redis desktop manager for free: <a href="https://github.com/qishibo/AnotherRedisDesktopManager/" target="_blank" rel="noopener">https://github.com/qishibo/AnotherRedisDesktopManager/</a></p>
</blockquote>
<h3 id="mysql安装部署备忘"><a href="#mysql安装部署备忘" class="headerlink" title="mysql安装部署备忘"></a>mysql安装部署备忘</h3><p>mysql安装在130机器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pull image</span></span><br><span class="line">docker pull mysql:latest</span><br><span class="line"><span class="comment"># run</span></span><br><span class="line">docker run --name mysql-mstc -v /root/wanghuan/docker/mysql/data:/data -e MYSQL_ROOT_PASSWORD=123456 -d -i -p 3306:3306 --restart=always  mysql:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出sql文件</span></span><br><span class="line">mysqldump -u root -p seumstc &gt; F:/seumstc.sql</span><br><span class="line"><span class="comment"># docker容器内导入sql文件</span></span><br><span class="line"><span class="comment"># 进入docker容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql-mstc bash</span><br><span class="line"><span class="comment"># 连接mysql</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"><span class="comment"># 新建数据库</span></span><br><span class="line">create database seumstc;</span><br><span class="line">use seumstc;</span><br><span class="line"><span class="comment"># 导入sql文件</span></span><br><span class="line"><span class="built_in">source</span> /data/seumstc.sql;</span><br></pre></td></tr></table></figure>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><blockquote>
<p><code>new Integer(123)</code> 与 <code>Integer.valueOf(123)</code> 的区别在于</p>
</blockquote>
<p><a href="https://stackoverflow.com/questions/9030817/differences-between-new-integer123-integer-valueof123-and-just-123" target="_blank" rel="noopener">参考</a></p>
<blockquote>
<p>红黑树与平衡二叉树的区别</p>
</blockquote>
<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">子字符串匹配kmp算法</a> </p>
</blockquote>
<p><a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="noopener">leetcode 28</a></p>
<p><a href="https://www.zhihu.com/question/21923021" target="_blank" rel="noopener">参考知乎实现</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: kmp算法查找子字符串在字符串中匹配的位置 leetcode 28https://leetcode.com/problems/implement-strstr/</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Param</span>: [haystack, needle]</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>: int</span></span><br><span class="line"><span class="comment">* <span class="doctag">@thorws</span>:</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: Mr.Wang</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Date</span>: 2020/2/5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(needle==<span class="keyword">null</span>||needle.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(haystack==<span class="keyword">null</span>||haystack.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] maxLengthTable=maxLocalMatchLength(needle);</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;haystack.length();i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(count&gt;<span class="number">0</span>&amp;&amp;needle.charAt(count)!=haystack.charAt(i))&#123;</span><br><span class="line">            count=maxLengthTable[count-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(needle.charAt(count)==haystack.charAt(i))&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count==needle.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> i-count+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] maxLocalMatchLength(String pattern)&#123;</span><br><span class="line">    <span class="keyword">if</span>(pattern==<span class="keyword">null</span>||pattern.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] maxLengthTable=<span class="keyword">new</span> <span class="keyword">int</span>[pattern.length()];</span><br><span class="line">    <span class="keyword">int</span> maxLength=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;maxLengthTable.length;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(maxLength&gt;<span class="number">0</span>&amp;&amp;pattern.charAt(maxLength)!=pattern.charAt(i))&#123;</span><br><span class="line">            maxLength=maxLengthTable[maxLength-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pattern.charAt(maxLength)==pattern.charAt(i))&#123;</span><br><span class="line">            maxLength++;</span><br><span class="line">        &#125;</span><br><span class="line">        maxLengthTable[i]=maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLengthTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>list与set的区别</p>
</blockquote>
<p>list与set均继承自Collections接口。</p>
<p><strong>list：</strong> 有序，可重复，可动态扩展，查找效率高，但插入删除效率低，支持for循环和迭代器。</p>
<p><strong>set：</strong> 无序，不重复，位置固定，由hashcode决定，加入set的object必须实现equals方法，插入删除效率高，检索效率低下，插入删除不会改变其他元素位置。set只能使用迭代器。</p>
<blockquote>
<p>HashSet如何保证元素不重复</p>
</blockquote>
<p>HashSet使用add()方法时调用HashMap的add()方法。判断元素是否存在时除了使用hashcode还需要调用equals()方法。HashMap的key是唯一，HashSet加入的Object作为HashMap的key。</p>
<p>以下是HashSet的部分源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT=<span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e,PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>HashMap线程不安全</p>
</blockquote>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="1-JVM上堆和栈的比较"><a href="#1-JVM上堆和栈的比较" class="headerlink" title="1. JVM上堆和栈的比较"></a>1. JVM上堆和栈的比较</h3><p><a href="https://iamjohnnyzhuang.github.io/java/2016/07/12/Java%E5%A0%86%E5%92%8C%E6%A0%88%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F.html" target="_blank" rel="noopener">参考文章</a></p>
<h3 id="2-JVM运行时数据区域"><a href="#2-JVM运行时数据区域" class="headerlink" title="2. JVM运行时数据区域"></a>2. JVM运行时数据区域</h3><blockquote>
<p>栈区：栈区需要内存连续</p>
</blockquote>
<ul>
<li><p>程序计数器：记录正在执行的虚拟机字节码指令地址(如果是本地方法则为空)</p>
</li>
<li><p>Java虚拟机栈：每一个Java方法在执行的同时会创建一个栈帧用于存放<strong>局部变量表、操作数栈、常量池引用</strong>等信息，方法的调用直至执行完成对应着栈帧入栈和出栈过程。</p>
<ul>
<li><p>可以通过<code>-Xss</code>这个参数来描述Java虚拟机栈的内存大小，JDK1.4默认256k，而JDK1.5+默认为1M</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -Xss2M HackTheJava</span><br></pre></td></tr></table></figure>
</li>
<li><p>该区域可能抛出如下异常：</p>
<ul>
<li><p>线程请求的栈深度超过最大值，抛出<code>StackOverflowError</code></p>
</li>
<li><p>栈进行动态扩展时无法申请到足够内存时，抛出<code>OutOfMemoryError</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>本地方法栈：本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。</li>
</ul>
<p>本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</p>
<blockquote>
<p>堆区：堆区不需要连续的内存，可动态增加内存，增加内存失败会抛出<code>OutOfMemoryError</code></p>
</blockquote>
<p>所有的对象都在堆区分配内存，是垃圾收集的主要区域(GC堆)</p>
<p>现在的垃圾收集器都采用分代收集算法，其主要思想采用不同类型的对象采用不同的垃圾收集算法，可以将堆分成两块：</p>
<pre><code>+ 新生代

+ 老年代</code></pre><p>可以通过 <code>-Xms</code> 和 <code>-Xmx</code> 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -Xms1M -Xmx2M HackTheJava</span><br></pre></td></tr></table></figure>

<blockquote>
<p>方法区</p>
</blockquote>
<p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>和<strong>堆一样不需要连续的内存</strong>，并且可以动态扩展，动态扩展失败一样会抛出 <code>OutOfMemoryError</code> 异常。</p>
<p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</p>
<p>HotSpot虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出<code>OutOfMemoryError</code>异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间(metaspace)，它位于本地内存中，而不是虚拟机内存中。</p>
<p>方法区是一个JVM规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。</p>
<ul>
<li><p>运行时常量池</p>
<p><strong>运行时常量池是方法区的一部分</strong>。</p>
<p>Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。</p>
<p>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。</p>
</li>
</ul>
<blockquote>
<p>直接内存</p>
</blockquote>
<p>在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。</p>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="1-从输入URL到页面加载的详细过程"><a href="#1-从输入URL到页面加载的详细过程" class="headerlink" title="1. 从输入URL到页面加载的详细过程"></a>1. 从输入URL到页面加载的详细过程</h3><p><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">参考文章</a></p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="1-Redis是单线程吗？为什么Redis如此之快？"><a href="#1-Redis是单线程吗？为什么Redis如此之快？" class="headerlink" title="1. Redis是单线程吗？为什么Redis如此之快？"></a>1. Redis是单线程吗？为什么Redis如此之快？</h3><p>redis单线程指的是网络请求模块使用了一个线程，即一个线程处理所有网络请求，其他模块仍用了多个线程。</p>
<p>因为CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽，既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p>
<blockquote>
<p>redis为什么如此之快？</p>
</blockquote>
<ul>
<li><p>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p>
</li>
<li><p>数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p>
</li>
<li><p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p>
</li>
<li><p>使用多路I/O复用模型，非阻塞IO；<a href="https://draveness.me/redis-io-multiplexing" target="_blank" rel="noopener">参考</a></p>
</li>
<li><p>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p>
</li>
</ul>
<blockquote>
<p>多路I/O复用模型，非阻塞IO</p>
</blockquote>
<p>下面举一个例子，模拟一个tcp服务器处理30个客户socket。<br>假设你是一个监考老师，让30个学生解答一道竞赛考题，然后负责验收学生答卷，你有下面几个选择：</p>
<p>第一种选择：按顺序逐个验收，先验收A，然后是B，之后是C、D。。。这中间如果有一个学生卡住，全班都会被耽误。<br>这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。</p>
<p>第二种选择：你创建30个分身，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者线程处理连接。</p>
<p>第三种选择，你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。。。</p>
<p>这种就是IO复用模型，Linux下的select、poll和epoll就是干这个的。将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。此时的socket应该采用非阻塞模式。</p>
<p>这样，整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的reactor模式。</p>
<blockquote>
<p>针对上面距离，在redis中表现为：</p>
</blockquote>
<p>有30个redis客户端（考生）与redis服务器的网络连接模块（监考老师）保持TCP连接，客户端会不定时的发送请求给服务器，当有一个redis客户端发起请求，会触发unix系统像epoll这样的系统调用，Redis的I/O 多路复用模块封装了底层的epoll这样的 I/O 多路复用函数，然后转发到相应的事件处理器。</p>
<p>文件事件处理器使用 I/O 多路复用模块同时监听多个 FD（文件描述符），当 accept、read、write 和 close 文件事件产生时，文件事件处理器就会回调 FD 绑定的事件处理器。</p>
<p>虽然整个文件事件处理器是在单线程上运行的，但是通过 I/O 多路复用模块的引入，实现了同时对多个 FD 读写的监控，提高了网络通信模型的性能，同时也可以保证整个 Redis 服务实现的简单。</p>
<h3 id="2-redis可能出现的问题："><a href="#2-redis可能出现的问题：" class="headerlink" title="2. redis可能出现的问题："></a>2. redis可能出现的问题：</h3><ul>
<li><p>缓存雪崩</p>
</li>
<li><p>缓存穿透</p>
</li>
<li><p>数据库和缓存双写一致性问题</p>
</li>
</ul>
<h3 id="3-Redis持久化方式有哪些？并比较"><a href="#3-Redis持久化方式有哪些？并比较" class="headerlink" title="3. Redis持久化方式有哪些？并比较"></a>3. Redis持久化方式有哪些？并比较</h3><h3 id="4-Redis过期回收策略和内存淘汰机制"><a href="#4-Redis过期回收策略和内存淘汰机制" class="headerlink" title="4.Redis过期回收策略和内存淘汰机制"></a>4.Redis过期回收策略和内存淘汰机制</h3><h3 id="5-redis主从复制机制"><a href="#5-redis主从复制机制" class="headerlink" title="5.redis主从复制机制"></a>5.redis主从复制机制</h3><blockquote>
<p>分布式系统的CAP理论</p>
</blockquote>
<h3 id="6-redis对事务的支持"><a href="#6-redis对事务的支持" class="headerlink" title="6.redis对事务的支持"></a>6.redis对事务的支持</h3><h3 id="7-redis的哨兵模式"><a href="#7-redis的哨兵模式" class="headerlink" title="7.redis的哨兵模式"></a>7.redis的哨兵模式</h3><h3 id="8-redis实现分布式锁"><a href="#8-redis实现分布式锁" class="headerlink" title="8.redis实现分布式锁"></a>8.redis实现分布式锁</h3><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><h3 id="1-fast-forward"><a href="#1-fast-forward" class="headerlink" title="1. fast-forward"></a>1. fast-forward</h3><h3 id="2-merge与rebase区别"><a href="#2-merge与rebase区别" class="headerlink" title="2. merge与rebase区别"></a>2. merge与rebase区别</h3>]]></content>
      <categories>
        <category>求职</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Redis</tag>
        <tag>Mysql</tag>
        <tag>Vue</tag>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>并发容器之ConcurrentLinkedQueue</title>
    <url>/2019/12/08/bing-fa-rong-qi-zhi-concurrentlinkedqueue/</url>
    <content><![CDATA[<h2 id="1-ConcurrentLinkedQueue简介"><a href="#1-ConcurrentLinkedQueue简介" class="headerlink" title="1.ConcurrentLinkedQueue简介"></a>1.ConcurrentLinkedQueue简介</h2><p>在单线程编程中我们会经常用到一些集合类，比如ArrayList,HashMap等，但是这些类都不是线程安全的类。在面试中也经常会有一些考点，比如ArrayList不是线程安全的，Vector是线程安全。而保障Vector线程安全的方式，是非常粗暴的在方法上用synchronized独占锁，将多线程执行变成串行化。要想将ArrayList变成线程安全的也可以使用<code>Collections.synchronizedList(List&lt;T&gt; list)</code>方法ArrayList转换成线程安全的，但这种转换方式依然是通过synchronized修饰方法实现的，很显然这不是一种高效的方式，同时，队列也是我们常用的一种数据结构，为了解决线程安全的问题，Doug Lea大师为我们准备了ConcurrentLinkedQueue这个线程安全的队列。从类名就可以看的出来实现队列的数据结构是链式。</p>
<a id="more"></a>
<h3 id="1-1-Node"><a href="#1-1-Node" class="headerlink" title="1.1 Node"></a>1.1 Node</h3><p>要想先学习ConcurrentLinkedQueue自然而然得先从它的节点类看起，明白它的底层数据结构。Node类的源码为：</p>
<pre><code>private static class Node&lt;E&gt; {
        volatile E item;
        volatile Node&lt;E&gt; next;
        .......
}</code></pre><p>Node节点主要包含了两个域：一个是数据域item，另一个是next指针，用于指向下一个节点从而构成链式队列。并且都是用volatile进行修饰的，以保证内存可见性（关于volatile<a href="https://juejin.im/post/5ae9b41b518825670b33e6c4" target="_blank" rel="noopener">可以看这篇文章</a>）。另外ConcurrentLinkedQueue含有这样两个成员变量：</p>
<pre><code>private transient volatile Node&lt;E&gt; head;
private transient volatile Node&lt;E&gt; tail;</code></pre><p>说明ConcurrentLinkedQueue通过持有头尾指针进行管理队列。当我们调用无参构造器时，其源码为：</p>
<pre><code>public ConcurrentLinkedQueue() {
    head = tail = new Node&lt;E&gt;(null);
}</code></pre><p>head和tail指针会指向一个item域为null的节点,此时ConcurrentLinkedQueue状态如下图所示：</p>
<p>如图，head和tail指向同一个节点Node0，该节点item域为null,next域为null。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2615789-a3dbf8f54bb3452e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.ConcurrentLinkedQueue初始化状态.png"></p>
<h2 id="1-2-操作Node的几个CAS操作"><a href="#1-2-操作Node的几个CAS操作" class="headerlink" title="1.2 操作Node的几个CAS操作"></a>1.2 操作Node的几个CAS操作</h2><p>在队列进行出队入队的时候免不了对节点需要进行操作，在多线程就很容易出现线程安全的问题。可以看出在处理器指令集能够支持<strong>CMPXCHG</strong>指令后，在java源码中涉及到并发处理都会使用CAS操作<a href="https://juejin.im/post/5ae6dc04f265da0ba351d3ff" target="_blank" rel="noopener">(关于CAS操作可以看这篇文章的第3.1节</a>)，那么在ConcurrentLinkedQueue对Node的CAS操作有这样几个：</p>
<pre><code>//更改Node中的数据域item    
boolean casItem(E cmp, E val) {
    return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val);
}
//更改Node中的指针域next
void lazySetNext(Node&lt;E&gt; val) {
    UNSAFE.putOrderedObject(this, nextOffset, val);
}
//更改Node中的指针域next
boolean casNext(Node&lt;E&gt; cmp, Node&lt;E&gt; val) {
    return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);
}</code></pre><p>可以看出这些方法实际上是通过调用UNSAFE实例的方法，UNSAFE为<strong>sun.misc.Unsafe</strong>类，该类是hotspot底层方法，目前为止了解即可，知道CAS的操作归根结底是由该类提供就好。</p>
<h1 id="2-offer方法"><a href="#2-offer方法" class="headerlink" title="2.offer方法"></a>2.offer方法</h1><p>对一个队列来说，插入满足FIFO特性，插入元素总是在队列最末尾的地方进行插入，而取（移除）元素总是从队列的队头。所有要想能够彻底弄懂ConcurrentLinkedQueue自然而然是从offer方法和poll方法开始。那么为了能够理解offer方法，采用debug的方式来一行一行的看代码走。另外，在看多线程的代码时，可采用这样的思维方式：</p>
<blockquote>
<p><strong>单个线程offer</strong><br><strong>多个线程offer</strong><br><strong>部分线程offer，部分线程poll</strong><br>—-offer的速度快于poll<br>——–队列长度会越来越长，由于offer节点总是在对队列队尾，而poll节点总是在队列对头，也就是说offer线程和poll线程两者并无“交集”，也就是说两类线程间并不会相互影响，这种情况站在相对速率的角度来看，也就是一个”单线程offer”<br>—-offer的速度慢于poll<br>——–poll的相对速率快于offer，也就是队头删的速度要快于队尾添加节点的速度，导致的结果就是队列长度会越来越短，而offer线程和poll线程就会出现“交集”，即那一时刻就可以称之为offer线程和poll线程同时操作的节点为 <strong>临界点</strong> ，且在该节点offer线程和poll线程必定相互影响。根据在临界点时offer和poll发生的相对顺序又可从两个角度去思考：<strong>1. 执行顺序为offer–&gt;poll–&gt;offer</strong>，即表现为当offer线程在Node1后插入Node2时，此时poll线程已经将Node1删除，这种情况很显然需要在offer方法中考虑； <strong>2.执行顺序可能为：poll–&gt;offer–&gt;poll</strong>，即表现为当poll线程准备删除的节点为null时（队列为空队列），此时offer线程插入一个节点使得队列变为非空队列</p>
</blockquote>
<p>先看这么一段代码：</p>
<pre><code>1. ConcurrentLinkedQueue&lt;Integer&gt; queue = new ConcurrentLinkedQueue&lt;&gt;();
2. queue.offer(1);
3. queue.offer(2);</code></pre><p>创建一个ConcurrentLinkedQueue实例，先offer 1，然后再offer 2。offer的源码为：</p>
<pre><code>public boolean offer(E e) {
1.    checkNotNull(e);
2.    final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e);

3.    for (Node&lt;E&gt; t = tail, p = t;;) {
4.        Node&lt;E&gt; q = p.next;
5.        if (q == null) {
6.            // p is last node
7.            if (p.casNext(null, newNode)) {
                // Successful CAS is the linearization point
                // for e to become an element of this queue,
               // and for newNode to become &quot;live&quot;.
8.                if (p != t) // hop two nodes at a time
9.                    casTail(t, newNode);  // Failure is OK.
10.                return true;
            }
            // Lost CAS race to another thread; re-read next
        }
11.        else if (p == q)
            // We have fallen off list.  If tail is unchanged, it
            // will also be off-list, in which case we need to
            // jump to head, from which all live nodes are always
            // reachable.  Else the new tail is a better bet.
12.            p = (t != (t = tail)) ? t : head;
           else
            // Check for tail updates after two hops.
13.            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;
    }
}</code></pre><p><strong>单线程执行角度分析</strong>：</p>
<p>先从<strong>单线程执行的角度</strong>看起，分析offer 1的过程。第1行代码会对是否为null进行判断，为null的话就直接抛出空指针异常，第2行代码将e包装成一个Node类，第3行为for循环，只有初始化条件没有循环结束条件，这很符合CAS的“套路”，在循环体CAS操作成功会直接return返回，如果CAS操作失败的话就在for循环中不断重试直至成功。这里实例变量t被初始化为tail，p被初始化为t即tail。为了方便下面的理解，<strong>p被认为队列真正的尾节点，tail不一定指向对象真正的尾节点，因为在ConcurrentLinkedQueue中tail是被延迟更新的</strong>，具体原因我们慢慢来看。代码走到第3行的时候，t和p都分别指向初始化时创建的item域为null，next域为null的Node0。第4行变量q被赋值为null，第5行if判断为true，在第7行使用casNext将插入的Node设置成当前队列尾节点p的next节点，如果CAS操作失败，此次循环结束在下次循环中进行重试。CAS操作成功走到第8行，此时p==t，if判断为false,直接return true返回。如果成功插入1的话，此时ConcurrentLinkedQueue的状态如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2615789-f2509bec71a8dc33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.offer 1后队列的状态.png"></p>
<p>如图，此时队列的尾节点应该为Node1,而tail指向的节点依然还是Node0,因此可以说明tail是延迟更新的。那么我们继续来看offer 2的时候的情况，很显然此时第4行q指向的节点不为null了，而是指向Node1,第5行if判断为false,第11行if判断为false,代码会走到第13行。好了，<strong>再插入节点的时候我们会问自己这样一个问题？上面已经解释了tail并不是指向队列真正的尾节点，那么在插入节点的时候，我们是不是应该最开始做的就是找到队列当前的尾节点在哪里才能插入？</strong>那么第13行代码就是<strong>找出队列真正的尾节点</strong>。</p>
<blockquote>
<p><strong>定位队列真正的对尾节点</strong></p>
</blockquote>
<pre><code>p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</code></pre><p>我们来分析一下这行代码，如果这段代码在<strong>单线程环境</strong>执行时，很显然由于p==t,此时p会被赋值为q,而q等于<code>Node&lt;E&gt; q = p.next</code>，即Node1。在第一次循环中指针p指向了队列真正的队尾节点Node1，那么在下一次循环中第4行q指向的节点为null，那么在第5行中if判断为true,那么在第7行依然通过casNext方法设置p节点的next为当前新增的Node,接下来走到第8行，这个时候p!=t，第8行if判断为true,会通过<code>casTail(t, newNode)</code>将当前节点Node设置为队列的队尾节点,此时的队列状态示意图如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/2615789-6f8fe58d7a83fe61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.队列offer 2后的状态.png"></p>
<p><strong>tail指向的节点由Node0改变为Node2</strong>,这里的casTail失败不需要重试的原因是，offer代码中主要是通过p的next节点q(<code>Node&lt;E&gt; q = p.next</code>)决定后面的逻辑走向的，当casTail失败时状态示意图如下：<br><img src="http://upload-images.jianshu.io/upload_images/2615789-3b07de9df192dfc7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.队列进行入队操作后casTail失败后的状态图.png"></p>
<p>如图，<strong>如果这里casTail设置tail失败即tail还是指向Node0节点的话，无非就是多循环几次通过13行代码定位到队尾节点</strong>。</p>
<p>通过对单线程执行角度进行分析，我们可以了解到poll的执行逻辑为：</p>
<ol>
<li><p><strong>如果tail指向的节点的下一个节点（next域）为null的话，说明tail指向的节点即为队列真正的队尾节点，因此可以通过casNext插入当前待插入的节点,但此时tail并未变化，如图2;</strong></p>
</li>
<li><p><strong>如果tail指向的节点的下一个节点（next域）不为null的话，说明tail指向的节点不是队列的真正队尾节点。通过<code>q（Node&lt;E&gt; q = p.next）</code>指针往前递进去找到队尾节点，然后通过casNext插入当前待插入的节点，并通过casTail方式更改tail，如图3</strong>。</p>
</li>
</ol>
<p>我们回过头再来看<code>p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</code>这行代码在单线程中，这段代码永远不会将p赋值为t,那么这么写就不会有任何作用，那我们试着在<strong>多线程</strong>的情况下进行分析。</p>
<p><strong>多线程执行角度分析</strong></p>
<blockquote>
<p><strong>多个线程offer</strong></p>
</blockquote>
<p>很显然这么写另有深意，其实在<strong>多线程环境</strong>下这行代码很有意思的。 <code>t != (t = tail)</code>这个操作<strong>并非一个原子操作</strong>，有这样一种情况：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2615789-9fd7db3a6c9372ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.线程A和线程B有可能的执行时序.png"></p>
<p>如图，假设线程A此时读取了变量t，线程B刚好在这个时候offer一个Node后，此时会修改tail指针,那么这个时候线程A再次执行t=tail时t会指向另外一个节点，很显然线程A前后两次读取的变量t指向的节点不相同，即<code>t != (t = tail)</code>为true,并且由于t指向节点的变化<code>p != t</code>也为true，此时该行代码的执行结果为p和t最新的t指针指向了同一个节点，并且此时t也是队列真正的对尾节点。那么，现在已经定位到队列真正的队尾节点，就可以执行offer操作了。</p>
<blockquote>
<p><strong>offer-&gt;poll-&gt;offer</strong></p>
</blockquote>
<p>那么还剩下第11行的代码我们没有分析，大致可以猜想到应该就是回答<strong>一部分线程offer，一部分poll</strong>的这种情况。当<code>if (p == q)</code>为true时，说明p指向的节点的next也指向它自己，这种节点称之为<strong>哨兵节点</strong>，<strong>这种节点在队列中存在的价值不大，一般表示为要删除的节点或者是空节点</strong>。为了能够很好的理解这种情况，我们先看看poll方法的执行过程后，再回过头来看，总之这是一个很有意思的事情 :)。</p>
<h1 id="3-poll方法"><a href="#3-poll方法" class="headerlink" title="3.poll方法"></a>3.poll方法</h1><p>poll方法源码如下：</p>
<pre><code>public E poll() {
    restartFromHead:
    1. for (;;) {
    2.    for (Node&lt;E&gt; h = head, p = h, q;;) {
    3.        E item = p.item;

    4.        if (item != null &amp;&amp; p.casItem(item, null)) {
                // Successful CAS is the linearization point
                // for item to be removed from this queue.
    5.            if (p != h) // hop two nodes at a time
    6.                updateHead(h, ((q = p.next) != null) ? q : p);
    7.            return item;
            }
    8.        else if ((q = p.next) == null) {
    9.            updateHead(h, p);
    10.            return null;
            }
    11.        else if (p == q)
    12.            continue restartFromHead;
            else
    13.            p = q;
        }
    }
}</code></pre><p>我们还是先站在<strong>单线程的角度</strong>去理清该方法的基本逻辑。假设ConcurrentLinkedQueue初始状态如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2615789-450e7301fd19e6df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.队列初始状态.png"></p>
<p>参数offer时的定义，我们还是先将<strong>变量p作为队列要删除真正的队头节点，h（head）指向的节点并不一定是队列的队头节点</strong>。先来看poll出Node1时的情况，由于<code>p=h=head</code>，参照上图，很显然此时p指向的Node1的数据域不为null,在第4行代码中<code>item!=null</code>判断为true后接下来通过<code>casItem</code>将Node1的数据域设置为null。如果CAS设置失败则此次循环结束等待下一次循环进行重试。若第4行执行成功进入到第5行代码，此时p和h都指向Node1,第5行if判断为false,然后直接到第7行return回Node1的数据域1，方法运行结束，此时的队列状态如下图。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2615789-c3c45ac89c461ab5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.队列出队操作后的状态.png"></p>
<p>下面继续从队列中poll，很显然当前h和p指向的Node1的数据域为null，那么第一件事就是要<strong>定位准备删除的队头节点(找到数据域不为null的节点)</strong>。</p>
<blockquote>
<p>定位删除的队头节点</p>
</blockquote>
<p>继续看，第三行代码item为null,第4行代码if判断为false,走到第8行代码（<code>q = p.next</code>）if也为false，由于q指向了Node2,在第11行的if判断也为false，因此代码走到了第13行，这个时候p和q共同指向了Node2,也就找到了要删除的真正的队头节点。可以总结出，定位待删除的队头节点的过程为：<strong>如果当前节点的数据域为null，很显然该节点不是待删除的节点，就用当前节点的下一个节点去试探</strong>。在经过第一次循环后，此时状态图为下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2615789-c4deb3237eefb777.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.经过一次循环后的状态.png"></p>
<p>进行下一次循环，第4行的操作同上述，当前假设第4行中casItem设置成功，由于p已经指向了Node2,而h还依旧指向Node1,此时第5行的if判断为true，然后执行<code>updateHead(h, ((q = p.next) != null) ? q : p)</code>，此时q指向的Node3，所有传入updateHead方法的分别是指向Node1的h引用和指向Node3的q引用。updateHead方法的源码为：</p>
<pre><code>final void updateHead(Node&lt;E&gt; h, Node&lt;E&gt; p) {
    if (h != p &amp;&amp; casHead(h, p))
        h.lazySetNext(h);
}</code></pre><p>该方法主要是通过<code>casHead</code>将队列的head指向Node3,并且通过 <code>h.lazySetNext</code>将Node1的next域指向它自己。最后在第7行代码中返回Node2的值。此时队列的状态如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2615789-5a93cb7a44f40745.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9.Node2从队列中出队后的状态.png"></p>
<p>Node1的next域指向它自己，head指向了Node3。如果队列为空队列的话，就会执行到代码的第8行<code>(q = p.next) == null</code>，if判断为true,因此在第10行中直接返回null。以上的分析是从单线程执行的角度去看，也可以让我们了解poll的整体思路，现在来做一个总结：</p>
<ol>
<li><p><strong>如果当前head,h和p指向的节点的Item不为null的话，说明该节点即为真正的队头节点（待删除节点），只需要通过casItem方法将item域设置为null,然后将原来的item直接返回即可。</strong></p>
</li>
<li><p><strong>如果当前head,h和p指向的节点的item为null的话，则说明该节点不是真正的待删除节点，那么应该做的就是寻找item不为null的节点。通过让q指向p的下一个节点（q = p.next）进行试探，若找到则通过updateHead方法更新head指向的节点以及构造哨兵节点（<code>通过updateHead方法的h.lazySetNext(h)</code>）</strong>。</p>
</li>
</ol>
<p>接下来，按照上面分析offer的思维方式，下面来分析一下多线程的情况，第一种情况是；</p>
<p><strong>多线程执行情况分析：</strong></p>
<blockquote>
<p><strong>多个线程poll</strong></p>
</blockquote>
<p>现在回过头来看poll方法的源码，有这样一部分：</p>
<pre><code>else if (p == q)
    continue restartFromHead;</code></pre><p>这一部分就是处理多个线程poll的情况，<code>q = p.next</code>也就是说q永远指向的是p的下一个节点，那么什么情况下会使得p,q指向同一个节点呢？根据上面我们的分析，只有p指向的节点在poll的时候转变成了<strong>哨兵节点</strong>（通过updateHead方法中的h.lazySetNext）。当线程A在判断<code>p==q</code>时，线程B已经将执行完poll方法将p指向的节点转换为<strong>哨兵节点</strong>并且head指向的节点已经发生了改变，所以就需要从restartFromHead处执行，保证用到的是最新的head。</p>
<blockquote>
<p><strong>poll-&gt;offer-&gt;poll</strong></p>
</blockquote>
<p>试想，还有这样一种情况，如果当前队列为空队列，线程A进行poll操作，同时线程B执行offer，然后线程A在执行poll，那么此时线程A返回的是null还是线程B刚插入的最新的那个节点呢？我们来写一代demo：</p>
<pre><code>public static void main(String[] args) {
    Thread thread1 = new Thread(() -&gt; {
        Integer value = queue.poll();
        System.out.println(Thread.currentThread().getName() + &quot; poll 的值为：&quot; + value);
        System.out.println(&quot;queue当前是否为空队列：&quot; + queue.isEmpty());
    });
    thread1.start();
    Thread thread2 = new Thread(() -&gt; {
        queue.offer(1);
    });
    thread2.start();
}</code></pre><p>输出结果为：</p>
<blockquote>
<p>Thread-0 poll 的值为：null<br>queue当前是否为空队列：false</p>
</blockquote>
<p>通过debug控制线程thread1和线程thread2的执行顺序，thread1先执行到第8行代码<code>if ((q = p.next) == null)</code>，由于此时队列为空队列if判断为true，进入if块，此时先让thread1暂停，然后thread2进行offer插入值为1的节点后，thread2执行结束。再让thread1执行，这时<strong>thread1并没有进行重试</strong>，而是代码继续往下走，返回null，尽管此时队列由于thread2已经插入了值为1的新的节点。所以输出结果为thread0 poll的为null,然队列不为空队列。因此，<strong>在判断队列是否为空队列的时候是不能通过线程在poll的时候返回为null进行判断的，可以通过isEmpty方法进行判断</strong>。</p>
<h1 id="4-offer方法中部分线程offer部分线程poll"><a href="#4-offer方法中部分线程offer部分线程poll" class="headerlink" title="4. offer方法中部分线程offer部分线程poll"></a>4. offer方法中部分线程offer部分线程poll</h1><p>在分析offer方法的时候我们还留下了一个问题，即对offer方法中第11行代码的理解。</p>
<blockquote>
<p><strong>offer-&gt;poll-&gt;offer</strong></p>
</blockquote>
<p>在offer方法的第11行代码<code>if (p == q)</code>，能够让if判断为true的情况为p指向的节点为<strong>哨兵节点</strong>，而什么时候会构造哨兵节点呢？在对poll方法的讨论中，我们已经找到了答案，即<strong>当head指向的节点的item域为null时会寻找真正的队头节点，等到待插入的节点插入之后，会更新head，并且将原来head指向的节点设置为哨兵节点。</strong>假设队列初始状态如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/2615789-70b0af25bced807a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.offer和poll相互影响分析时队列初始状态.png"><br>因此在线程A执行offer时，线程B执行poll就会存在如下一种情况：<br><img src="http://upload-images.jianshu.io/upload_images/2615789-cf872ba6fdd99099.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.线程A和线程B可能存在的执行时序.png"></p>
<p>如图，线程A的tail节点存在next节点Node1,因此会通过引用q往前寻找队列真正的队尾节点，当执行到判断<code>if (p == q)</code>时，此时线程B执行poll操作，在对线程B来说，head和p指向Node0,由于Node0的item域为null,同样会往前递进找到队列真正的队头节点Node1,在线程B执行完poll之后，Node0就会转换为<strong>哨兵节点</strong>，也就意味着队列的head发生了改变，此时队列状态为下图。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2615789-d0d2d16b16c11802.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12.线程B进行poll后队列的状态图.png"></p>
<p>此时线程A在执行判断<code>if (p == q)</code>时就为true,会继续执行<code>p = (t != (t = tail)) ? t : head;</code>，由于tail指针没有发生改变所以p被赋值为head,重新从head开始完成插入操作。</p>
<h1 id="5-HOPS的设计"><a href="#5-HOPS的设计" class="headerlink" title="5. HOPS的设计"></a>5. HOPS的设计</h1><p>通过上面对offer和poll方法的分析，我们发现tail和head是延迟更新的，两者更新触发时机为：</p>
<p><strong>tail更新触发时机</strong>：当tail指向的节点的下一个节点不为null的时候，会执行定位队列真正的队尾节点的操作，找到队尾节点后完成插入之后才会通过casTail进行tail更新；当tail指向的节点的下一个节点为null的时候，只插入节点不更新tail。</p>
<p><strong>head更新触发时机：</strong>当head指向的节点的item域为null的时候，会执行定位队列真正的队头节点的操作，找到队头节点后完成删除之后才会通过updateHead进行head更新；当head指向的节点的item域不为null的时候，只删除节点不更新head。</p>
<p>并且在更新操作时，源码中会有注释为：<strong>hop two nodes at a time</strong>。所以这种延迟更新的策略就被叫做HOPS的大概原因是这个（猜的 :)），从上面更新时的状态图可以看出，head和tail的更新是“跳着的”即中间总是间隔了一个。那么这样设计的意图是什么呢？</p>
<p>如果让tail永远作为队列的队尾节点，实现的代码量会更少，而且逻辑更易懂。但是，这样做有一个缺点，<strong>如果大量的入队操作，每次都要执行CAS进行tail的更新，汇总起来对性能也会是大大的损耗。如果能减少CAS更新的操作，无疑可以大大提升入队的操作效率，所以doug lea大师每间隔1次（tail和队尾节点的距离为1）进行才利用CAS更新tail。</strong>对head的更新也是同样的道理，虽然，这样设计会多出在循环中定位队尾节点，但总体来说读的操作效率要远远高于写的性能，因此，多出来的在循环中定位尾节点的操作的性能损耗相对而言是很小的。</p>
<blockquote>
<p>参考资料</p>
</blockquote>
<p>《java并发编程的艺术》<br>《Java高并发程序设计》<br>ConcurrentLinkedQueue博文：<a href="https://www.cnblogs.com/sunshine-2015/p/6067709.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunshine-2015/p/6067709.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>并发容器之ConcurrentHashMap(JDK 1.8版本)</title>
    <url>/2019/12/06/bing-fa-rong-qi-zhi-concurrenthashmap-jdk-1-8-ban-ben/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://github.com/njustwh2014/MyJavaRepo" target="_blank" rel="noopener">我的github项目，有一些代码示例</a> forked from <a href="https://github.com/CL0610/Java-concurrency" target="_blank" rel="noopener">https://github.com/CL0610/Java-concurrency</a></p>
</blockquote>
<h2 id="1-ConcurrentHashmap简介"><a href="#1-ConcurrentHashmap简介" class="headerlink" title="1.ConcurrentHashmap简介"></a>1.ConcurrentHashmap简介</h2><p>在使用HashMap时在多线程情况下扩容会出现CPU接近100%的情况，因为<strong>Hashmap并不是线程安全的</strong>，通常我们可以使用在java体系中古老的Hashtable类，该类基本上所有的方法都采用synchronized进行线程安全的控制，可想而知，在高并发的情况下，每次只有一个线程能够获取对象监视器锁，这样的并发性能的确不令人满意。另外一种方式通过Collections的<code>Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)</code>将Hashmap包装成一个线程安全的map。比如SynchronzedMap的put方法源码为：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.put(key, value);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上SynchronizedMap实现依然是采用synchronized独占式锁进行线程安全的并发控制的。同样，这种方案的性能也是令人不太满意的。针对这种境况，Doug Lea大师不遗余力的为我们创造了一些线程安全的并发容器，让每一个java开发人员倍感幸福。相对于Hashmap来说，ConcurrentHashMap就是线程安全的map，其中<strong>利用了锁分段的思想提高了并发度</strong>。</p>
<p>ConcurrentHashMap在JDK1.6的版本网上资料很多，有兴趣的可以去看看。<br>JDK 1.6版本关键要素：</p>
<ol>
<li><p>segment继承了ReentrantLock充当锁的角色，为每一个segment提供了线程安全的保障；</p>
</li>
<li><p>segment维护了哈希散列表的若干个桶，每个桶由HashEntry构成的链表。</p>
</li>
</ol>
<p>而到了JDK 1.8的ConcurrentHashMap就有了很大的变化，光是代码量就足足增加了很多。1.8版本舍弃了segment，并且大量使用了synchronized，以及CAS无锁操作以保证ConcurrentHashMap操作的线程安全性。至于为什么不用ReentrantLock而是Synchronzied呢？实际上，synchronzied做了很多的优化，包括偏向锁，轻量级锁，重量级锁，可以依次向上升级锁状态，但不能降级，因此，使用synchronized相较于ReentrantLock的性能会持平甚至在某些情况更优，具体的性能测试可以去网上查阅一些资料。另外，底层数据结构改变为采用<strong>数组+链表+红黑树</strong>的数据形式。</p>
<h2 id="2-关键属性及类"><a href="#2-关键属性及类" class="headerlink" title="2.关键属性及类"></a>2.关键属性及类</h2><p>在了解ConcurrentHashMap的具体方法实现前，我们需要系统的来看一下几个关键的地方。</p>
<blockquote>
<p><strong>ConcurrentHashMap的关键属性</strong></p>
</blockquote>
<ol>
<li><strong>table</strong></li>
</ol>
<p><code>volatile Node&lt;K,V&gt;[] table;</code>://装载Node的数组，作为ConcurrentHashMap的数据容器，采用懒加载的方式，直到第一次插入数据的时候才会进行初始化操作，数组的大小总是为2的幂次方。</p>
<ol start="2">
<li><strong>nextTable</strong></li>
</ol>
<p><code>volatile Node&lt;K,V&gt;[] nextTable;</code> //扩容时使用，平时为null，只有在扩容的时候才为非null</p>
<ol start="3">
<li><strong>sizeCtl</strong></li>
</ol>
<p><code>volatile int sizeCtl;</code><br>该属性用来控制table数组的大小，根据是否初始化和是否正在扩容有几种情况：<br><strong>当值为负数时：</strong>如果为-1表示正在初始化，如果为-N则表示当前正有N-1个线程进行扩容操作；<br><strong>当值为正数时：</strong>如果当前数组为null的话表示table在初始化过程中，sizeCtl表示为需要新建数组的长度；<br>若已经初始化了，表示当前数据容器（table数组）可用容量也可以理解成临界值（插入节点数超过了该临界值就需要扩容），具体指为数组的长度n 乘以 加载因子loadFactor；<br>当值为0时，即数组长度为默认初始值。</p>
<ol start="4">
<li><strong>sun.misc.Unsafe U</strong></li>
</ol>
<p>在ConcurrentHashMapde的实现中可以看到大量的U.compareAndSwapXXXX的方法去修改ConcurrentHashMap的一些属性。这些方法实际上是利用了CAS算法保证了线程安全性，这是一种乐观策略，假设每一次操作都不会产生冲突，当且仅当冲突发生的时候再去尝试。而CAS操作依赖于现代处理器指令集，通过底层<strong>CMPXCHG</strong>指令实现。CAS(V,O,N)核心思想为：<strong>若当前变量实际值V与期望的旧值O相同，则表明该变量没被其他线程进行修改，因此可以安全的将新值N赋值给变量；若当前变量实际值V与期望的旧值O不相同，则表明该变量已经被其他线程做了处理，此时将新值N赋给变量操作就是不安全的，在进行重试</strong>。而在大量的同步组件和并发容器的实现中使用CAS是通过<code>sun.misc.Unsafe</code>类实现的，该类提供了一些可以直接操控内存和线程的底层操作，可以理解为java中的“指针”。该成员变量的获取是在静态代码块中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        .......</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>ConcurrentHashMap中关键内部类</strong></p>
</blockquote>
<ol>
<li><strong>Node</strong></li>
</ol>
<p>Node类实现了Map.Entry接口，主要存放key-value对，并且具有next域</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V val;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外可以看出很多属性都是用volatile进行修饰的，也就是为了保证内存可见性。</p>
<ol start="2">
<li><strong>TreeNode</strong></li>
</ol>
<p>树节点，继承于承载数据的Node类。而红黑树的操作是针对TreeBin类的，从该类的注释也可以看出，也就是TreeBin会将TreeNode进行再一次封装</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Nodes for use in TreeBins</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>TreeBin</strong></li>
</ol>
<p>这个类并不负责包装用户的key、value信息，而是包装的很多TreeNode节点。实际的ConcurrentHashMap“数组”中，存放的是TreeBin对象，而不是TreeNode对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; root;</span><br><span class="line">        <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">        <span class="comment">// values for lockState</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>ForwardingNode</strong></li>
</ol>
<p>在扩容时才会出现的特殊节点，其key,value,hash全部为null。并拥有nextTable指针引用新的table数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>CAS关键操作</strong></p>
</blockquote>
<p>在上面我们提及到在ConcurrentHashMap中会大量使用CAS修改它的属性和一些操作。因此，在理解ConcurrentHashMap的方法前我们需要了解下面几个常用的利用CAS算法来保障线程安全的操作。</p>
<ol>
<li><p><strong>tabAt</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法用来获取table数组中索引为i的Node元素。</p>
</li>
<li><p><strong>casTabAt</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用CAS操作设置table数组中索引为i的元素</p>
</li>
<li><p><strong>setTabAt</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>该方法用来设置table数组中索引为i的元素</p>
<h2 id="3-重点方法讲解"><a href="#3-重点方法讲解" class="headerlink" title="3.重点方法讲解"></a>3.重点方法讲解</h2><p>在熟悉上面的这核心信息之后，我们接下来就来依次看看几个常用的方法是怎样实现的。</p>
<h3 id="3-1-实例构造器方法"><a href="#3-1-实例构造器方法" class="headerlink" title="3.1 实例构造器方法"></a>3.1 实例构造器方法</h3><p>在使用ConcurrentHashMap第一件事自然而然就是new 出来一个ConcurrentHashMap对象，一共提供了如下几个构造器方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 构造一个空的map，即table数组还未初始化，初始化放在第一次插入数据时，默认大小为16</span></span><br><span class="line">ConcurrentHashMap()</span><br><span class="line"><span class="comment">// 2. 给定map的大小</span></span><br><span class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity) </span><br><span class="line"><span class="comment">// 3. 给定一个map</span></span><br><span class="line">ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</span><br><span class="line"><span class="comment">// 4. 给定map的大小以及加载因子</span></span><br><span class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span><br><span class="line"><span class="comment">// 5. 给定map大小，加载因子以及并发度（预计同时操作数据的线程）</span></span><br><span class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity,<span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span><br></pre></td></tr></table></figure>
<p>ConcurrentHashMap一共给我们提供了5中构造器方法，具体使用请看注释，我们来看看第2种构造器，传入指定大小时的情况，该构造器源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 小于0直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//2. 判断是否超过了允许的最大值，超过了话则取最大值，否则再对该值进一步处理</span></span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">                MAXIMUM_CAPACITY :</span><br><span class="line">                tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//3. 赋值给sizeCtl</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>补充</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;&lt;      <span class="comment">//左移运算符，num &lt;&lt; 1,相当于num乘以2</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;      <span class="comment">//右移运算符，num &gt;&gt; 1,相当于num除以2</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;    <span class="comment">//无符号右移，忽略符号位，空位都以0补齐</span></span><br></pre></td></tr></table></figure>
<p>这段代码的逻辑请看注释，很容易理解，如果小于0就直接抛出异常，如果指定值大于了所允许的最大值的话就取最大值，否则，在对指定值做进一步处理。最后将cap赋值给sizeCtl,关于sizeCtl的说明请看上面的说明，<strong>当调用构造器方法之后，sizeCtl的大小应该就代表了ConcurrentHashMap的大小，即table数组长度</strong>。tableSizeFor做了哪些事情了？源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a power of two table size for the given desired capacity.</span></span><br><span class="line"><span class="comment">    * See Hackers Delight, sec 3.2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = c - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过注释就很清楚了，该方法会将调用构造器方法时指定的大小转换成一个2的幂次方数，也就是说ConcurrentHashMap的大小一定是2的幂次方，比如，当指定大小为18时，为了满足2的幂次方特性，实际上concurrentHashMapd的大小为2的5次方（32）。另外，需要注意的是，<strong>调用构造器方法的时候并未构造出table数组（可以理解为ConcurrentHashMap的数据容器），只是算出table数组的长度，当第一次向ConcurrentHashMap插入数据的时候才真正的完成初始化创建table数组的工作</strong>。</p>
<h3 id="3-2-initTable方法"><a href="#3-2-initTable方法" class="headerlink" title="3.2 initTable方法"></a>3.2 initTable方法</h3><p>直接上源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 1. 保证只有一个线程正在进行初始化操作</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 2. 得出数组的大小</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    <span class="comment">// 3. 这里才真正的初始化数组</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// 4. 计算数组中可用的大小：实际大小n*0.75（加载因子）</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的逻辑请见注释，有可能存在一个情况是多个线程同时走到这个方法中，为了保证能够正确初始化，在第1步中会先通过if进行判断，若当前已经有一个线程正在初始化即sizeCtl值变为-1，这个时候其他线程在If判断为true从而调用Thread.yield()让出CPU时间片。正在进行初始化的线程会调用U.compareAndSwapInt方法将sizeCtl改为-1即正在初始化的状态。另外还需要注意的事情是，在第四步中会进一步计算数组中可用的大小即为数组实际大小n乘以加载因子0.75.可以看看这里乘以0.75是怎么算的，0.75为四分之三，这里<code>n - (n &gt;&gt;&gt; 2)</code>是不是刚好是n-(1/4)n=(3/4)n，挺有意思的吧:)。如果选择是无参的构造器的话，这里在new Node数组的时候会使用默认大小为<code>DEFAULT_CAPACITY</code>（16），然后乘以加载因子0.75为12，也就是说数组的可用大小为12。</p>
<h3 id="3-3-put方法"><a href="#3-3-put方法" class="headerlink" title="3.3 put方法"></a>3.3 put方法</h3><p>使用ConcurrentHashMap最长用的也应该是put和get方法了吧，我们先来看看put方法是怎样实现的。调用put方法时实际具体实现是putVal方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//1. 计算key的hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; </span><br><span class="line">        <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//2. 如果当前table还没有初始化先调用initTable方法将tab进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//3. tab中索引为i的位置的元素为null，则直接使用CAS将值插入即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                            <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4. 当前正在扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//5. 当前为链表，在链表中插入新的键值对</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                    (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                            value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 6.当前为红黑树，将新的键值对插入到红黑树中</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                        value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 7.插入完键值对后再根据实际大小看是否需要转换成红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//8.对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容 </span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>put方法的代码量有点长，我们按照上面的分解的步骤一步步来看。<strong>从整体而言，为了解决线程安全的问题，ConcurrentHashMap使用了synchronzied和CAS的方式</strong>。在之前了解过HashMap以及1.8版本之前的ConcurrenHashMap都应该知道ConcurrentHashMap结构图，为了方面下面的讲解这里先直接给出，如果对这有疑问的话，可以在网上随便搜搜即可。</p>
<p><img src="/2019/12/06/bing-fa-rong-qi-zhi-concurrenthashmap-jdk-1-8-ban-ben/ConcurrentHashMap%E6%95%A3%E5%88%97%E6%A1%B6%E6%95%B0%E7%BB%84%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="ConcurrentHashMap散列桶数组结构示意图"></p>
<p>如图（图片摘自网络），ConcurrentHashMap是一个哈希桶数组，如果不出现哈希冲突的时候，每个元素均匀的分布在哈希桶数组中。当出现哈希冲突的时候，是<strong>标准的链地址的解决方式</strong>，将hash值相同的节点构成链表的形式，称为“拉链法”，另外，在1.8版本中为了防止拉链过长，当链表的长度大于8的时候会将链表转换成红黑树。table数组中的每个元素实际上是单链表的头结点或者红黑树的根节点。当插入键值对时首先应该定位到要插入的桶，即插入table数组的索引i处。那么，怎样计算得出索引i呢？当然是根据key的hashCode值。</p>
<blockquote>
<p>1.spread()重哈希，以减小Hash冲突</p>
</blockquote>
<p>我们知道对于一个hash表来说，hash值分散的不够均匀的话会大大增加哈希冲突的概率，从而影响到hash表的性能。因此通过spread方法进行了一次重hash从而大大减小哈希冲突的可能性。spread方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法主要是<strong>将key的hashCode的低16位于高16位进行异或运算</strong>，这样不仅能够使得hash值能够分散能够均匀减小hash冲突的概率，另外只用到了异或运算，在性能开销上也能兼顾，做到平衡的trade-off。</p>
<blockquote>
<p>2.初始化table</p>
</blockquote>
<p>紧接着到第2步，会判断当前table数组是否初始化了，没有的话就调用initTable进行初始化，该方法在上面已经讲过了。</p>
<blockquote>
<p>3.能否直接将新值插入到table数组中</p>
</blockquote>
<p>从上面的结构示意图就可以看出存在这样一种情况，如果插入值待插入的位置刚好所在的table数组为null的话就可以直接将值插入即可。那么怎样根据hash确定在table中待插入的索引i呢？很显然可以通过hash值与数组的长度取模操作，从而确定新值插入到数组的哪个位置。而之前我们提过ConcurrentHashMap的大小总是2的幂次方，(n - 1) &amp; hash运算等价于对长度n取模，也就是hash%n，但是位运算比取模运算的效率要高很多，Doug lea大师在设计并发容器的时候也是将性能优化到了极致，令人钦佩。</p>
<p>确定好数组的索引i后，就可以可以tabAt()方法（该方法在上面已经说明了，有疑问可以回过头去看看）获取该位置上的元素，如果当前Node f为null的话，就可以直接用casTabAt方法将新值插入即可。</p>
<blockquote>
<p>4.当前是否正在扩容</p>
</blockquote>
<p>如果当前节点不为null，且该节点为特殊节点（forwardingNode）的话，就说明当前concurrentHashMap正在进行扩容操作，关于扩容操作，下面会作为一个具体的方法进行讲解。那么怎样确定当前的这个Node是不是特殊的节点了？是通过判断该节点的hash值是不是等于-1（MOVED）,代码为(fh = f.hash) == MOVED，对MOVED的解释在源码上也写的很清楚了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>5.当table[i]为链表的头结点，在链表中插入新值</p>
</blockquote>
<p>在table[i]不为null并且不为forwardingNode时，并且当前Node f的hash值大于0（fh &gt;= 0）的话说明当前节点f为当前桶的所有的节点组成的链表的头结点。那么接下来，要想向ConcurrentHashMap插入新值的话就是向这个链表插入新值。通过synchronized (f)的方式进行加锁以实现线程安全性。往链表中插入节点的部分代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    binCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">        K ek;</span><br><span class="line">        <span class="comment">// 找到hash值相同的key,覆盖旧值即可</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((ek = e.key) == key ||</span><br><span class="line">                (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">            oldVal = e.val;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                e.val = value;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;K,V&gt; pred = e;</span><br><span class="line">        <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果到链表末尾仍未找到，则直接将新值插入到链表末尾即可</span></span><br><span class="line">            pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                        value, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码很好理解，就是两种情况：1. 在链表中如果找到了与待插入的键值对的key相同的节点，就直接覆盖即可；2. 如果直到找到了链表的末尾都没有找到的话，就直接将待插入的键值对追加到链表的末尾即可</p>
<blockquote>
<p>6.当table[i]为红黑树的根节点，在红黑树中插入新值</p>
</blockquote>
<p>按照之前的数组+链表的设计方案，这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，甚至在极端情况下，查找一个节点会出现时间复杂度为O(n)的情况，则会严重影响ConcurrentHashMap的性能，于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高ConcurrentHashMap的性能，其中会用到红黑树的插入、删除、查找等算法。当table[i]为红黑树的树节点时的操作为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line">    binCount = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                    value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldVal = p.val;</span><br><span class="line">        <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">            p.val = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先在if中通过<code>f instanceof TreeBin</code>判断当前table[i]是否是树节点，这下也正好验证了我们在最上面介绍时说的TreeBin会对TreeNode做进一步封装，对红黑树进行操作的时候针对的是TreeBin而不是TreeNode。这段代码很简单，调用putTreeVal方法完成向红黑树插入新节点，同样的逻辑，<strong>如果在红黑树中存在于待插入键值对的Key相同（hash值相等并且equals方法判断为true）的节点的话，就覆盖旧值，否则就向红黑树追加新节点</strong>。</p>
<blockquote>
<p>7.根据当前节点个数进行调整</p>
</blockquote>
<p>当完成数据新节点插入之后，会进一步对当前链表大小进行调整，这部分代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">        treeifyBin(tab, i);</span><br><span class="line">    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很容易理解，如果当前链表节点个数大于等于8（TREEIFY_THRESHOLD）的时候，就会调用treeifyBin方法将tabel[i]（第i个散列桶）拉链转换成红黑树。</p>
<p>至此，关于Put方法的逻辑就基本说的差不多了，现在来做一些总结：</p>
<p>整体流程：</p>
<ol>
<li>首先对于每一个放入的值，首先利用spread方法对key的hashcode进行一次hash计算，由此来确定这个值在      table中的位置；</li>
<li>如果当前table数组还未初始化，先将table数组进行初始化操作；</li>
<li>如果这个位置是null的，那么使用CAS操作直接放入；</li>
<li>如果这个位置存在结点，说明发生了hash碰撞，首先判断这个节点的类型。如果该节点fh==MOVED(代表forwardingNode,数组正在进行扩容)的话，说明正在进行扩容；</li>
<li>如果是链表节点（fh&gt;0）,则得到的结点就是hash值相同的节点组成的链表的头节点。需要依次向后遍历确定这个新加入的值所在位置。如果遇到key相同的节点，则只需要覆盖该结点的value值即可。否则依次向后遍历，直到链表尾插入这个结点；</li>
<li>如果这个节点的类型是TreeBin的话，直接调用红黑树的插入方法进行插入新的节点；</li>
<li>插入完节点之后再次检查链表长度，如果长度大于8，就把这个链表转换成红黑树；</li>
<li>对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容。 </li>
</ol>
<h3 id="3-4-get方法"><a href="#3-4-get方法" class="headerlink" title="3.4 get方法"></a>3.4 get方法</h3><p>看完了put方法再来看get方法就很容易了，用逆向思维去看就好，这样存的话我反过来这么取就好了。get方法源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">// 1. 重hash</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. table[i]桶节点的key与查找的key相同，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 当前节点hash小于0说明为树节点，在红黑树中查找即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//4. 从链表中查找，查找到则返回该节点的value，否则就返回null即可</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的逻辑请看注释，首先先看当前的hash桶数组节点即table[i]是否为查找的节点，若是则直接返回；若不是，则继续再看当前是不是树节点？通过看节点的hash值是否为小于0，如果小于0则为树节点。如果是树节点在红黑树中查找节点；如果不是树节点，那就只剩下为链表的形式的一种可能性了，就向后遍历查找节点，若查找到则返回节点的value即可，若没有找到就返回null。</p>
<h3 id="3-5-transfer方法"><a href="#3-5-transfer方法" class="headerlink" title="3.5 transfer方法"></a>3.5 transfer方法</h3><p>当ConcurrentHashMap容量不足的时候，需要对table进行扩容。这个方法的基本思想跟HashMap是很像的，但是由于它是支持并发扩容的，所以要复杂的多。原因是它支持多线程进行扩容操作，而并没有加锁。我想这样做的目的不仅仅是为了满足concurrent的要求，而是希望利用并发处理去减少扩容带来的时间影响。transfer方法源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="comment">//1. 新建Node数组，容量为之前的两倍</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">//2. 新建forwardingNode引用，在之后会用到</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="comment">// 3. 确定遍历中的索引i</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                        (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                        nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                    nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.将原数组中的元素复制到新数组中去</span></span><br><span class="line">        <span class="comment">//4.5 for循环退出，扩容结束修改sizeCtl属性</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.1 当前数组中第i个元素为null，用CAS设置成特殊节点forwardingNode(可以理解成占位符)</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="comment">//4.2 如果遍历到ForwardingNode节点  说明这个点已经被处理过了 直接跳过  这里是控制并发扩容的核心</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//4.3 处理当前节点为链表的头结点的情况，构造两个链表，一个是原链表  另一个是原链表的反序排列</span></span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//在nextTable的i位置上插入一个链表</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">//在nextTable的i+n的位置上插入另一个链表</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">//在table的i位置上插入forwardNode节点  表示已经处理过该节点</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">//设置advance为true 返回到上面的while循环中 就可以执行i--操作</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//4.4 处理当前节点是TreeBin时的情况，操作和上面的类似</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码逻辑请看注释,整个扩容操作分为<strong>两个部分</strong>：</p>
<p><strong>第一部分</strong>是构建一个nextTable,它的容量是原来的两倍，这个操作是单线程完成的。新建table数组的代码为:<code>Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]</code>,在原容量大小的基础上右移一位。</p>
<p><strong>第二个部分</strong>就是将原来table中的元素复制到nextTable中，主要是遍历复制的过程。<br>根据运算得到当前遍历的数组的位置i，然后利用tabAt方法获得i位置的元素再进行判断：</p>
<ol>
<li>如果这个位置为空，就在原table中的i位置放入forwardNode节点，这个也是触发并发扩容的关键点；</li>
<li>如果这个位置是Node节点（fh&gt;=0），如果它是一个链表的头节点，就构造一个反序链表，把他们分别放在nextTable的i和i+n的位置上</li>
<li>如果这个位置是TreeBin节点（fh&lt;0），也做一个反序处理，并且判断是否需要untreefi，把处理的结果分别放在nextTable的i和i+n的位置上</li>
<li>遍历过所有的节点以后就完成了复制工作，这时让nextTable作为新的table，并且更新sizeCtl为新容量的0.75倍 ，完成扩容。设置为新容量的0.75倍代码为 <code>sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1)</code>，仔细体会下是不是很巧妙，n&lt;&lt;1相当于n右移一位表示n的两倍即2n,n&gt;&gt;&gt;1左右一位相当于n除以2即0.5n,然后两者相减为2n-0.5n=1.5n,是不是刚好等于新容量的0.75倍即2n*0.75=1.5n。最后用一个示意图来进行总结（图片摘自网络）：</li>
</ol>
<p><img src="/2019/12/06/bing-fa-rong-qi-zhi-concurrenthashmap-jdk-1-8-ban-ben/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="ConcurrentHashMap扩容示意图"></p>
<h3 id="3-6-与size相关的一些方法"><a href="#3-6-与size相关的一些方法" class="headerlink" title="3.6 与size相关的一些方法"></a>3.6 与size相关的一些方法</h3><p>对于ConcurrentHashMap来说，这个table里到底装了多少东西其实是个不确定的数量，因为<strong>不可能在调用size()方法的时候像GC的“stop the world”一样让其他线程都停下来让你去统计，因此只能说这个数量是个估计值。对于这个估计值</strong>，ConcurrentHashMap也是大费周章才计算出来的。</p>
<p>为了统计元素个数，ConcurrentHashMap定义了一些变量和一个内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * A padded cell for distributing counts.  Adapted from LongAdder</span></span><br><span class="line"><span class="comment">    * and Striped64.  See their internal docs for explanation.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterCell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">    CounterCell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 实际上保存的是hashmap中的元素个数  利用CAS锁进行更新</span></span><br><span class="line"><span class="comment">    但它并不用返回当前hashmap的元素个数 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Spinlock (locked via CAS) used when resizing and/or creating CounterCells.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Table of counter cells. When non-null, size is a power of 2.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>mappingCount与size方法</strong></p>
</blockquote>
<p><strong>mappingCount</strong>与<strong>size</strong>方法的类似  从给出的注释来看，应该使用mappingCount代替size方法 两个方法都没有直接返回basecount 而是统计一次这个值，而这个值其实也是一个大概的数值，因此可能在统计的时候有其他线程正在执行插入或删除操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the number of mappings. This method should be used</span></span><br><span class="line"><span class="comment">    * instead of &#123;<span class="doctag">@link</span> #size&#125; because a ConcurrentHashMap may</span></span><br><span class="line"><span class="comment">    * contain more mappings than can be represented as an int. The</span></span><br><span class="line"><span class="comment">    * value returned is an estimate; the actual count may differ if</span></span><br><span class="line"><span class="comment">    * there are concurrent insertions or removals.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the number of mappings</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">mappingCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0L</span>) ? <span class="number">0L</span> : n; <span class="comment">// ignore transient negative values</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;<span class="comment">//所有counter的值求和</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>addCount方法</strong></p>
</blockquote>
<p>在put方法结尾处调用了addCount方法，把当前ConcurrentHashMap的元素个数+1这个方法一共做了两件事,更新baseCount的值，检测是否进行扩容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">//利用CAS方法更新baseCount的值 </span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">                U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果check值大于等于0 则需要检验是否需要进行扩容操作</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//如果已经有其他线程在执行扩容操作</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前线程是唯一的或是第一个发起扩容的线程  此时nextTable=null</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>JDK6,7中的ConcurrentHashmap主要使用Segment来实现减小锁粒度，分割成若干个Segment，在put的时候需要锁住Segment，get时候不加锁，使用volatile来保证可见性，当要统计全局时（比如size），首先会尝试多次计算modcount来确定，这几次尝试中，是否有其他线程进行了修改操作，如果没有，则直接返回size。如果有，则需要依次锁住所有的Segment来计算。</p>
<p>1.8之前put定位节点时要先定位到具体的segment，然后再在segment中定位到具体的桶。而在1.8的时候摒弃了segment臃肿的设计，直接针对的是Node[] tale数组中的每一个桶，进一步减小了锁粒度。并且防止拉链过长导致性能下降，当链表长度大于8的时候采用红黑树的设计。</p>
<p>主要设计上的变化有以下几点:</p>
<ol>
<li>不采用segment而采用node，锁住node来实现减小锁粒度。</li>
<li>设计了MOVED状态 当resize的中过程中 线程2还在put数据，线程2会帮助resize。</li>
<li>使用3个CAS操作来确保node的一些操作的原子性，这种方式代替了锁。</li>
<li>sizeCtl的不同值来代表不同含义，起到了控制的作用。</li>
<li>采用synchronized而不是ReentrantLock</li>
</ol>
<p>更多关于1.7版本与1.8版本的ConcurrentHashMap的实现对比，可以参考<a href="http://www.jianshu.com/p/e694f1e868ec" target="_blank" rel="noopener">这篇文章</a>。</p>
<blockquote>
<p>参考文章</p>
</blockquote>
<p>1.8版本ConcurrentHashMap</p>
<ol>
<li><a href="http://www.importnew.com/22007.html" target="_blank" rel="noopener">http://www.importnew.com/22007.html</a></li>
<li><a href="http://www.jianshu.com/p/c0642afe03e0" target="_blank" rel="noopener">http://www.jianshu.com/p/c0642afe03e0</a></li>
</ol>
<p>1.8版本的HashMap</p>
<p><a href="http://www.importnew.com/20386.html" target="_blank" rel="noopener">http://www.importnew.com/20386.html</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote>
<p>《java并发编程的艺术》</p>
</blockquote>
<blockquote>
<p><a href="https://github.com/njustwh2014/MyJavaRepo" target="_blank" rel="noopener">我的github项目，有一些代码示例</a> forked from <a href="https://github.com/CL0610/Java-concurrency" target="_blank" rel="noopener">https://github.com/CL0610/Java-concurrency</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Concurrent</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Concurrent</tag>
        <tag>HashMap</tag>
        <tag>ConcurrentHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的Cloneable和Serializable接口思考</title>
    <url>/2019/12/06/java-zhong-de-cloneable-he-serializable-jie-kou-si-kao/</url>
    <content><![CDATA[<h2 id="Cloneable接口"><a href="#Cloneable接口" class="headerlink" title="Cloneable接口"></a>Cloneable接口</h2><p><strong>clone()方法</strong>：允许在<strong>堆</strong>中克隆出一块与原对象一样的对象，并将这个对象的地址赋予新的引用。</p>
<p>Java中一个类要实现clone()方法，必须实现Cloneable接口，否则在调用clone()方法时会报CloneNotSupportException异常。</p>
<blockquote>
<p>需要说明：</p>
</blockquote>
<a id="more"></a>
<ol>
<li>对象拷贝返回的是一个新对象，而不是一个引用。</li>
<li>拷贝对象与用 new操作符返回的新对象的区别就是这个拷贝已经包含了一些原来对象的信息，而不是对象的初始信息。</li>
</ol>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloneClass</span> <span class="keyword">implements</span> <span class="title">CLoneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CloneClass o=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            o=(CloneClass)<span class="keyword">super</span>.clone();<span class="comment">//native方法，不是new出来然后赋值，这样效率低下。</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(CloneNotSupportException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>值得注意的地方</p>
</blockquote>
<ol>
<li><p>为了实现clone功能，CloneClass类实现了Cloneable接口，这个接口属于java.lang 包，java.lang包已经被缺省的导入类中，所以不需要写成java.lang.Cloneable；</p>
</li>
<li><p>重写了clone()方法；</p>
</li>
<li><p>在clone()方法中调用了super.clone()，这也意味着无论clone类的继承结构是什么样的，super.clone()直接或 间接调用了java.lang.Object类的clone()方法。</p>
</li>
<li><p>Object类的clone()方法是一个native方法，native方法的效率一般来说都是远高于java中的非native方法。这也解释了为什么要用Object中clone()方法而不是先new一个对象，然后把原始对象中的信息赋到新对象中，虽然这也实现了clone功能，但效率较低。</p>
</li>
<li><p>Object类中的clone()方法还是一个protected属性的方法。这也意味着如果要应用clone()方法，必须继承Object类，在Java中所有的类是缺省继承Object类的，也就不用关心这点了。</p>
</li>
<li><p>重写clone()方法。还有一点要考虑的是为了让其它类能调用这个clone类的clone()方法，重写之后要把clone()方法的属性设置为public。</p>
</li>
</ol>
<blockquote>
<p>Java中clone()方法克隆出的对象是浅克隆(拷贝)</p>
</blockquote>
<ul>
<li><p>浅拷贝（浅克隆）复制出来的对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。</p>
</li>
<li><p>深拷贝（深克隆）复制出来的所有变量都含有与原来的对象相同的值，那些引用其他对象的变量将指向复制出来的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。</p>
</li>
</ul>
<blockquote>
<p>那么利用clone()方法是否可以实现深克隆吗？</p>
</blockquote>
<p>我们先来看看浅克隆示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Teacher teacher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, Teacher teacher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.teacher = teacher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            student = (Student) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>深克隆示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Teacher teacher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, Teacher teacher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.teacher = teacher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            student = (Student) <span class="keyword">super</span>.clone();</span><br><span class="line">            Teacher teacherClone=<span class="keyword">this</span>.teacher.clone();<span class="comment">//这就需要Teacher类也实现了Cloneable接口。</span></span><br><span class="line">            student.setTeacher(teacherClone);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从以上示例可以看出，利用clone()方法可以实现深克隆，需要逐层实现Cloneable接口，这种方法如果继承链比较长，过程会比较麻烦。</p>
<p>此时我们就需要简便地实现深克隆：利用Serializable接口。</p>
<h2 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a>Serializable接口</h2><blockquote>
<p>序列化<br>对象的寿命通常随着生成该对象的程序的终止而终止，而有时候需要把在内存中的各种<strong>对象的状态</strong>（也就是实例变量，不是方法，区别于<strong>类的状态</strong>）保存下来，并且可以在需要时再将对象恢复。Java提供了一种保存对象状态的机制，那就是序列化。</p>
</blockquote>
<p>Java序列化技术可以将一个对象的状态写入一个Byte 流里（序列化），并且可以从其它地方把该Byte流里的数据读出来（反序列化）。</p>
<blockquote>
<p>什么时候需要序列化？</p>
</blockquote>
<ul>
<li><p>想把内存中的对象状态保存到一个文件中或者数据库中时候</p>
</li>
<li><p>想把对象通过网络进行传播的时候</p>
</li>
</ul>
<blockquote>
<p>如何序列化</p>
</blockquote>
<p>只要一个类实现Serializable接口，那么这个类就可以序列化。</p>
<p>示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID=<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name:"</span>+name+<span class="string">"\t age:"</span>+age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过ObjectOutputStream 的writeObject()方法把这个类的对象写到一个地方（文件），再通过ObjectInputStream 的readObject()方法把这个对象读出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序列化对象</span></span><br><span class="line">File file=<span class="keyword">new</span> File(<span class="string">"file"</span>+File.separator+<span class="string">"out.txt"</span>);</span><br><span class="line"></span><br><span class="line">FileOutputStream fos=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    fos=<span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">    ObjectOutputStream oos=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        oos=<span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">        Person person=<span class="keyword">new</span> Person(<span class="string">"huanhuan"</span>,<span class="number">23</span>);</span><br><span class="line">        System.out.println(person.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入对象</span></span><br><span class="line">        oos.writeObject(person);</span><br><span class="line">        oos.flush();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            oos.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"oos关闭失败:"</span>+e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(FileNotFoundException e)&#123;</span><br><span class="line">    System.out.println(<span class="string">"找不到文件:"</span>+e.getMessage());</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"fos关闭失败："</span>+e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化对象</span></span><br><span class="line"></span><br><span class="line">FileInputStream fis=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    fis=<span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">    ObjectInputStream ois=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        ois=<span class="keyword">new</span> ObjetcInputStream(fis);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Person person=(Person)ois.readObject();</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ois.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"ois关闭失败："</span>+e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">"找不到文件："</span>+e.getMessage());</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"fis关闭失败："</span>+e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>serialVersionUID</p>
</blockquote>
<p>注意到上面程序中有一个serialVersionUID，实现了Serializable接口之后，Eclipse/IDEA就会提示你增加一个serialVersionUID，虽然不加的话上述程序依然能够正常运行。</p>
<p>序列化ID在Eclipse/IDEA下提供了两种生成策略：</p>
<ul>
<li><p>一个是固定的 1L</p>
</li>
<li><p>一个是随机生成一个不重复的long类型数据（实际上是使用JDK工具，根据类名、接口名、成员方法及属性等来生成）</p>
</li>
</ul>
<p>上面程序中，输出对象和读入对象使用的是同一个Person类。</p>
<p>如果是通过网络传输的话，如果Person类的serialVersionUID不一致，那么反序列化就不能正常进行。例如在客户端A中Person类的serialVersionUID=1L，而在客户端B中Person类的serialVersionUID=2L 那么就不能重构这个Person对象。</p>
<p>试图重构就会报java.io.InvalidClassException异常，因为这两个类的版本不一致，local class incompatible，重构就会出现错误。</p>
<p>如果没有特殊需求的话，使用用默认的1L就可以，这样可以确保代码一致时反序列化成功。那么随机生成的序列化ID有什么作用呢，有些时候，通过改变序列化ID可以用来限制某些用户的使用。</p>
<blockquote>
<p>静态变量序列化</p>
</blockquote>
<p>序列化只能保存对象的非静态成员交量，不能保存任何的成员方法和静态的成员变量，而且序列化保存的只是变量的值，对于变量的任何修饰符都不能保存。</p>
<p>如果把Person类中的name定义为static类型的话，试图重构，就不能得到原来的值，只能得到null。说明对静态成员变量值是不保存的。这其实比较容易理解，序列化保存的是对象的状态，<strong>静态变量属于类的状态</strong>，因此 序列化并不保存静态变量。</p>
<blockquote>
<p>transient关键字</p>
</blockquote>
<p>经常在实现了 Serializable接口的类中能看见transient关键字。 transient关键字的作用是：阻止实例中那些用此关键字声明的变量持久化；当对象被反序列化时（从源文件读取字节序列进行重构），这样的实例变量值不会被持久化和恢复。</p>
<p>当某些变量不想被序列化，同是又不适合使用static关键字声明，那么此时就需要用transient关键字来声明该变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name:"</span>+name+<span class="string">"\tage:"</span>+age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</p>
<p><strong>注</strong>：对于某些类型的属性，其状态是瞬时的，这样的属性是无法保存其状态的。例如一个线程属性或需要访问IO、本地资源、网络资源等的属性，对于这些字段，我们必须用transient关键字标明，否则编译器将报措。</p>
<blockquote>
<p>序列化中的继承问题</p>
</blockquote>
<p>当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；</p>
<p>一个子类实现了Serializable接口，它的父类都没有实现Serializable接口，要想将父类对象也序列化，就需要让父类也实现Serializable接口。</p>
<p>第二种情况中：如果父类不实现Serializable接口的话，就需要有默认的无参的构造函数。这是因为创建java对象的时候需要先有父对象，才有子对象，反序列化也不例外。在反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取父对象的变量值时，它的值是调用父类无参构造函数后的值。在这种情况下，在序列化时根据需要在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都是默认声明的值，如int型的默认是0，string型的默认是null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span></span>&#123;&#125;           <span class="comment">//默认的无参构造函数，没有进行初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;     <span class="comment">//有参构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"num:"</span>+num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> num,String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(num);             <span class="comment">//调用父类中的构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString()+<span class="string">"\tname:"</span>+name+<span class="string">"\tage:"</span>+age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Serializable克隆</p>
</blockquote>
<p>Java可以把对象序列化写进一个流里面，反之也可以把对象从序列化流里面读取出来，但这一进一出，这个对象就不再是原来的对象了，就达到了克隆的要求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span>  <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Teacher teacher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, Teacher teacher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.teacher = teacher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">serializableClone</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Student clone;</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream bo = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oo = <span class="keyword">new</span> ObjectOutputStream(bo);</span><br><span class="line">        oo.writeObject(<span class="keyword">this</span>);</span><br><span class="line">        ByteArrayInputStream bi = <span class="keyword">new</span> ByteArrayInputStream(bo.toByteArray());</span><br><span class="line">        ObjectInputStream oi = <span class="keyword">new</span> ObjectInputStream(bi);</span><br><span class="line">        clone = (Student) oi.readObject();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过把对象写进ByteArrayOutputStream里，再把它读取出来。注意这个过程中所有涉及的对象都必须实现Serializable接口，由于涉及IO操作，这种方式的效率会比前面的低。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://blog.csdn.net/xiaomingdetianxia/article/details/74453033" target="_blank" rel="noopener">Java中 Cloneable 、Serializable 接口详解</a></p>
</blockquote>
<blockquote>
<p><a href="https://juejin.im/post/58ae7be02f301e0068ef31f0" target="_blank" rel="noopener">JAVA 基础 - clone浅克隆与深克隆</a></p>
</blockquote>
<blockquote>
<p><a href="https://cnbin.github.io/blog/2016/02/23/java-zhong-ru-guo-clonewei-shi-yao-bi-xu-shi-xian-cloneablejie-kou/" target="_blank" rel="noopener">Java中如果clone为什么必须实现Cloneable接口</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>LockSupport工具</title>
    <url>/2019/12/05/locksupport-gong-ju/</url>
    <content><![CDATA[<p><a href="https://github.com/njustwh2014/MyJavaRepo" target="_blank" rel="noopener">我的github项目，有一些代码示例</a> forked from <a href="https://github.com/CL0610/Java-concurrency" target="_blank" rel="noopener">https://github.com/CL0610/Java-concurrency</a></p>
<h2 id="1-LockSupport简介"><a href="#1-LockSupport简介" class="headerlink" title="1. LockSupport简介"></a>1. LockSupport简介</h2><p>在之前介绍<a href="http://njustwh2014.github.io/2019/11/05/shen-ru-li-jie-abstractqueuedsynchronizer-aqs/">AQS的底层实现</a>，已经在介绍java中的Lock时，比如<a href="http://njustwh2014.github.io/2019/11/05/che-di-li-jie-reentrantlock/">ReentrantLock</a>,<a href="http://njustwh2014.github.io/2019/11/08/shen-ru-li-jie-du-xie-suo-reentrantreadwritelock/">ReentReadWriteLocks</a>,已经在介绍线程间等待/通知机制使用的<a href="http://njustwh2014.github.io/2019/11/08/xiang-jie-condition-de-await-he-signal-deng-dai-tong-zhi-ji-zhi/">Condition</a>时都会调用LockSupport.park()方法和LockSupport.unpark()方法。而这个在同步组件的实现中被频繁使用的LockSupport到底是何方神圣，现在就来看看。LockSupport位于java.util.concurrent.locks包下，有兴趣的可以直接去看源码，该类的方法并不是很多。LockSupprot是线程的阻塞原语，用来阻塞线程和唤醒线程。每个使用LockSupport的线程都会与一个许可关联，如果该许可可用，并且可在线程中使用，则调用park()将会立即返回，否则可能阻塞。如果许可尚不可用，则可以调用 unpark 使其可用。但是注意许可<strong>不可重入</strong>，也就是说只能调用一次park()方法，否则会一直阻塞。</p>
<a id="more"></a>
<h2 id="2-LockSupport方法介绍"><a href="#2-LockSupport方法介绍" class="headerlink" title="2. LockSupport方法介绍"></a>2. LockSupport方法介绍</h2><p>LockSupport中的方法不多，这里将这些方法做一个总结：</p>
<blockquote>
<p><strong>阻塞线程</strong></p>
</blockquote>
<ol>
<li>void park()：阻塞当前线程，如果调用unpark方法或者当前线程被中断，从能从park()方法中返回</li>
<li>void park(Object blocker)：功能同方法1，入参增加一个Object对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；</li>
<li>void parkNanos(long nanos)：阻塞当前线程，最长不超过nanos纳秒，增加了超时返回的特性；</li>
<li>void parkNanos(Object blocker, long nanos)：功能同方法3，入参增加一个Object对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；</li>
<li>void parkUntil(long deadline)：阻塞当前线程，知道deadline；</li>
<li>void parkUntil(Object blocker, long deadline)：功能同方法5，入参增加一个Object对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；</li>
</ol>
<blockquote>
<p><strong>唤醒线程</strong></p>
</blockquote>
<p>void unpark(Thread thread):唤醒处于阻塞状态的指定线程</p>
<p>实际上LockSupport阻塞和唤醒线程的功能是依赖于sun.misc.Unsafe，这是一个很底层的类，有兴趣的可以去查阅资料，比如park()方法的功能实现则是靠unsafe.park()方法。另外在阻塞线程这一系列方法中还有一个很有意思的现象就是，每个方法都会新增一个带有Object的阻塞对象的重载方法。那么增加了一个Object对象的入参会有什么不同的地方了？示例代码很简单就不说了，直接看dump线程的信息。</p>
<p><strong>调用park()方法dump线程</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">"main" #1 prio=5 os_prio=0 tid=0x02cdcc00 nid=0x2b48 waiting on condition [0x00d6f000]</span><br><span class="line">    java.lang.Thread.State: WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:<span class="number">304</span>)</span><br><span class="line">        at learn.LockSupportDemo.main(LockSupportDemo.java:<span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<p><strong>调用park(Object blocker)方法dump线程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">"main" #1 prio=5 os_prio=0 tid=0x0069cc00 nid=0x6c0 waiting on condition [0x00dcf000]</span><br><span class="line">    java.lang.Thread.State: WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        - parking to wait <span class="keyword">for</span>  &lt;<span class="number">0x048c2d18</span>&gt; (a java.lang.String)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:<span class="number">175</span>)</span><br><span class="line">        at learn.LockSupportDemo.main(LockSupportDemo.java:<span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<p>通过分别调用这两个方法然后dump线程信息可以看出，带Object的park方法相较于无参的park方法会增加 parking to wait for  &lt;0x048c2d18&gt; (a java.lang.String）的信息，这种信息就类似于记录“案发现场”，有助于工程人员能够迅速发现问题解决问题。有个有意思的事情是，我们都知道如果使用synchronzed阻塞了线程dump线程时都会有阻塞对象的描述，在java 5推出LockSupport时遗漏了这一点，在java 6时进行了补充。还有一点需要需要的是：<strong>synchronzed致使线程阻塞，线程会进入到BLOCKED状态，而调用LockSupprt方法阻塞线程会致使线程进入到WAITING状态。</strong></p>
<h2 id="3-一个例子"><a href="#3-一个例子" class="headerlink" title="3. 一个例子"></a>3. 一个例子</h2><p>用一个很简单的例子说说这些方法怎么用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"被唤醒"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        LockSupport.unpark(thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>thread线程调用LockSupport.park()致使thread阻塞，当mian线程睡眠3秒结束后通过LockSupport.unpark(thread)方法唤醒thread线程,thread线程被唤醒执行后续操作。另外，还有一点值得关注的是，<strong>LockSupport.unpark(thread)可以指定线程对象唤醒指定的线程</strong>。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote>
<p>《java并发编程的艺术》</p>
</blockquote>
<blockquote>
<p><a href="https://github.com/njustwh2014/MyJavaRepo" target="_blank" rel="noopener">我的github项目，有一些代码示例</a> forked from <a href="https://github.com/CL0610/Java-concurrency" target="_blank" rel="noopener">https://github.com/CL0610/Java-concurrency</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Concurrent</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Concurrent</tag>
        <tag>AQS</tag>
        <tag>Lock</tag>
        <tag>Condition</tag>
      </tags>
  </entry>
  <entry>
    <title>centos上部署docker、java、nginx、elasticsearch</title>
    <url>/2019/12/05/centos-shang-bu-shu-docker-java-nginx-elasticsearch/</url>
    <content><![CDATA[<h2 id="安装centos6"><a href="#安装centos6" class="headerlink" title="安装centos6"></a>安装centos6</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看版本信息</span></span><br><span class="line">cat /etc/redhat-release</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://blog.csdn.net/shuaigexiaobo/article/details/78030008" target="_blank" rel="noopener">版本信息参考链接</a></p>
</blockquote>
<p><strong>开启相应端口</strong></p>
<a id="more"></a>
<h2 id="centos中安装docker"><a href="#centos中安装docker" class="headerlink" title="centos中安装docker"></a>centos中安装docker</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看你当前的内核版本</span></span><br><span class="line">uname -r</span><br><span class="line"></span><br><span class="line"><span class="comment">#更新yum源</span></span><br><span class="line">yum update</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装 Docker</span></span><br><span class="line">yum -y install docker</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动 Docker 后台服务</span></span><br><span class="line">service docker start</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试运行 hello-world,由于本地没有hello-world这个镜像，所以会下载一个hello-world的镜像，并在容器内运行z</span></span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://segmentfault.com/a/1190000012063374" target="_blank" rel="noopener">docker常用命令参考链接</a></p>
</blockquote>
<h2 id="docker中安装elasticsearch"><a href="#docker中安装elasticsearch" class="headerlink" title="docker中安装elasticsearch"></a>docker中安装elasticsearch</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">docker pull elasticsearch:6.5.0</span><br><span class="line"><span class="comment"># 查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 启动镜像</span></span><br><span class="line">docker run -d  -p 9300:9300 -p 9200:9200 -p 5601:5601 --name elasticsearch -v /home/huanhuan/dockerdata/elasticsearch:/data elasticsearch:6.5.0</span><br><span class="line"><span class="comment"># 查看日志</span></span><br><span class="line">docker logs -f elasticsearch</span><br></pre></td></tr></table></figure>
<blockquote>
<p>错误max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在宿主机内修改</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"vm.max_map_count=262144"</span> &gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://www.jianshu.com/p/04f4d7b4a1d3" target="_blank" rel="noopener">centos7常见elasticsearch错误解决方法</a></p>
</blockquote>
<h2 id="docker中安装kibana"><a href="#docker中安装kibana" class="headerlink" title="docker中安装kibana"></a>docker中安装kibana</h2><p>本来打算用nginx代理访问，结果可以直接访问，应该是docker的kibana镜像内置了代理访问。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">docker pull docker.elastic.co/kibana/kibana:6.5.2</span><br><span class="line"><span class="comment"># 查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 启动镜像</span></span><br><span class="line">docker run -it -d -e ELASTICSEARCH_URL=http://127.0.0.1:9200 --name kibana --network=container:elasticsearch docker.elastic.co/kibana/kibana:6.5.2</span><br></pre></td></tr></table></figure>

<h2 id="docker中安装grafana"><a href="#docker中安装grafana" class="headerlink" title="docker中安装grafana"></a>docker中安装grafana</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#拉取镜像</span></span><br><span class="line">docker pull grafana/grafana:latest</span><br><span class="line"><span class="comment">#启动镜像</span></span><br><span class="line">docker run -d -p 3000:3000 --name=grafana  grafana/grafana</span><br><span class="line"><span class="comment">#查看日志</span></span><br><span class="line">docker logs -f grafana</span><br><span class="line"><span class="comment">#查看容器ip</span></span><br><span class="line">docker inspect --format=&#123;&#123;.NetworkSettings.IPAddress&#125;&#125; elasticsearch</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认账户密码:admin/admin</p>
</blockquote>
<blockquote>
<p>第一次登陆后我修改为:admin/trend#1..</p>
</blockquote>
<h2 id="docker中安装nginx"><a href="#docker中安装nginx" class="headerlink" title="docker中安装nginx"></a>docker中安装nginx</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">docker pull nginx</span><br><span class="line"><span class="comment"># 启动镜像</span></span><br><span class="line">docker run -d -p 9528:9528 -p 9529:9529 -p 9530:9530 --name nginx --privileged=<span class="literal">true</span> -v /home/huanhuan/dockerdata/nginx/element-admin:/home/huanhuan/dockerdata/nginx/element-admin -v /home/huanhuan/dockerdata/nginx/images:/home/huanhuan/dockerdata/nginx/images -v /home/huanhuan/dockerdata/nginx/conf/nginx.conf:/etc/nginx/nginx.conf  nginx</span><br></pre></td></tr></table></figure>
<blockquote>
<p>–privileged=true 解决docker读取宿主机文件的权限</p>
</blockquote>
]]></content>
      <categories>
        <category>Centos</category>
      </categories>
  </entry>
  <entry>
    <title>docker中使用grafana</title>
    <url>/2019/11/28/docker-zhong-shi-yong-grafana/</url>
    <content><![CDATA[<h2 id="查看grafana镜像"><a href="#查看grafana镜像" class="headerlink" title="查看grafana镜像"></a>查看grafana镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search grafana</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="拉取grafana镜像"><a href="#拉取grafana镜像" class="headerlink" title="拉取grafana镜像"></a>拉取grafana镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull grafana/grafana:latest</span><br></pre></td></tr></table></figure>

<h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3000:3000 --name=grafana -v D:/grafana:/var/lib/grafana grafana/grafana</span><br><span class="line">docker logs -f grafana</span><br></pre></td></tr></table></figure>

<blockquote>
<p>默认账户密码:admin/admin</p>
</blockquote>
<blockquote>
<p>第一次登陆后我修改为:admin/trend#1..</p>
</blockquote>
<h2 id="grafana容器访问elasticsearch容器"><a href="#grafana容器访问elasticsearch容器" class="headerlink" title="grafana容器访问elasticsearch容器"></a>grafana容器访问elasticsearch容器</h2><blockquote>
<p>查看elasticsearch容器ip</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect --format=&#123;&#123;.NetworkSettings.IPAddress&#125;&#125; elasticsearch</span><br></pre></td></tr></table></figure>

<p>result:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">172.17.0.2</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://www.jianshu.com/p/0ded8d810860" target="_blank" rel="noopener">关于docker的网络类型</a></p>
</blockquote>
<blockquote>
<p>安装后一些目录作用</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#主配置文件</span></span><br><span class="line">/etc/grafana/grafana.ini</span><br><span class="line"><span class="comment">#数据文件</span></span><br><span class="line">/var/lib/grafana</span><br><span class="line"><span class="comment">#home目录</span></span><br><span class="line">/usr/share/grafana</span><br><span class="line"><span class="comment">#日志目录</span></span><br><span class="line">/var/<span class="built_in">log</span>/grafana</span><br><span class="line"><span class="comment">#插件目录</span></span><br><span class="line">/var/lib/grafana/plugins</span><br><span class="line"><span class="comment">#自定义一些精细化配置的文件夹</span></span><br><span class="line">/etc/grafana/provisioning</span><br></pre></td></tr></table></figure>

<p><a href="https://www.li-rui.top/2018/12/12/monitor/grafana%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">配置参考</a></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>docker中使用kibana</title>
    <url>/2019/11/22/docker-zhong-shi-yong-kibana/</url>
    <content><![CDATA[<h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull docker.elastic.co/kibana/kibana:6.5.2</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it -d -e ELASTICSEARCH_URL=http://127.0.0.1:9200 --name kibana --network=container:elasticsearch docker.elastic.co/kibana/kibana:6.5.2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>–network 指定容器共享elasticsearch容器的网络栈 (使用了–network 就不能使用-p 来暴露端口)</p>
</blockquote>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>docker中使用elasticsearch</title>
    <url>/2019/11/20/docker-zhong-shi-yong-elasticsearch/</url>
    <content><![CDATA[<h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull elasticsearch:6.5.0</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d  -p 9300:9300 -p 9200:9200 -p 5601:5601 --name elasticsearch -v D:/elasticsearchdata:/data elasticsearch:6.5.0</span><br><span class="line"></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/20/docker-zhong-shi-yong-elasticsearch/installsuccess.png" alt="安装成功"></p>
<h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs -f 91fe</span><br></pre></td></tr></table></figure>

<h2 id="谷歌浏览器安装elasticsearch-head插件"><a href="#谷歌浏览器安装elasticsearch-head插件" class="headerlink" title="谷歌浏览器安装elasticsearch head插件"></a>谷歌浏览器安装elasticsearch head插件</h2><p><img src="/2019/11/20/docker-zhong-shi-yong-elasticsearch/elassticsearch.png" alt="安装成功"></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>Java并发编程实战:秒杀系统实现</title>
    <url>/2019/11/13/java-bing-fa-bian-cheng-shi-zhan-miao-sha-xi-tong-shi-xian/</url>
    <content><![CDATA[<p><a href="https://github.com/njustwh2014/seckill" target="_blank" rel="noopener">源码地址</a> refer to <a href="https://github.com/TyCoding/springboot-seckill" target="_blank" rel="noopener">TypCoding</a></p>
<p>恰逢双十一，跟着<a href="https://github.com/TyCoding/springboot-seckill" target="_blank" rel="noopener">TypCoding</a>尝试去实现基于Springboot秒杀系统，具体实现细节可以参考<a href="https://github.com/TyCoding/springboot-seckill" target="_blank" rel="noopener">TypCoding</a>的Readme。</p>
<a id="more"></a>
<p>接下来就记录我对于秒杀技术的一些理解。</p>
]]></content>
      <categories>
        <category>Concurrent</category>
      </categories>
  </entry>
  <entry>
    <title>Centos安装Redis</title>
    <url>/2019/11/13/centos-an-zhuang-redis/</url>
    <content><![CDATA[<blockquote>
<p>在CentOS和Red Hat系统中，首先添加EPEL仓库，然后更新yum源：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum update</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>然后安装redis</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum -y install redis</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为了可以使Redis能被远程连接，需要修改配置文件，路径为/etc/redis.conf</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/redis.conf</span><br></pre></td></tr></table></figure>
<p>需要修改的地方：</p>
<p>首先，注释这一行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#bind 127.0.0.1</span><br></pre></td></tr></table></figure>
<p>另外，推荐给Redis设置密码，取消注释这一行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#requirepass foobared</span><br></pre></td></tr></table></figure>
<p>foobared即当前密码，可以自行修改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">requirepass 密码</span><br></pre></td></tr></table></figure>

<blockquote>
<p>常用命令</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start redis.service <span class="comment">#启动redis服务器</span></span><br><span class="line"></span><br><span class="line">systemctl stop redis.service <span class="comment">#停止redis服务器</span></span><br><span class="line"></span><br><span class="line">systemctl restart redis.service <span class="comment">#重新启动redis服务器</span></span><br><span class="line"></span><br><span class="line">systemctl status redis.service <span class="comment">#获取redis服务器的运行状态</span></span><br><span class="line"></span><br><span class="line">systemctl <span class="built_in">enable</span> redis.service <span class="comment">#开机启动redis服务器</span></span><br><span class="line"></span><br><span class="line">systemctl <span class="built_in">disable</span> redis.service <span class="comment">#开机禁用redis服务器</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Centos</category>
      </categories>
  </entry>
  <entry>
    <title>centos7安装mysql</title>
    <url>/2019/11/11/centos7-an-zhuang-mysql/</url>
    <content><![CDATA[<blockquote>
<p>系统环境</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Centos 7.6 64位</span><br></pre></td></tr></table></figure>

<h2 id="添加mysql-yum源"><a href="#添加mysql-yum源" class="headerlink" title="添加mysql yum源"></a>添加mysql yum源</h2><p>在centOS上直接使用yum install mysql安装，最后安装上的会是MariaDB，所以要先添加mysql yum源。</p>
<a id="more"></a>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -Uvh https://repo.mysql.com//mysql80-community-release-el7-2.noarch.rpm</span><br></pre></td></tr></table></figure>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote>
<p>查看yum源中mysql版本</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum repolist all | grep mysql</span><br></pre></td></tr></table></figure>

<blockquote>
<p>禁用最新版本mysql8.0</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum-config-manager --<span class="built_in">disable</span> mysql80-community</span><br></pre></td></tr></table></figure>

<blockquote>
<p>启用我们需要的mysql5.7</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum-config-manager --<span class="built_in">enable</span> mysql57-community</span><br></pre></td></tr></table></figure>

<blockquote>
<p>检查刚刚配置是否生效</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum repolist enabled | grep mysql</span><br></pre></td></tr></table></figure>

<blockquote>
<p>开始安装</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install mysql-community-server</span><br></pre></td></tr></table></figure>

<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><blockquote>
<p>启动mysql</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service mysqld start</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看mysql启动状态</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service mysqld status</span><br></pre></td></tr></table></figure>

<blockquote>
<p>设置开机自启动(optional)</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service mysqld <span class="built_in">enable</span></span><br><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure>

<blockquote>
<p>初次登陆需要临时密码</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">'temporary password'</span> /var/<span class="built_in">log</span>/mysqld.log</span><br></pre></td></tr></table></figure>

<blockquote>
<p>登录</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><blockquote>
<p>修改密码要求</p>
</blockquote>
<p>login mysql first.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_policy=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_length=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改密码</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">'root'</span>@<span class="string">'localhost'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'123456'</span>;</span><br></pre></td></tr></table></figure>

<h2 id="授权其他机器登陆"><a href="#授权其他机器登陆" class="headerlink" title="授权其他机器登陆"></a>授权其他机器登陆</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'root'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'mypassword'</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>;</span><br><span class="line"><span class="keyword">FLUSH</span>  <span class="keyword">PRIVILEGES</span>;</span><br></pre></td></tr></table></figure>
<h2 id="mysql导入导出sql文件"><a href="#mysql导入导出sql文件" class="headerlink" title="mysql导入导出sql文件"></a>mysql导入导出sql文件</h2><blockquote>
<p>导出整个数据库</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名</span><br><span class="line">mysqldump -u dbuser -p dbname &gt; dbname.sql</span><br></pre></td></tr></table></figure>

<blockquote>
<p>导出一个表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名</span><br><span class="line">mysqldump -u dbuser -p dbname users&gt; dbname_users.sql</span><br></pre></td></tr></table></figure>
<blockquote>
<p>导出一个数据库结构</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -u dbuser -p -d --add-drop-table dbname &gt;d:/dbname_db.sql</span><br><span class="line">-d 没有数据 --add-drop-table 在每个create语句之前增加一个drop table</span><br></pre></td></tr></table></figure>

<blockquote>
<p>导入数据库<br>常用source 命令<br>进入mysql数据库控制台，如</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line">mysql&gt;use 数据库</span><br></pre></td></tr></table></figure>
<p>然后使用source命令，后面参数为脚本文件(如这里用到的.sql)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt;<span class="built_in">source</span> d:/dbname.sql</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Centos</category>
      </categories>
  </entry>
  <entry>
    <title>我的阿里云服务器配置备忘</title>
    <url>/2019/11/11/wo-de-a-li-yun-fu-wu-qi-pei-zhi-bei-wang/</url>
    <content><![CDATA[<h2 id="更换系统盘后出现”WARNING-REMOTE-HOST-IDENTIFICATION-HAS-CHANGED-”"><a href="#更换系统盘后出现”WARNING-REMOTE-HOST-IDENTIFICATION-HAS-CHANGED-”" class="headerlink" title="更换系统盘后出现”WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!”"></a>更换系统盘后出现”WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!”</h2><blockquote>
<p>删除~/.ssh/known_hosts文件，或者如果你可以判断出known_hosts中原ssh服务器的公钥，删去那部分。</p>
</blockquote>
<h2 id="相关路径记录"><a href="#相关路径记录" class="headerlink" title="相关路径记录"></a>相关路径记录</h2><blockquote>
<p>用户目录: </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/home/huanhuan</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="mysql使用"><a href="#mysql使用" class="headerlink" title="mysql使用"></a>mysql使用</h2><blockquote>
<p><a href="http://njustwh2014.github.io/2019/11/11/centos7-an-zhuang-mysql/">安装请参考</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p 123456</span><br></pre></td></tr></table></figure>

<h3 id="秒杀数据库"><a href="#秒杀数据库" class="headerlink" title="秒杀数据库"></a>秒杀数据库</h3><blockquote>
<p>上传sql文件到我的centos</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp D:\\git_repo\\seckill\\db\\sys_schema.sql root@ip:/home/huanhuan/mysqldata</span><br><span class="line">scp D:\\git_repo\\seckill\\db\\sys_data.sql root@ip:/home/huanhuan/mysqldata</span><br></pre></td></tr></table></figure>

<blockquote>
<p>mysql读取sql文件</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line">mysql&gt;use seckill;</span><br><span class="line">mysql&gt;<span class="built_in">source</span> /home/huanhuan/mysqldata/sys_schema.sql;</span><br><span class="line">mysql&gt;<span class="built_in">source</span> /home/huanhuan/mysqldata/sys_data.sql;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Centos</category>
      </categories>
      <tags>
        <tag>阿里云</tag>
        <tag>Centos</tag>
      </tags>
  </entry>
  <entry>
    <title>详解Condition的await和signal等待通知机制</title>
    <url>/2019/11/08/xiang-jie-condition-de-await-he-signal-deng-dai-tong-zhi-ji-zhi/</url>
    <content><![CDATA[<p><a href="https://github.com/njustwh2014/MyJavaRepo" target="_blank" rel="noopener">我的github项目，有一些代码示例</a> forked from <a href="https://github.com/CL0610/Java-concurrency" target="_blank" rel="noopener">https://github.com/CL0610/Java-concurrency</a></p>
<h2 id="1-Condition简介"><a href="#1-Condition简介" class="headerlink" title="1.Condition简介"></a>1.Condition简介</h2><p>任何一个java类都天然继承于Object类，在线程间实现通信的往往会应用到Object的几个方法，比如wait(),wait(long timeout),wait(long timeout, int nanos)与notify(),notifyAll()几个方法实现等待/通知机制，同样的， 在java Lock体系下依然会有同样的方法实现等待/通知机制。从整体上来看<strong>Object的wait和notify/notify是与对象监视器配合完成线程间的等待/通知机制，而Condition与Lock配合完成等待通知机制，前者是java底层级别的，后者是语言级别的，具有更高的可控制性和扩展性</strong>。两者除了在使用方式上不同外，在<strong>功能特性</strong>上还是有很多的不同：</p>
<a id="more"></a>
<ol>
<li>Condition能够支持不响应中断，而通过使用Object方式不支持；</li>
<li>Condition能够支持多个等待队列（new 多个Condition对象），而Object方式只能支持一个；</li>
<li>Condition能够支持超时时间的设置，而Object不支持</li>
</ol>
<p>参照Object的wait和notify/notifyAll方法，Condition也提供了同样的方法：</p>
<blockquote>
<p><strong>针对Object的wait方法</strong></p>
</blockquote>
<ol>
<li><code>void await() throws InterruptedException</code>:当前线程进入等待状态，如果其他线程调用condition的signal或者signalAll方法并且当前线程获取Lock从await方法返回，如果在等待状态中被中断会抛出被中断异常；</li>
<li><code>long awaitNanos(long nanosTimeout)</code>：当前线程进入等待状态直到被通知，中断或者<strong>超时</strong>；</li>
<li><code>boolean await(long time, TimeUnit unit)throws InterruptedException</code>：同第二种，支持自定义时间单位</li>
<li><code>boolean awaitUntil(Date deadline) throws InterruptedException</code>：当前线程进入等待状态直到被通知，中断或者<strong>到了某个时间</strong> </li>
</ol>
<blockquote>
<p><strong>针对Object的notify/notifyAll方法</strong></p>
</blockquote>
<ol>
<li><code>void signal()</code>：唤醒一个等待在condition上的线程，将该线程从<strong>等待队列</strong>中转移到<strong>同步队列</strong>中，如果在同步队列中能够竞争到Lock则可以从等待方法中返回。</li>
<li><code>void signalAll()</code>：与1的区别在于能够唤醒所有等待在condition上的线程<h2 id="2-Condition实现原理分析"><a href="#2-Condition实现原理分析" class="headerlink" title="2.Condition实现原理分析"></a>2.Condition实现原理分析</h2><h3 id="2-1-等待队列"><a href="#2-1-等待队列" class="headerlink" title="2.1 等待队列"></a>2.1 等待队列</h3>要想能够深入的掌握condition还是应该知道它的实现原理，现在我们一起来看看condiiton的源码。创建一个condition对象是通过<code>lock.newCondition()</code>,而这个方法实际上是会new出一个<strong>ConditionObject</strong>对象，该类是AQS（<a href="http://njustwh2014.github.io/2019/11/05/shen-ru-li-jie-abstractqueuedsynchronizer-aqs/">AQS的实现原理的文章</a>）的一个内部类，有兴趣可以去看看。前面我们说过，condition是要和lock配合使用的也就是condition和Lock是绑定在一起的，而lock的实现原理又依赖于AQS，自然而然ConditionObject作为AQS的一个内部类无可厚非。我们知道在锁机制的实现上，AQS内部维护了一个同步队列，如果是独占式锁的话，所有获取锁失败的线程的尾插入到<strong>同步队列</strong>，同样的，condition内部也是使用同样的方式，内部维护了一个 <strong>等待队列</strong>，所有调用condition.await方法的线程会加入到等待队列中，并且线程状态转换为等待状态。另外注意到ConditionObject中有两个成员变量：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** First node of condition queue. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"><span class="comment">/** Last node of condition queue. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br></pre></td></tr></table></figure>
这样我们就可以看出来ConditionObject通过持有等待队列的头尾指针来管理等待队列。主要注意的是Node类复用了在AQS中的Node类，其节点状态和相关属性可以去看<a href="http://njustwh2014.github.io/2019/11/05/shen-ru-li-jie-abstractqueuedsynchronizer-aqs/">AQS的实现原理的文章</a>，如果您仔细看完这篇文章对condition的理解易如反掌，对lock体系的实现也会有一个质的提升。Node类有这样一个属性：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后继节点</span></span><br><span class="line">Node nextWaiter;</span><br></pre></td></tr></table></figure>
进一步说明，<strong>等待队列是一个单向队列</strong>，而在之前说AQS时知道同步队列是一个双向队列。接下来我们用一个demo，通过debug进去看是不是符合我们的猜想：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这段代码没有任何实际意义，甚至很臭，只是想说明下我们刚才所想的。新建了10个线程，每个线程先获取锁，然后调用condition.await方法释放锁将当前线程加入到等待队列中，通过debug控制当走到第10个线程的时候查看<code>firstWaiter</code>即等待队列中的头结点，debug模式下情景图如下：</li>
</ol>
<p><img src="/2019/11/08/xiang-jie-condition-de-await-he-signal-deng-dai-tong-zhi-ji-zhi/debug%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%83%85%E6%99%AF%E5%9B%BE.png" alt="debug模式下情景图"></p>
<p>从这个图我们可以很清楚的看到这样几点：1. 调用condition.await方法后线程依次尾插入到等待队列中，如图队列中的线程引用依次为Thread-0,Thread-1,Thread-2….Thread-8；2. 等待队列是一个单向队列。通过我们的猜想然后进行实验验证，我们可以得出等待队列的示意图如下图所示：</p>
<p><img src="/2019/11/08/xiang-jie-condition-de-await-he-signal-deng-dai-tong-zhi-ji-zhi/debug%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%83%85%E6%99%AF%E5%9B%BE.png" alt="等待队列的示意图"></p>
<p>同时还有一点需要注意的是：我们可以多次调用lock.newCondition()方法创建多个condition对象，也就是一个lock可以持有多个等待队列。而在之前利用Object的方式实际上是指在<strong>对象Object对象监视器上只能拥有一个同步队列和一个等待队列，而并发包中的Lock拥有一个同步队列和多个等待队列</strong>。示意图如下：</p>
<p><img src="/2019/11/08/xiang-jie-condition-de-await-he-signal-deng-dai-tong-zhi-ji-zhi/AQS%E6%8C%81%E6%9C%89%E5%A4%9A%E4%B8%AACondition.png" alt="AQS持有多个Condition.png"></p>
<p>如图所示，ConditionObject是AQS的内部类，因此每个ConditionObject能够访问到AQS提供的方法，相当于每个Condition都拥有所属同步器的引用。</p>
<h3 id="2-2-await实现原理"><a href="#2-2-await实现原理" class="headerlink" title="2.2 await实现原理"></a>2.2 await实现原理</h3><p><strong>当调用condition.await()方法后会使得当前获取lock的线程进入到等待队列，如果该线程能够从await()方法返回的话一定是该线程获取了与condition相关联的lock</strong>。接下来，我们还是从源码的角度去看，只有熟悉了源码的逻辑我们的理解才是最深的。await()方法源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 1. 将当前线程包装成Node，尾插入到等待队列中</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 2. 释放当前线程所占用的lock，在释放的过程中会唤醒同步队列中的下一个节点</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 3. 当前线程进入到等待状态</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 自旋等待获取到同步状态（即获取到lock）</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="comment">// 5. 处理被中断的情况</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码的主要逻辑<strong>请看注释</strong>，我们都知道<strong>当当前线程调用condition.await()方法后，会使得当前线程释放lock然后加入到等待队列中，直至被signal/signalAll后会使得当前线程从等待队列中移至到同步队列中去，直到获得了lock后才会从await方法返回，或者在等待时被中断会做中断处理</strong>。那么关于这个实现过程我们会有这样几个问题：1. 是怎样将当前线程添加到等待队列中去的？2.释放锁的过程？3.怎样才能从await方法退出？而这段代码的逻辑就是告诉我们这三个问题的答案。具体<strong>请看注释</strong>，在第1步中调用addConditionWaiter将当前线程添加到等待队列中，该方法源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将当前线程包装成Node</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//尾插入</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    <span class="comment">//更新lastWaiter</span></span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码就很容易理解了，将当前节点包装成Node，如果等待队列的firstWaiter为null的话（等待队列为空队列），则将firstWaiter指向当前的Node,否则，更新lastWaiter(尾节点)即可。就是<strong>通过尾插入的方式将当前线程封装的Node插入到等待队列中即可</strong>，同时可以看出等待队列是一个<strong>不带头结点的链式队列</strong>，之前我们学习AQS时知道同步队列<strong>是一个带头结点的链式队列</strong>，这是两者的一个区别。将当前节点插入到等待对列之后，会使当前线程释放lock，由fullyRelease方法实现，fullyRelease源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            <span class="comment">//成功释放同步状态</span></span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不成功释放同步状态抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码就很容易理解了，<strong>调用AQS的模板方法release方法释放AQS的同步状态并且唤醒在同步队列中头结点的后继节点引用的线程</strong>，如果释放成功则正常返回，若失败的话就抛出异常。到目前为止，这两段代码已经解决了前面的两个问题的答案了，还剩下第三个问题，怎样从await方法退出？现在回过头再来看await方法有这样一段逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    <span class="comment">// 3. 当前线程进入到等待状态</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然，当线程第一次调用condition.await()方法时，会进入到这个while()循环中，然后通过LockSupport.park(this)方法使得当前线程进入等待状态，那么要想退出这个await方法第一个前提条件自然而然的是要先退出这个while循环，出口就只剩下两个地方：<strong>1. 逻辑走到break退出while循环；2. while循环中的逻辑判断为false</strong>。再看代码出现第1种情况的条件是当前等待的线程被中断后代码会走到break退出，第二种情况是当前节点被移动到了同步队列中（即另外线程调用的condition的signal或者signalAll方法），while中逻辑判断为false后结束while循环。总结下，就是<strong>当前线程被中断或者调用condition.signal/condition.signalAll方法当前节点移动到了同步队列后</strong> ，这是当前线程退出await方法的前提条件。当退出while循环后就会调用<code>acquireQueued(node, savedState)</code>，这个方法在介绍AQS的底层实现时说过了，若感兴趣的话可以去<a href="http://njustwh2014.github.io/2019/11/05/shen-ru-li-jie-abstractqueuedsynchronizer-aqs/">看这篇文章</a>，该方法的作用是在<strong>自旋过程中线程不断尝试获取同步状态，直至成功（线程获取到lock）</strong>。这样也说明了<strong>退出await方法必须是已经获得了condition引用（关联）的lock</strong>。到目前为止，开头的三个问题我们通过阅读源码的方式已经完全找到了答案，也对await方法的理解加深。await方法示意图如下图：</p>
<p><img src="/2019/11/08/xiang-jie-condition-de-await-he-signal-deng-dai-tong-zhi-ji-zhi/await%E6%96%B9%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="await方法示意图"></p>
<p>如图，调用condition.await方法的线程必须是已经获得了lock，也就是当前线程是同步队列中的头结点。调用该方法后会使得当前线程所封装的Node尾插入到等待队列中。</p>
<blockquote>
<p>超时机制的支持</p>
</blockquote>
<p>condition还额外支持了超时机制，使用者可调用方法awaitNanos,awaitUtil。这两个方法的实现原理，基本上与AQS中的tryAcquire方法如出一辙，关于tryAcquire可以仔细阅读<a href="http://njustwh2014.github.io/2019/11/05/shen-ru-li-jie-abstractqueuedsynchronizer-aqs/">这篇文章的第3.4部分</a>。</p>
<blockquote>
<p>不响应中断的支持</p>
</blockquote>
<p>要想不响应中断可以调用condition.awaitUninterruptibly()方法，该方法的源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Node node = addConditionWaiter();</span><br><span class="line">	<span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">	<span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">		LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">			interrupted = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted)</span><br><span class="line">		selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段方法与上面的await方法基本一致，只不过减少了对中断的处理，并省略了reportInterruptAfterWait方法抛被中断的异常。</p>
<h3 id="2-3-signal-signalAll实现原理"><a href="#2-3-signal-signalAll实现原理" class="headerlink" title="2.3 signal/signalAll实现原理"></a>2.3 signal/signalAll实现原理</h3><p><strong>调用condition的signal或者signalAll方法可以将等待队列中等待时间最长的节点移动到同步队列中</strong>，使得该节点能够有机会获得lock。按照等待队列是先进先出（FIFO）的，所以等待队列的头节点必然会是等待时间最长的节点，也就是每次调用condition的signal方法是将头节点移动到同步队列中。我们来通过看源码的方式来看这样的猜想是不是对的，signal方法源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1. 先检测当前线程是否已经获取lock</span></span><br><span class="line">	<span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">	<span class="comment">//2. 获取等待队列中第一个节点，之后的操作都是针对这个节点</span></span><br><span class="line">	Node first = firstWaiter;</span><br><span class="line">	<span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">		doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>signal方法首先会检测当前线程是否已经获取lock，如果没有获取lock会直接抛出异常，如果获取的话再得到等待队列的头指针引用的节点，之后的操作的doSignal方法也是基于该节点。下面我们来看看doSignal方法做了些什么事情，doSignal方法源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">			lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//1. 将头结点从等待队列中移除</span></span><br><span class="line">		first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//2. while中transferForSignal方法对头结点做真正的处理</span></span><br><span class="line">	&#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">				(first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体逻辑请看注释，真正对头节点做处理的逻辑在<strong>transferForSignal</strong>放，该方法源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		* If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	<span class="comment">//1. 更新状态为0</span></span><br><span class="line">	<span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		* Splice onto queue and try to set waitStatus of predecessor to</span></span><br><span class="line"><span class="comment">		* indicate that thread is (probably) waiting. If cancelled or</span></span><br><span class="line"><span class="comment">		* attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">		* case the waitStatus can be transiently and harmlessly wrong).</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	<span class="comment">//2.将该节点移入到同步队列中去</span></span><br><span class="line">	Node p = enq(node);</span><br><span class="line">	<span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">	<span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">		LockSupport.unpark(node.thread);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键逻辑请看注释，这段代码主要做了两件事情1.将头结点的状态更改为CONDITION；2.调用enq方法，将该节点尾插入到同步队列中，关于enq方法请看AQS的底层实现这篇文章。现在我们可以得出结论：<strong>调用condition的signal的前提条件是当前线程已经获取了lock，该方法会使得等待队列中的头节点即等待时间最长的那个节点移入到同步队列，而移入到同步队列后才有机会使得等待线程被唤醒，即从await方法中的LockSupport.park(this)方法中返回，从而才有机会使得调用await方法的线程成功退出</strong>。signal执行示意图如下图：</p>
<p><img src="/2019/11/08/xiang-jie-condition-de-await-he-signal-deng-dai-tong-zhi-ji-zhi/signal%E6%89%A7%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="signal执行示意图"></p>
<blockquote>
<p>signalAll</p>
</blockquote>
<p>sigllAll与sigal方法的区别体现在doSignalAll方法上，前面我们已经知道<strong>doSignal方法只会对等待队列的头节点进行操作，</strong>，而doSignalAll的源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">	lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		Node next = first.nextWaiter;</span><br><span class="line">		first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">		transferForSignal(first);</span><br><span class="line">		first = next;</span><br><span class="line">	&#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法只不过时间等待队列中的每一个节点都移入到同步队列中，即“通知”当前调用condition.await()方法的每一个线程。</p>
<h2 id="3-await与signal-signalAll的结合思考"><a href="#3-await与signal-signalAll的结合思考" class="headerlink" title="3. await与signal/signalAll的结合思考"></a>3. await与signal/signalAll的结合思考</h2><p>文章开篇提到等待/通知机制，通过使用condition提供的await和signal/signalAll方法就可以实现这种机制，而这种机制能够解决最经典的问题就是“生产者与消费者问题”，关于“生产者消费者问题”之后会用单独的一篇文章进行讲解，这也是面试的高频考点。await和signal和signalAll方法就像一个开关控制着线程A（等待方）和线程B（通知方）。它们之间的关系可以用下面一个图来表现得更加贴切：</p>
<p><img src="/2019/11/08/xiang-jie-condition-de-await-he-signal-deng-dai-tong-zhi-ji-zhi/condition%E4%B8%8B%E7%9A%84%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6.png" alt="condition下的等待通知机制.png"></p>
<p>如图，<strong>线程awaitThread先通过lock.lock()方法获取锁成功后调用了condition.await方法进入等待队列，而另一个线程signalThread通过lock.lock()方法获取锁成功后调用了condition.signal或者signalAll方法，使得线程awaitThread能够有机会移入到同步队列中，当其他线程释放lock后使得线程awaitThread能够有机会获取lock，从而使得线程awaitThread能够从await方法中退出执行后续操作。如果awaitThread获取lock失败会直接进入到同步队列</strong>。</p>
<h2 id="4-一个例子"><a href="#4-一个例子" class="headerlink" title="4. 一个例子"></a>4. 一个例子</h2><p>我们用一个很简单的例子说说condition的用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwaitSignal</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread waiter = <span class="keyword">new</span> Thread(<span class="keyword">new</span> waiter());</span><br><span class="line">		waiter.start();</span><br><span class="line">		Thread signaler = <span class="keyword">new</span> Thread(<span class="keyword">new</span> signaler());</span><br><span class="line">		signaler.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">waiter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">"当前条件不满足等待"</span>);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						condition.await();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">"接收到通知条件满足"</span>);</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				lock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">signaler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				condition.signalAll();</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				lock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Thread-0当前条件不满足等待</span><br><span class="line">Thread-0接收到通知，条件满足</span><br></pre></td></tr></table></figure>
<p>开启了两个线程waiter和signaler，waiter线程开始执行的时候由于条件不满足，执行condition.await方法使该线程进入等待状态同时释放锁，signaler线程获取到锁之后更改条件，并通知所有的等待线程后释放锁。这时，waiter线程获取到锁，并由于signaler线程更改了条件此时相对于waiter来说条件满足，继续执行。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote>
<p>《java并发编程的艺术》</p>
</blockquote>
<blockquote>
<p><a href="https://github.com/njustwh2014/MyJavaRepo" target="_blank" rel="noopener">我的github项目，有一些代码示例</a> forked from <a href="https://github.com/CL0610/Java-concurrency" target="_blank" rel="noopener">https://github.com/CL0610/Java-concurrency</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Concurrent</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Concurrent</tag>
        <tag>AQS</tag>
        <tag>Lock</tag>
        <tag>Condition</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解读写锁ReentrantReadWriteLock</title>
    <url>/2019/11/08/shen-ru-li-jie-du-xie-suo-reentrantreadwritelock/</url>
    <content><![CDATA[<p><a href="https://github.com/njustwh2014/MyJavaRepo" target="_blank" rel="noopener">我的github项目，有一些代码示例</a> forked from <a href="https://github.com/CL0610/Java-concurrency" target="_blank" rel="noopener">https://github.com/CL0610/Java-concurrency</a></p>
<h2 id="1-读写锁的介绍"><a href="#1-读写锁的介绍" class="headerlink" title="1.读写锁的介绍"></a>1.读写锁的介绍</h2><p>在并发场景中用于解决线程安全的问题，我们几乎会高频率的使用到独占式锁，通常使用java提供的关键字synchronized或者concurrents包中实现了Lock接口的<a href="http://njustwh2014.github.io/2019/11/05/che-di-li-jie-reentrantlock/">ReentrantLock</a>。它们都是独占式获取锁，也就是在同一时刻只有一个线程能够获取锁。而在一些业务场景中，大部分只是读数据，写数据很少，如果仅仅是读数据的话并不会影响数据正确性（出现脏读），而如果在这种业务场景下，依然使用独占锁的话，很显然这将是出现<strong>性能瓶颈</strong>的地方。针对这种读多写少的情况，java还提供了另外一个实现Lock接口的ReentrantReadWriteLock(读写锁)。<strong>读写所允许同一时刻被多个读线程访问，但是在写线程访问时，所有的读线程和其他的写线程都会被阻塞</strong>。在分析WirteLock和ReadLock的互斥性时可以按照WriteLock与WriteLock之间，WriteLock与ReadLock之间以及ReadLock与ReadLock之间进行分析。更多关于读写锁特性介绍大家可以看源码上的介绍（阅读源码时最好的一种学习方式，我也正在学习中，与大家共勉），这里做一个归纳总结：</p>
<ol>
<li><strong>公平性选择</strong>：支持非公平性（默认）和公平的锁获取方式，吞吐量还是非公平优于公平；</li>
<li><strong>重入性</strong>：支持重入，读锁获取后能再次获取，写锁获取之后能够再次获取写锁，同时也能够获取读锁；</li>
<li><strong>锁降级</strong>：遵循获取写锁，获取读锁再释放写锁的次序，写锁能够降级成为读锁<a id="more"></a>
要想能够彻底的理解读写锁必须能够理解这样几个问题：</li>
<li>读写锁是怎样实现分别记录读写状态的？</li>
<li>写锁是怎样获取和释放的？</li>
<li>读锁是怎样获取和释放的？</li>
</ol>
<p>我们带着这样的三个问题，再去了解下读写锁。</p>
<h2 id="2-写锁详解"><a href="#2-写锁详解" class="headerlink" title="2.写锁详解"></a>2.写锁详解</h2><h3 id="2-1-写锁的获取"><a href="#2-1-写锁的获取" class="headerlink" title="2.1.写锁的获取"></a>2.1.写锁的获取</h3><p>同步组件的实现聚合了同步器（AQS），并通过重写重写同步器（AQS）中的方法实现同步组件的同步语义（关于同步组件的实现层级结构可以<a href="http://njustwh2014.github.io/2019/11/04/chu-shi-lock-he-abstractqueuedsynchronizer-aqs/">看这篇文章</a>，AQS的底层实现分析可以<a href="http://njustwh2014.github.io/2019/11/05/shen-ru-li-jie-abstractqueuedsynchronizer-aqs/">看这篇文章</a>）。因此，写锁的实现依然也是采用这种方式。在同一时刻写锁是不能被多个线程所获取，很显然<strong>写锁是独占式锁</strong>，而实现写锁的同步语义是通过重写AQS中的tryAcquire方法实现的。源码为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Walkthrough:</span></span><br><span class="line"><span class="comment">        * 1. If read count nonzero or write count nonzero</span></span><br><span class="line"><span class="comment">        *    and owner is a different thread, fail.</span></span><br><span class="line"><span class="comment">        * 2. If count would saturate, fail. (This can only</span></span><br><span class="line"><span class="comment">        *    happen if count is already nonzero.)</span></span><br><span class="line"><span class="comment">        * 3. Otherwise, this thread is eligible for lock if</span></span><br><span class="line"><span class="comment">        *    it is either a reentrant acquire or</span></span><br><span class="line"><span class="comment">        *    queue policy allows it. If so, update state</span></span><br><span class="line"><span class="comment">        *    and set owner.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 1. 获取写锁当前的同步状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 2. 获取写锁获取的次数</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="comment">// 3.1 当读锁已被读线程获取或者当前线程不是已经获取写锁的线程的话</span></span><br><span class="line">        <span class="comment">// 当前线程获取写锁失败</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">        <span class="comment">// 3.2 当前线程获取写锁，支持可重复加锁</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.3 写锁未被任何线程获取，当前线程可获取写锁</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的逻辑请看注释，这里有一个地方需要重点关注，exclusiveCount(c)方法，该方法源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure>
<p>其中<strong>EXCLUSIVE_MASK</strong>为:  <code>static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;</code>      EXCLUSIVE _MASK为1左移16位然后减1，即为0x0000FFFF。而exclusiveCount方法是将同步状态（state为int类型）与0x0000FFFF相与，即取同步状态的低16位。那么低16位代表什么呢？根据exclusiveCount方法的注释为独占式获取的次数即写锁被获取的次数，现在就可以得出来一个结论<strong>同步状态的低16位用来表示写锁的获取次数</strong>。同时还有一个方法值得我们注意：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br></pre></td></tr></table></figure>
<p>该方法是获取读锁被获取的次数，是将同步状态（int c）右移16次，即取同步状态的高16位，现在我们可以得出另外一个结论<strong>同步状态的高16位用来表示读锁被获取的次数</strong>。现在还记得我们开篇说的需要弄懂的第一个问题吗？读写锁是怎样实现分别记录读锁和写锁的状态的，现在这个问题的答案就已经被我们弄清楚了，其示意图如下图所示：</p>
<p><img src="/2019/11/08/shen-ru-li-jie-du-xie-suo-reentrantreadwritelock/%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E8%AF%BB%E5%86%99%E7%8A%B6%E6%80%81%E8%AE%BE%E8%AE%A1.png" alt="读写锁的读写状态设计.png"></p>
<p>现在我们回过头来看写锁获取方法tryAcquire，其主要逻辑为：<strong>当读锁已经被读线程获取或者写锁已经被其他写线程获取，则写锁获取失败；否则，获取成功并支持重入，增加写状态。</strong></p>
<h3 id="2-2-写锁的释放"><a href="#2-2-写锁的释放" class="headerlink" title="2.2.写锁的释放"></a>2.2.写锁的释放</h3><p>写锁释放通过重写AQS的tryRelease方法，源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">//1. 同步状态减去写状态</span></span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">    <span class="comment">//2. 当前写状态是否为0，为0则释放写锁</span></span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//3. 不为0则更新同步状态</span></span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码的实现逻辑请看注释，不难理解与ReentrantLock基本一致，这里需要注意的是，减少写状态<code>int nextc = getState() - releases;</code>只需要用<strong>当前同步状态直接减去写状态的原因正是我们刚才所说的写状态是由同步状态的低16位表示的</strong>。</p>
<h2 id="3-读锁详解"><a href="#3-读锁详解" class="headerlink" title="3.读锁详解"></a>3.读锁详解</h2><h3 id="3-1-读锁的获取"><a href="#3-1-读锁的获取" class="headerlink" title="3.1.读锁的获取"></a>3.1.读锁的获取</h3><p>看完了写锁，现在来看看读锁，读锁不是独占式锁，即同一时刻该锁可以被多个读线程获取也就是一种共享式锁。按照之前对AQS介绍，实现共享式同步组件的同步语义需要通过重写AQS的tryAcquireShared方法和tryReleaseShared方法。读锁的获取实现方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Walkthrough:</span></span><br><span class="line"><span class="comment">        * 1. If write lock held by another thread, fail.</span></span><br><span class="line"><span class="comment">        * 2. Otherwise, this thread is eligible for</span></span><br><span class="line"><span class="comment">        *    lock wrt state, so ask if it should block</span></span><br><span class="line"><span class="comment">        *    because of queue policy. If not, try</span></span><br><span class="line"><span class="comment">        *    to grant by CASing state and updating count.</span></span><br><span class="line"><span class="comment">        *    Note that step does not check for reentrant</span></span><br><span class="line"><span class="comment">        *    acquires, which is postponed to full version</span></span><br><span class="line"><span class="comment">        *    to avoid having to check hold count in</span></span><br><span class="line"><span class="comment">        *    the more typical non-reentrant case.</span></span><br><span class="line"><span class="comment">        * 3. If step 2 fails either because thread</span></span><br><span class="line"><span class="comment">        *    apparently not eligible or CAS fails or count</span></span><br><span class="line"><span class="comment">        *    saturated, chain to version with full retry loop.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//1. 如果写锁已经被获取并且获取写锁的线程不是当前线程的话，当前</span></span><br><span class="line">    <span class="comment">// 线程获取读锁失败返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        <span class="comment">//2. 当前线程获取读锁</span></span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="comment">//3. 下面的代码主要是新增的一些功能，比如getReadHoldCount()方法</span></span><br><span class="line">        <span class="comment">//返回当前获取读锁的次数</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. 处理在第二步中CAS操作失败的自旋已经实现重入性</span></span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的逻辑请看注释，需要注意的是  <strong>当写锁被其他线程获取后，读锁获取失败</strong>，否则获取成功利用CAS更新同步状态。另外，当前同步状态需要加上SHARED_UNIT（<code>(1 &lt;&lt; SHARED_SHIFT)</code>即0x00010000）的原因这是我们在上面所说的同步状态的高16位用来表示读锁被获取的次数。如果CAS失败或者已经获取读锁的线程再次获取读锁时，是靠fullTryAcquireShared方法实现的，这段代码就不展开说了，有兴趣可以看看。</p>
<h3 id="3-2-读锁的释放"><a href="#3-2-读锁的释放" class="headerlink" title="3.2.读锁的释放"></a>3.2.读锁的释放</h3><p>读锁释放的实现主要通过方法tryReleaseShared，源码如下，主要逻辑请看注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 前面还是为了实现getReadHoldCount等新功能</span></span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="keyword">int</span> count = rh.count;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 读锁释放 将同步状态减去读状态即可</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">            <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">            <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-锁降级"><a href="#4-锁降级" class="headerlink" title="4.锁降级"></a>4.锁降级</h2><p>读写锁支持锁降级，<strong>遵循按照获取写锁，获取读锁再释放写锁的次序，写锁能够降级成为读锁</strong>，不支持锁升级，关于锁降级下面的示例代码摘自ReentrantWriteReadLock源码中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">            <span class="comment">// Must release read lock before acquiring write lock</span></span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">            rwl.writeLock().lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck state because another thread might have</span></span><br><span class="line">                <span class="comment">// acquired write lock and changed state before we did.</span></span><br><span class="line">                <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">                    data = ...</span><br><span class="line">            cacheValid = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Downgrade by acquiring read lock before releasing write lock</span></span><br><span class="line">            rwl.readLock().lock();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwl.writeLock().unlock(); <span class="comment">// Unlock write, still hold read</span></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        use(data);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote>
<p>《java并发编程的艺术》</p>
</blockquote>
<blockquote>
<p><a href="https://github.com/njustwh2014/MyJavaRepo" target="_blank" rel="noopener">我的github项目，有一些代码示例</a> forked from <a href="https://github.com/CL0610/Java-concurrency" target="_blank" rel="noopener">https://github.com/CL0610/Java-concurrency</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Concurrent</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Concurrent</tag>
        <tag>AQS</tag>
        <tag>Lock</tag>
        <tag>Condition</tag>
      </tags>
  </entry>
  <entry>
    <title>从0开始使用ElasticSearch</title>
    <url>/2019/11/08/cong-0-kai-shi-shi-yong-elasticsearch/</url>
    <content><![CDATA[<h2 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h2><p><img src="http://pzpoejx7j.bkt.clouddn.com/systemstructure.png" alt="System structure"></p>
<ul>
<li>首先监测Backup文件夹，由于公司lab环境和office环境ping不通，我利用我在公司个人文件夹，监测Backup文件夹，当有新的文件传入，会复制到我的个人文件夹data内。<a id="more"></a>
<img src="/2019/11/08/cong-0-kai-shi-shi-yong-elasticsearch/backup%E6%88%AA%E5%9B%BE.png" alt="Backup截图"></li>
</ul>
<p><img src="/2019/11/08/cong-0-kai-shi-shi-yong-elasticsearch/data%E6%88%AA%E5%9B%BE.png" alt="Backup截图"></p>
<ul>
<li><p>同样原理，这时就可以进入lab环境开发，由于我一开始在windows上写的Java代码，所以是在windows上进行解压缩，解析，以及发送解析后的json文件到elasticsearch所在的centos服务器上，其实没必要这样，建议后面改为解压缩解析都在centos服务器上，当然更好的是在获得源文件时不需要压缩直接解析上传至elasticsearch.</p>
</li>
<li><p>我在Centos服务器上写了个脚本，当有json文件上传至服务器，就上传到elasticsearch</p>
</li>
</ul>
<h2 id="Java代码后期只需要修改配置文件即可"><a href="#Java代码后期只需要修改配置文件即可" class="headerlink" title="Java代码后期只需要修改配置文件即可"></a>Java代码后期只需要修改配置文件即可</h2><p><img src="/2019/11/08/cong-0-kai-shi-shi-yong-elasticsearch/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3.png" alt="配置文件详解"></p>
<h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><p>关于elk安装配置，在windows上总是会出现各种问题，这里我完全参考了这个<a href="https://www.howtoing.com/how-to-install-elasticsearch-logstash-and-kibana-elastic-stack-on-centos-7" target="_blank" rel="noopener">教程</a>在centos下进行安装配置。大家也可以跟着教程安装配置。</p>
<p>此次项目，我建立的索引如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X PUT <span class="string">"localhost:9200/acinfoindex?pretty"</span> -H <span class="string">'Content-Type: application/json'</span> -d<span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  "mappings":&#123;</span></span><br><span class="line"><span class="string">    "info":&#123;</span></span><br><span class="line"><span class="string">      "properties":&#123;</span></span><br><span class="line"><span class="string">        "AC":&#123;"type":"keyword"&#125;,</span></span><br><span class="line"><span class="string">        "GUID":&#123;"type":"keyword"&#125;,</span></span><br><span class="line"><span class="string">        "TIME":&#123;"type":"date",</span></span><br><span class="line"><span class="string">          "format": "epoch_second"</span></span><br><span class="line"><span class="string">          &#125;,</span></span><br><span class="line"><span class="string">        "CPUINFO":&#123;</span></span><br><span class="line"><span class="string">            "properties":&#123;</span></span><br><span class="line"><span class="string">                "auth_simp_n":&#123;"type": "integer"&#125;,</span></span><br><span class="line"><span class="string">                "auth_ntlm_n":&#123;"type": "integer"&#125;,</span></span><br><span class="line"><span class="string">                "th_inc":&#123;"type": "integer"&#125;,</span></span><br><span class="line"><span class="string">                "th_net_in_traffic":&#123;"type": "integer"&#125;,</span></span><br><span class="line"><span class="string">                "auth_krb5_n":&#123;"type": "integer"&#125;,</span></span><br><span class="line"><span class="string">                "usg_mem":&#123;"type": "integer"&#125;,</span></span><br><span class="line"><span class="string">                "th_net_out_traffic":&#123;"type": "integer"&#125;,</span></span><br><span class="line"><span class="string">                "auth_succ_n":&#123;"type": "integer"&#125;,</span></span><br><span class="line"><span class="string">                "usg_disk_io":&#123;"type": "integer"&#125;,</span></span><br><span class="line"><span class="string">                "th_inc_http2":&#123;"type": "integer"&#125;,</span></span><br><span class="line"><span class="string">                "th_inc_https":&#123;"type": "integer"&#125;,</span></span><br><span class="line"><span class="string">                "th_inc_http":&#123;"type": "integer"&#125;,</span></span><br><span class="line"><span class="string">                "auth_n":&#123;"type": "integer"&#125;,</span></span><br><span class="line"><span class="string">                "usg_cpu":&#123;"type": "integer"&#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">        &#125; </span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &#125;   </span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/08/cong-0-kai-shi-shi-yong-elasticsearch/%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3.png" alt="索引详解"></p>
<h2 id="上传数据至elasticsearch"><a href="#上传数据至elasticsearch" class="headerlink" title="上传数据至elasticsearch"></a>上传数据至elasticsearch</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pyinotify</span><br><span class="line"></span><br><span class="line">multi_event=pyinotify.IN_CREATE|pyinotify.IN_ACCESS|pyinotify.IN_CLOSE_WRITE</span><br><span class="line">wm=pyinotify.WatchManager()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEventHandler</span><span class="params">(pyinotify.ProcessEvent)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_IN_CREATE</span><span class="params">(self,event)</span>:</span></span><br><span class="line">        print(<span class="string">'CREATE'</span>,event.pathname)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">precess_IN_ACCESS</span><span class="params">(self,event)</span>:</span></span><br><span class="line">        print(<span class="string">'ACCESS'</span>,event.pathname)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_IN_CLOSE_WRITE</span><span class="params">(self,event)</span>:</span></span><br><span class="line">        print(<span class="string">'CLOSE_WRITE'</span>,event.pathname)</span><br><span class="line">        output = os.popen(<span class="string">"curl -H 'Content-Type: application/x-ndjson' -XPOST 'localhost:9200/acinfoindex/info/_bulk?pretty' --data-binary @"</span>+event.pathname)</span><br><span class="line"></span><br><span class="line">handler=MyEventHandler()</span><br><span class="line"></span><br><span class="line">notifier=pyinotify.Notifier(wm,handler)</span><br><span class="line"></span><br><span class="line">wm.add_watch(<span class="string">'/home/huanhuan/data'</span>,multi_event)</span><br><span class="line">notifier.loop()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/08/cong-0-kai-shi-shi-yong-elasticsearch/codepython.png" alt="重要就上传的一句话"></p>
<h2 id="如何在Kibana上查看我们上传的数据"><a href="#如何在Kibana上查看我们上传的数据" class="headerlink" title="如何在Kibana上查看我们上传的数据"></a>如何在Kibana上查看我们上传的数据</h2><blockquote>
<p>查看数据是否上传成功<br><img src="/2019/11/08/cong-0-kai-shi-shi-yong-elasticsearch/uploadsuccess.png" alt></p>
</blockquote>
<blockquote>
<p>建立Index Pattern<br><img src="/2019/11/08/cong-0-kai-shi-shi-yong-elasticsearch/indexstep1.png" alt><br><img src="/2019/11/08/cong-0-kai-shi-shi-yong-elasticsearch/indexstep2.png" alt><br><img src="/2019/11/08/cong-0-kai-shi-shi-yong-elasticsearch/indexstep3.png" alt></p>
</blockquote>
<blockquote>
<p>Discover中查看数据，大家以后检验数据是否正确，可以在这里搜索查看。<br><img src="/2019/11/08/cong-0-kai-shi-shi-yong-elasticsearch/indexstep4.png" alt></p>
</blockquote>
<h2 id="grafana"><a href="#grafana" class="headerlink" title="grafana"></a>grafana</h2><p><a href="https://www.aiprose.com/blog/26" target="_blank" rel="noopener">安装教程</a></p>
<p><a href="http://docs.flycloud.me/docs/ELKStack/elasticsearch/other/grafana.html" target="_blank" rel="noopener">官方教程</a></p>
<h3 id="添加datasource"><a href="#添加datasource" class="headerlink" title="添加datasource"></a>添加datasource</h3><p><img src="/2019/11/08/cong-0-kai-shi-shi-yong-elasticsearch/grafanadatasource1.png" alt></p>
<p>具体添加elasticsearch就不赘述了,<a href="http://docs.flycloud.me/docs/ELKStack/elasticsearch/other/grafana.html" target="_blank" rel="noopener">教程</a>中有。</p>
<h3 id="怎么在table中添加全局变量"><a href="#怎么在table中添加全局变量" class="headerlink" title="怎么在table中添加全局变量"></a>怎么在table中添加全局变量</h3><p><img src="/2019/11/08/cong-0-kai-shi-shi-yong-elasticsearch/grafanavar1.png" alt><br><img src="/2019/11/08/cong-0-kai-shi-shi-yong-elasticsearch/grafanavar2.png" alt><br><img src="/2019/11/08/cong-0-kai-shi-shi-yong-elasticsearch/grafanavar3.png" alt><br><img src="/2019/11/08/cong-0-kai-shi-shi-yong-elasticsearch/grafanavar4.png" alt></p>
<h3 id="怎么添加一个graph等等"><a href="#怎么添加一个graph等等" class="headerlink" title="怎么添加一个graph等等"></a>怎么添加一个graph等等</h3><p>参考<a href="http://docs.flycloud.me/docs/ELKStack/elasticsearch/other/grafana.html" target="_blank" rel="noopener">教程</a>。</p>
<blockquote>
<p>table<br><img src="/2019/11/08/cong-0-kai-shi-shi-yong-elasticsearch/grafanatable1.png" alt><br><img src="/2019/11/08/cong-0-kai-shi-shi-yong-elasticsearch/grafanatable2.png" alt></p>
</blockquote>
<blockquote>
<p>graph<br><img src="/2019/11/08/cong-0-kai-shi-shi-yong-elasticsearch/grafanagraph1.png" alt><br><img src="/2019/11/08/cong-0-kai-shi-shi-yong-elasticsearch/grafanagraph2.png" alt></p>
</blockquote>
]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>kibana</tag>
        <tag>grafana</tag>
        <tag>java</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>字节跳动后端实习面试记录</title>
    <url>/2019/11/08/zi-jie-tiao-dong-hou-duan-shi-xi-mian-shi-ji-lu/</url>
    <content><![CDATA[<p>心血来潮，在牛客网上给字节跳动投递了后端开发实习生，大概是近期太膨胀了吧，面试完还是我太菜了。害。。。。。<br><img src="http://pzpoejx7j.bkt.clouddn.com/%E5%A4%AA%E9%9A%BE%E4%BA%86.jpeg" alt></p>
<p>接下来就将这次面试和之前两次问题来个汇总吧。</p>
<a id="more"></a>
<h2 id="Java方面"><a href="#Java方面" class="headerlink" title="Java方面"></a>Java方面</h2><blockquote>
<p>StringBuilder和StringBuffer区别，两者的应用场景</p>
<p>JVM内存有哪几块</p>
<p>GC有哪几种方法</p>
<p>你是如何理解线程安全的</p>
</blockquote>
<h2 id="计算机方面"><a href="#计算机方面" class="headerlink" title="计算机方面"></a>计算机方面</h2><blockquote>
<p>堆和栈哪个快，为什么</p>
<p>什么是虚拟内存</p>
</blockquote>
<h2 id="操作系统方面"><a href="#操作系统方面" class="headerlink" title="操作系统方面"></a>操作系统方面</h2><blockquote>
<p>linux常用指令，如磁盘占用，CPU占用等(趋势科技)</p>
<p>docker的网络模式，以及docker如何访问其他容器，使用主机网络(亚信科技)</p>
</blockquote>
<h2 id="数据库方面"><a href="#数据库方面" class="headerlink" title="数据库方面"></a>数据库方面</h2><blockquote>
<p>redis都有哪些数据类型</p>
<p>pipeline有什么用</p>
<p>redis如何实现主从一致</p>
<p>redis为什么快(亚信科技)</p>
<p>mysql的索引是什么</p>
<p>mysql的存储引擎</p>
<p>为什么要用树</p>
<p>B+树和B树的区别</p>
</blockquote>
<h2 id="计算机网络方面"><a href="#计算机网络方面" class="headerlink" title="计算机网络方面"></a>计算机网络方面</h2><blockquote>
<p>说说TCP的三次握手和四次挥手吧</p>
<p>解释timewait</p>
<p>如何对一个网站进行性能测试，你认为一个网站性能瓶颈在哪些方面(趋势科技)</p>
</blockquote>
<h2 id="数据结构编程问题"><a href="#数据结构编程问题" class="headerlink" title="数据结构编程问题"></a>数据结构编程问题</h2><blockquote>
<p>给定一个有序数组，对其平方后去重，返回元素个数。如：[1,1,2,2]-&gt;2;[-1,1,2,2]-&gt;2</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实考虑到我是投递实习岗位，问的已经很基础了，但由于平时学习，都过于浮于表面，对于问题没有深究，很多问题都只能回答个大概，面试官细问下只能说还不了解，希望接下来学习，<strong>多注意实现原理，多去比较不同实现的原因和应用场景</strong></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>彻底理解ReentrantLock</title>
    <url>/2019/11/05/che-di-li-jie-reentrantlock/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://github.com/njustwh2014/MyJavaRepo" target="_blank" rel="noopener">我的github项目，有一些代码示例</a> forked from <a href="https://github.com/CL0610/Java-concurrency" target="_blank" rel="noopener">https://github.com/CL0610/Java-concurrency</a></p>
</blockquote>
<h2 id="1-ReentrantLock的介绍"><a href="#1-ReentrantLock的介绍" class="headerlink" title="1. ReentrantLock的介绍"></a>1. ReentrantLock的介绍</h2><p>ReentrantLock重入锁，是实现Lock接口的一个类，也是在实际编程中使用频率很高的一个锁，<strong>支持重入性，表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞</strong>。在java关键字synchronized隐式支持重入性，synchronized通过获取自增，释放自减的方式实现重入。与此同时，ReentrantLock还支持<strong>公平锁和非公平锁</strong>两种方式。那么，要想完完全全的弄懂ReentrantLock的话，主要也就是ReentrantLock同步语义的学习：1. 重入性的实现原理；2. 公平锁和非公平锁。</p>
<a id="more"></a>
<h2 id="2-重入性的实现原理"><a href="#2-重入性的实现原理" class="headerlink" title="2. 重入性的实现原理"></a>2. 重入性的实现原理</h2><p>要想支持重入性，就要解决两个问题：<strong>1. 在线程获取锁的时候，如果已经获取锁的线程是当前线程的话则直接再次获取成功；2. 由于锁会被获取n次，那么只有锁在被释放同样的n次之后，该锁才算是完全释放成功</strong>。通过<a href="http://njustwh2014.github.io/2019/11/05/shen-ru-li-jie-abstractqueuedsynchronizer-aqs/">这篇文章</a>，我们知道，同步组件主要是通过重写AQS的几个protected方法来表达自己的同步语义。针对第一个问题，我们来看看ReentrantLock是怎样实现的，以非公平锁为例，判断当前线程能否获得锁为例，核心方法为nonfairTryAcquire：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//1. 如果该锁未被任何线程占有，该锁能被当前线程获取</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.若被占有，检查占有线程是否是当前线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 3. 再次获取，计数加一</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的逻辑也很简单，具体请看注释。为了支持重入性，在第二步增加了处理逻辑，如果该锁已经被线程所占有了，会继续检查占有线程是否为当前线程，如果是的话，同步状态加1返回true，表示可以再次获取成功。每次重新获取都会对同步状态进行加一的操作，那么释放的时候处理思路是怎样的了？（依然还是以非公平锁为例）核心方法为tryRelease：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 同步状态减1</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//2. 只有当同步状态为0时，锁成功被释放，返回true</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 锁未被完全释放，返回false</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的逻辑请看注释，需要注意的是，重入锁的释放必须得等到同步状态为0时锁才算成功释放，否则锁仍未释放。如果锁被获取n次，释放了n-1次，该锁未完全释放返回false，只有被释放n次才算成功释放，返回true。到现在我们可以理清ReentrantLock重入性的实现了，也就是理解了同步语义的第一条。</p>
<h2 id="3-公平锁与非公平锁"><a href="#3-公平锁与非公平锁" class="headerlink" title="3. 公平锁与非公平锁"></a>3. 公平锁与非公平锁</h2><p>ReentrantLock支持两种锁：<strong>公平锁</strong>和<strong>非公平锁</strong>。<strong>何谓公平性，是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求上的绝对时间顺序，满足FIFO</strong>。ReentrantLock的构造方法无参时是构造非公平锁，源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外还提供了另外一种方式，可传入一个boolean值，true时为公平锁，false时为非公平锁，源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面非公平锁获取时（nonfairTryAcquire方法）只是简单的获取了一下当前状态做了一些逻辑处理，并没有考虑到当前同步队列中线程等待的情况。我们来看看公平锁的处理逻辑是怎样的，核心方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的逻辑与nonfairTryAcquire基本上一直，唯一的不同在于增加了hasQueuedPredecessors的逻辑判断，方法名就可知道该方法用来判断当前节点在同步队列中是否有前驱节点的判断，如果有前驱节点说明有线程比当前线程更早的请求资源，根据公平性，当前线程请求资源失败。如果当前节点没有前驱节点的话，再才有做后面的逻辑判断的必要性。<strong>公平锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁则不一定，有可能刚释放锁的线程能再次获取到锁</strong>。</p>
<blockquote>
<p><strong>公平锁  VS  非公平锁</strong></p>
</blockquote>
<ol>
<li><p>公平锁每次获取到锁为同步队列中的第一个节点，<strong>保证请求资源时间上的绝对顺序</strong>，而非公平锁有可能刚释放锁的线程下次继续获取该锁，则有可能导致其他线程永远无法获取到锁，<strong>造成“饥饿”现象</strong>。</p>
</li>
<li><p>公平锁为了保证时间上的绝对顺序，需要频繁的上下文切换，而非公平锁会降低一定的上下文切换，降低性能开销。因此，ReentrantLock默认选择的是非公平锁，则是为了减少一部分上下文切换，<strong>保证了系统更大的吞吐量</strong>。</p>
</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote>
<p>《java并发编程的艺术》</p>
</blockquote>
<blockquote>
<p><a href="https://github.com/njustwh2014/MyJavaRepo" target="_blank" rel="noopener">我的github项目，有一些代码示例</a> forked from <a href="https://github.com/CL0610/Java-concurrency" target="_blank" rel="noopener">https://github.com/CL0610/Java-concurrency</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Concurrent</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Concurrent</tag>
        <tag>AQS</tag>
        <tag>Lock</tag>
        <tag>Condition</tag>
        <tag>ReentrantLock</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解AbstractQueuedSynchronizer(AQS)</title>
    <url>/2019/11/05/shen-ru-li-jie-abstractqueuedsynchronizer-aqs/</url>
    <content><![CDATA[<p><a href="https://github.com/njustwh2014/MyJavaRepo" target="_blank" rel="noopener">我的github项目，有一些代码示例</a> forked from <a href="https://github.com/CL0610/Java-concurrency" target="_blank" rel="noopener">https://github.com/CL0610/Java-concurrency</a></p>
<h2 id="1-AQS简介"><a href="#1-AQS简介" class="headerlink" title="1. AQS简介"></a>1. AQS简介</h2><p>在<a href="http://njustwh2014.github.io/2019/11/04/chu-shi-lock-he-abstractqueuedsynchronizer-aqs/">上一篇文章</a>中我们对lock和AbstractQueuedSynchronizer(AQS)有了初步的认识。在同步组件的实现中，AQS是核心部分，同步组件的实现者通过使用AQS提供的模板方法实现同步组件语义，AQS则实现了对<strong>同步状态的管理，以及对阻塞线程进行排队，等待通知</strong>等等一些底层的实现处理。AQS的核心也包括了这些方面:<strong>同步队列，独占式锁的获取和释放，共享锁的获取和释放以及可中断锁，超时等待锁获取这些特性的实现</strong>，而这些实际上则是AQS提供出来的模板方法，归纳整理如下：</p>
<a id="more"></a>
<p><strong>独占式锁：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span><span class="comment">//独占式获取同步状态，如果获取失败则插入同步队列进行等待；</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span><span class="comment">//与acquire方法相同，但在同步队列中进行等待的时候可以检测中断；</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span><span class="comment">//在acquireInterruptibly基础上增加了超时等待功能，在超时时间内没有获得同步状态返回false;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span><span class="comment">//释放同步状态，该方法会唤醒在同步队列中的下一个节点</span></span></span><br></pre></td></tr></table></figure>
<p><strong>共享式锁：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span><span class="comment">//共享式获取同步状态，与独占式的区别在于同一时刻有多个线程获取同步状态；</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span><span class="comment">//在acquireShared方法基础上增加了能响应中断的功能；</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span><span class="comment">//在acquireSharedInterruptibly基础上增加了超时等待的功能；</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span><span class="comment">//共享式释放同步状态</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>tips: <a href="https://blog.csdn.net/wojiushiwo945you/article/details/42292999" target="_blank" rel="noopener">共享式锁与独占式锁</a></p>
</blockquote>
<p>要想掌握AQS的底层实现，其实也就是对这些模板方法的逻辑进行学习。在学习这些模板方法之前，我们得首先了解下AQS中的同步队列是一种什么样的数据结构，因为同步队列是AQS对同步状态的管理的基石。</p>
<h2 id="2-同步队列"><a href="#2-同步队列" class="headerlink" title="2. 同步队列"></a>2. 同步队列</h2><p>当共享资源被某个线程占有，其他请求该资源的线程将会阻塞，从而进入同步队列。就数据结构而言，队列的实现方式无外乎两者一是通过数组的形式，另外一种则是链表的形式。AQS中的同步队列则是<strong>通过链式方式</strong>进行实现。接下来，很显然我们至少会抱有这样的疑问：<strong>1. 节点的数据结构是什么样的？2. 是单向还是双向？3. 是带头结点的还是不带头节点的</strong>?我们依旧先是通过看源码的方式。</p>
<p>在AQS有一个静态内部类Node，其中有这样一些属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus <span class="comment">//节点状态</span></span><br><span class="line"><span class="keyword">volatile</span> Node prev <span class="comment">//当前节点/线程的前驱节点</span></span><br><span class="line"><span class="keyword">volatile</span> Node next; <span class="comment">//当前节点/线程的后继节点</span></span><br><span class="line"><span class="keyword">volatile</span> Thread thread;<span class="comment">//加入同步队列的线程引用</span></span><br><span class="line">Node nextWaiter;<span class="comment">//等待队列中的下一个节点</span></span><br></pre></td></tr></table></figure>
<p>节点的状态有以下这些：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> CANCELLED =  <span class="number">1</span><span class="comment">//节点从同步队列中取消</span></span><br><span class="line"><span class="keyword">int</span> SIGNAL    = -<span class="number">1</span><span class="comment">//后继节点的线程处于等待状态，如果当前节点释放同步状态会通知后继节点，使得后继节点的线程能够运行；</span></span><br><span class="line"><span class="keyword">int</span> CONDITION = -<span class="number">2</span><span class="comment">//当前节点进入等待队列中</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATE = -<span class="number">3</span><span class="comment">//表示下一次共享式同步状态获取将会无条件传播下去</span></span><br><span class="line"><span class="keyword">int</span> INITIAL = <span class="number">0</span>;<span class="comment">//初始状态</span></span><br></pre></td></tr></table></figure>
<p>现在我们知道了节点的数据结构类型，并且每个节点拥有其前驱和后继节点，很显然这是<strong>一个双向队列</strong>。同样的我们可以用一段demo看一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">				lock.lock();</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">					lock.unlock();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			thread.start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例代码中开启了5个线程，先获取锁之后再睡眠10S中，实际上这里让线程睡眠是想模拟出当线程无法获取锁时进入同步队列的情况。通过debug，当Thread-4（在本例中最后一个线程）获取锁失败后进入同步时，AQS时现在的同步队列如图所示：</p>
<p><img src="/2019/11/05/shen-ru-li-jie-abstractqueuedsynchronizer-aqs/LockDemo-debug.png" alt="LockDemo debug"></p>
<p>Thread-0先获得锁后进行睡眠，其他线程（Thread-1,Thread-2,Thread-3,Thread-4）获取锁失败进入同步队列，同时也可以很清楚的看出来每个节点有两个域：prev(前驱)和next(后继)，并且每个节点用来保存获取同步状态失败的线程引用以及等待状态等信息。另外AQS中有两个重要的成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br></pre></td></tr></table></figure>
<p>也就是说AQS实际上通过头尾指针来管理同步队列，同时实现包括获取锁失败的线程进行入队，释放锁时对同步队列中的线程进行通知等核心方法。其示意图如下：</p>
<p><img src="/2019/11/05/shen-ru-li-jie-abstractqueuedsynchronizer-aqs/%E9%98%9F%E5%88%97%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="队列示意图.png"></p>
<p>通过对源码的理解以及做实验的方式，现在我们可以清楚的知道这样几点：</p>
<ol>
<li><strong>节点的数据结构，即AQS的静态内部类Node,节点的等待状态等信息</strong>；</li>
<li><strong>同步队列是一个双向队列，AQS通过持有头尾指针管理同步队列</strong>；</li>
</ol>
<p>那么，节点如何进行入队和出队是怎样做的了？实际上这对应着锁的获取和释放两个操作：获取锁失败进行入队操作，获取锁成功进行出队操作。</p>
<h2 id="3-独占锁"><a href="#3-独占锁" class="headerlink" title="3. 独占锁"></a>3. 独占锁</h2><h3 id="3-1-独占锁的获取（acquire方法）"><a href="#3-1-独占锁的获取（acquire方法）" class="headerlink" title="3.1 独占锁的获取（acquire方法）"></a>3.1 独占锁的获取（acquire方法）</h3><p>我们继续通过看源码和debug的方式来看，还是以上面的demo为例，调用lock()方法是获取独占式锁，获取失败就将当前线程加入同步队列，成功则线程执行。而lock()方法实际上会调用AQS的<strong>acquire()</strong>方法，源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先看同步状态是否获取成功，如果成功则方法结束返回</span></span><br><span class="line">        <span class="comment">//若失败则先调用addWaiter()方法再调用acquireQueued()方法</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键信息请看注释，acquire根据当前获得同步状态成功与否做了两件事情：1. 成功，则方法结束返回，2. 失败，则先调用addWaiter()然后在调用acquireQueued()方法。</p>
<blockquote>
<p><strong>获取同步状态失败，入队操作</strong></p>
</blockquote>
<p>当线程获取独占式锁失败后就会将当前线程加入同步队列，那么加入队列的方式是怎样的了？我们接下来就应该去研究一下addWaiter()和acquireQueued()。addWaiter()源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 将当前线程构建成Node类型</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        <span class="comment">// 2. 当前尾节点是否为null？</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.2 将当前节点尾插入的方式插入同步队列中</span></span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.1. 当前同步队列尾节点为null，说明当前线程是第一个加入同步队列进行等待的线程</span></span><br><span class="line">        <span class="comment">// 或者存在并发，导致CAS失败，自旋尝试CAS</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析可以看上面的注释。程序的逻辑主要分为两个部分：<strong>1. 当前同步队列的尾节点为null，调用方法enq()插入;2. 当前队列的尾节点不为null，则采用尾插入（compareAndSetTail（）方法）的方式入队。</strong>另外还会有另外一个问题：如果 <code>if (compareAndSetTail(pred, node))</code>为false怎么办？会继续执行到enq()方法，同时很明显compareAndSetTail是一个CAS操作，通常来说如果CAS操作失败会继续自旋（死循环）进行重试。因此，经过我们这样的分析，enq()方法可能承担两个任务：<strong>1. 处理当前同步队列尾节点为null时进行入队操作；2. 如果CAS尾插入节点失败后负责自旋进行尝试。</strong>那么是不是真的就像我们分析的一样了？只有源码会告诉我们答案:),enq()源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="comment">//1. 构造头结点</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 2. 尾插入，CAS操作失败自旋尝试</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的分析中我们可以看出在第1步中会先创建头结点，说明同步队列是<strong>带头结点的链式存储结构</strong>。带头结点与不带头结点相比，会在入队和出队的操作中获得更大的便捷性，因此同步队列选择了带头结点的链式存储结构。那么带头节点的队列初始化时机是什么？自然而然是在<strong>tail为null时，即当前线程是第一次插入同步队列</strong>。compareAndSetTail(t, node)方法会利用CAS操作设置尾节点，如果CAS操作失败会在<code>for (;;)</code>for死循环中不断尝试，直至成功return返回为止。因此，对enq()方法可以做这样的总结：</p>
<ol>
<li><strong>在当前线程是第一个加入同步队列时，调用compareAndSetHead(new Node())方法，完成链式队列的头结点的初始化</strong>；</li>
<li><strong>自旋不断尝试CAS尾插入节点直至成功为止</strong>。</li>
</ol>
<p>现在我们已经很清楚获取独占式锁失败的线程包装成Node然后插入同步队列的过程了？那么紧接着会有下一个问题？在同步队列中的节点（线程）会做什么事情了来保证自己能够有机会获得独占式锁了？带着这样的问题我们就来看看acquireQueued()方法，从方法名就可以很清楚，这个方法的作用就是排队获取锁的过程，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 1. 获得当前节点的先驱节点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">// 2. 当前节点能否获取独占式锁					</span></span><br><span class="line">                <span class="comment">// 2.1 如果当前节点的先驱节点是头结点并且成功获取同步状态，即可以获得独占式锁</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    <span class="comment">//队列头指针用指向当前节点</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    <span class="comment">//释放前驱节点</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 2.2 获取锁失败，线程进入等待状态等待获取独占式锁</span></span><br><span class="line">                <span class="comment">/*当前节点不是第二个节点 或者 再次获取锁失败*/</span></span><br><span class="line">                <span class="comment">/*判断是否需要挂起，在挂起后，判断线程是否中断*/</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序逻辑通过注释已经标出，整体来看这又是一个<strong>自旋</strong>的过程（for (;;)），代码首先获取当前节点的先驱节点，<strong>如果先驱节点是头结点的并且成功获得同步状态的时候（if (p == head &amp;&amp; tryAcquire(arg))），当前节点所指向的线程能够获取锁</strong>。反之，获取锁失败进入等待状态。整体示意图为下图：</p>
<p><img src="/2019/11/05/shen-ru-li-jie-abstractqueuedsynchronizer-aqs/%E8%87%AA%E6%97%8B%E8%8E%B7%E5%8F%96%E9%94%81%E6%95%B4%E4%BD%93%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="自旋获取锁整体示意图.png"></p>
<blockquote>
<p><strong>获取锁成功，出队操作</strong></p>
</blockquote>
<p>获取锁的节点出队的逻辑是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队列头结点引用指向当前节点</span></span><br><span class="line">setHead(node);</span><br><span class="line"><span class="comment">//释放前驱节点</span></span><br><span class="line">p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">failed = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> interrupted;</span><br></pre></td></tr></table></figure>
<p>setHead()方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        head = node;</span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line">        node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将当前节点通过setHead()方法设置为队列的头结点，然后将之前的头结点的next域设置为null并且pre域也为null，即与队列断开，无任何引用方便GC时能够将内存进行回收。示意图如下：</p>
<p><img src="/2019/11/05/shen-ru-li-jie-abstractqueuedsynchronizer-aqs/%E5%BD%93%E5%89%8D%E8%8A%82%E7%82%B9%E5%BC%95%E7%94%A8%E7%BA%BF%E7%A8%8B%E8%8E%B7%E5%8F%96%E9%94%81%EF%BC%8C%E5%BD%93%E5%89%8D%E8%8A%82%E7%82%B9%E8%AE%BE%E7%BD%AE%E4%B8%BA%E9%98%9F%E5%88%97%E5%A4%B4%E7%BB%93%E7%82%B9.png" alt="当前节点引用线程获取锁，当前节点设置为队列头结点.png"></p>
<p>那么当获取锁失败的时候会调用shouldParkAfterFailedAcquire()方法和parkAndCheckInterrupt()方法，判断此时是否能够安全的挂起。shouldParkAfterFailedAcquire()方法源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 当前节点已经被设置为等待唤醒的状态，可以安全的挂起了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 当前节点node的前任节点被取消，那么【跳过】这些取消的节点，</span></span><br><span class="line"><span class="comment">         * 当跳过之后，重新尝试获取锁</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过前面的判断，waitStatus一定不是 SIGNAL 或 CANCELLED。</span></span><br><span class="line"><span class="comment">         * 推断出一定是 0 or PROPAGATE</span></span><br><span class="line"><span class="comment">         * 调用者需要再次尝试，在挂起之前能不能获取到锁，</span></span><br><span class="line"><span class="comment">         * 因此，将当前pred的状态设为SIGNAL，再次尝试获取锁之后，如果还没有得到锁那么挂起</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>shouldParkAfterFailedAcquire()方法主要逻辑是使用<code>compareAndSetWaitStatus(pred, ws, Node.SIGNAL)</code>使用CAS将节点状态由INITIAL设置成SIGNAL，表示当前线程阻塞。当compareAndSetWaitStatus设置失败则说明shouldParkAfterFailedAcquire方法返回false，然后会在acquireQueued()方法中for (;;)死循环中会继续重试，直至compareAndSetWaitStatus设置节点状态位为SIGNAL时shouldParkAfterFailedAcquire返回true时才会执行方法parkAndCheckInterrupt()方法，该方法的源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使得该线程阻塞</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的关键是会调用LookSupport.park()方法（关于LookSupport会在以后的文章进行讨论），该方法是用来阻塞当前线程的。因此到这里就应该清楚了，acquireQueued()在自旋过程中主要完成了两件事情：</p>
<ol>
<li><strong>如果当前节点的前驱节点是头节点，并且能够获得同步状态的话，当前线程能够获得锁该方法执行结束退出</strong>；</li>
<li><strong>获取锁失败的话，先将节点状态设置成SIGNAL，然后调用LookSupport.park方法使得当前线程阻塞</strong>。</li>
</ol>
<p>经过上面的分析，独占式锁的获取过程也就是acquire()方法的执行流程如下图所示：</p>
<p><img src="/2019/11/05/shen-ru-li-jie-abstractqueuedsynchronizer-aqs/%E7%8B%AC%E5%8D%A0%E5%BC%8F%E9%94%81%E8%8E%B7%E5%8F%96%EF%BC%88acquire()%E6%96%B9%E6%B3%95%EF%BC%89%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="独占式锁获取（acquire()方法）流程图.png"></p>
<h3 id="3-2-独占锁的释放（release-方法）"><a href="#3-2-独占锁的释放（release-方法）" class="headerlink" title="3.2 独占锁的释放（release()方法）"></a>3.2 独占锁的释放（release()方法）</h3><p>独占锁的释放就相对来说比较容易理解了，废话不多说先来看下源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">//如果【释放的线程】和【获取锁的线程】不是同一个，抛出非法监视器状态异常。</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 因为是重入的关系，不是每次释放锁c都等于0，</span></span><br><span class="line">    <span class="comment">// 直到最后一次释放锁时，才通知AQS不需要再记录哪个线程正在获取锁。</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码逻辑就比较容易理解了，如果同步状态释放成功（tryRelease返回true）则会执行if块中的代码，当head指向的头结点不为null，并且该节点的状态值不为0的话才会执行unparkSuccessor()方法。unparkSuccessor方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">        * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">        * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">         <span class="comment">/*如果状态为负（SIGNAL、PROPAGATE），那么清除其状态</span></span><br><span class="line"><span class="comment">        * 如果失败，或者状态被其他等待线程改变，也没有关系</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">        * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">        * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">        * non-cancelled successor.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 一般情况下唤醒的线程是【头结点】的【下一个节点】</span></span><br><span class="line"><span class="comment">     * 但是如果该节点被取消或者为null，</span></span><br><span class="line"><span class="comment">     * 那么需要【从后往前遍历】寻找一个【最早的】并且【没有被取消】的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//头节点的后继节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//后继节点不为null时唤醒该线程</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码的关键信息请看注释，首先获取头节点的后继节点，当后继节点的时候会调用LookSupport.unpark()方法，该方法会唤醒该节点的后继节点所包装的线程。因此，<strong>每一次锁释放后就会唤醒队列中该节点的后继节点所引用的线程，从而进一步可以佐证获得锁的过程是一个FIFO（先进先出）的过程。</strong></p>
<p>到现在我们终于啃下了一块硬骨头了，通过学习源码的方式非常深刻的学习到了独占式锁的获取和释放的过程以及同步队列。可以做一下总结：</p>
<ol>
<li><strong>线程获取锁失败，线程被封装成Node进行入队操作，核心方法在于addWaiter()和enq()，同时enq()完成对同步队列的头结点初始化工作以及CAS操作失败的重试</strong>;</li>
<li><strong>线程获取锁是一个自旋的过程，当且仅当 当前节点的前驱节点是头结点并且成功获得同步状态时，节点出队即该节点引用的线程获得锁，否则，当不满足条件时就会调用LookSupport.park()方法使得线程阻塞</strong>；</li>
<li><strong>释放锁的时候会唤醒后继节点；</strong></li>
</ol>
<p>总体来说：<strong>在获取同步状态时，AQS维护一个同步队列，获取同步状态失败的线程会加入到队列中进行自旋；移除队列（或停止自旋）的条件是前驱节点是头结点并且成功获得了同步状态。在释放同步状态时，同步器会调用unparkSuccessor()方法唤醒后继节点。</strong></p>
<blockquote>
<p><strong>独占锁特性学习</strong></p>
</blockquote>
<h3 id="3-3-可中断式获取锁（acquireInterruptibly方法）"><a href="#3-3-可中断式获取锁（acquireInterruptibly方法）" class="headerlink" title="3.3 可中断式获取锁（acquireInterruptibly方法）"></a>3.3 可中断式获取锁（acquireInterruptibly方法）</h3><p>我们知道lock相较于synchronized有一些更方便的特性，比如<strong>能响应中断以及超时等待等特性</strong>，现在我们依旧采用通过学习源码的方式来看看能够响应中断是怎么实现的。可响应中断式锁可调用方法lock.lockInterruptibly();而该方法其底层会调用AQS的acquireInterruptibly方法，源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        <span class="comment">//线程获取锁失败</span></span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在获取同步状态失败后就会调用doAcquireInterruptibly方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//将节点插入到同步队列中</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//获取锁出队</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">//线程中断抛异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键信息请看注释，现在看这段代码就很轻松了吧:),与acquire方法逻辑几乎一致，唯一的区别是当<strong>parkAndCheckInterrupt</strong>返回true时即线程阻塞时该线程被中断，代码抛出被中断异常。</p>
<h3 id="3-4-超时等待式获取锁（tryAcquireNanos-方法）"><a href="#3-4-超时等待式获取锁（tryAcquireNanos-方法）" class="headerlink" title="3.4 超时等待式获取锁（tryAcquireNanos()方法）"></a>3.4 超时等待式获取锁（tryAcquireNanos()方法）</h3><p>通过调用lock.tryLock(timeout,TimeUnit)方式达到超时等待获取锁的效果，该方法会在三种情况下才会返回：</p>
<ol>
<li>在超时时间内，当前线程成功获取了锁；</li>
<li>当前线程在超时时间内被中断；</li>
<li>超时时间结束，仍未获得锁返回false。</li>
</ol>
<p>我们仍然通过采取阅读源码的方式来学习底层具体是怎么实现的，该方法会调用AQS的方法tryAcquireNanos(),源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        <span class="comment">//实现超时等待的效果</span></span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很显然这段源码最终是靠doAcquireNanos方法实现超时等待的效果，该方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//1. 根据超时时间和当前时间计算出截止时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//2. 当前线程获得锁出队列</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3.1 重新计算超时时间</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="comment">// 3.2 已经超时返回false</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 3.3 线程阻塞等待 </span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="comment">// 3.4 线程被中断抛出被中断异常</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>程序逻辑如图所示：</p>
<p><img src="/2019/11/05/shen-ru-li-jie-abstractqueuedsynchronizer-aqs/%E8%B6%85%E6%97%B6%E7%AD%89%E5%BE%85%E5%BC%8F%E8%8E%B7%E5%8F%96%E9%94%81%EF%BC%88doAcquireNanos()%E6%96%B9%E6%B3%95%EF%BC%89.png" alt="超时等待式获取锁（doAcquireNanos()方法）"></p>
<p>程序逻辑同独占锁可响应中断式获取基本一致，唯一的不同在于获取锁失败后，对超时时间的处理上，在第1步会先计算出按照现在时间和超时时间计算出理论上的截止时间，比如当前时间是8h10min,超时时间是10min，那么根据<code>deadline = System.nanoTime() + nanosTimeout</code>计算出刚好达到超时时间时的系统时间就是8h 10min+10min = 8h 20min。然后根据<code>deadline - System.nanoTime()</code>就可以判断是否已经超时了，比如，当前系统时间是8h 30min很明显已经超过了理论上的系统时间8h 20min，<code>deadline - System.nanoTime()</code>计算出来就是一个负数，自然而然会在3.2步中的If判断之间返回false。如果还没有超时即3.2步中的if判断为true时就会继续执行3.3步通过<strong>LockSupport.parkNanos</strong>使得当前线程阻塞，同时在3.4步增加了对中断的检测，若检测出被中断直接抛出被中断异常。</p>
<h2 id="4-共享锁"><a href="#4-共享锁" class="headerlink" title="4. 共享锁"></a>4. 共享锁</h2><h3 id="4-1-共享锁的获取（acquireShared-方法）"><a href="#4-1-共享锁的获取（acquireShared-方法）" class="headerlink" title="4.1 共享锁的获取（acquireShared()方法）"></a>4.1 共享锁的获取（acquireShared()方法）</h3><p>在聊完AQS对独占锁的实现后，我们继续一鼓作气的来看看共享锁是怎样实现的？共享锁的获取方法为acquireShared，源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段源码的逻辑很容易理解，在该方法中会首先调用tryAcquireShared方法，tryAcquireShared返回值是一个int类型，当返回值为大于等于0的时候方法结束说明获得成功获取锁，否则，表明获取同步状态失败即所引用的线程获取锁失败，会执行doAcquireShared方法，该方法的源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 当该节点的前驱节点是头结点且成功获取同步状态</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在来看这段代码会不会很容易了？逻辑几乎和独占式锁的获取一模一样，这里的自旋过程中能够退出的条件<strong>是当前节点的前驱节点是头结点并且tryAcquireShared(arg)返回值大于等于0即能成功获得同步状态</strong>。</p>
<h3 id="4-2-共享锁的释放（releaseShared-方法）"><a href="#4-2-共享锁的释放（releaseShared-方法）" class="headerlink" title="4.2 共享锁的释放（releaseShared()方法）"></a>4.2 共享锁的释放（releaseShared()方法）</h3><p>共享锁的释放在AQS中会调用方法releaseShared：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当成功释放同步状态之后即tryReleaseShared会继续执行doReleaseShared方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">        * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">        * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">        * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">        * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">        * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">        * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">        * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">        * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段方法跟独占式锁释放过程有点点不同，在共享式锁的释放过程中，对于能够支持多个线程同时访问的并发组件，必须保证多个线程能够安全的释放同步状态，这里采用的CAS保证，当CAS操作失败continue，在下一次循环中进行重试。</p>
<h3 id="4-3-可中断（acquireSharedInterruptibly-方法），超时等待（tryAcquireSharedNanos-方法）"><a href="#4-3-可中断（acquireSharedInterruptibly-方法），超时等待（tryAcquireSharedNanos-方法）" class="headerlink" title="4.3 可中断（acquireSharedInterruptibly()方法），超时等待（tryAcquireSharedNanos()方法）"></a>4.3 可中断（acquireSharedInterruptibly()方法），超时等待（tryAcquireSharedNanos()方法）</h3><p>关于可中断锁以及超时等待的特性其实现和独占式锁可中断获取锁以及超时等待的实现几乎一致，具体的就不再说了，如果理解了上面的内容对这部分的理解也是水到渠成的。</p>
<p>通过这篇，加深了对AQS的底层实现更加清楚了，也对了解并发组件的实现原理打下了基础，学无止境，继续加油:);如果觉得不错，请给赞，嘿嘿。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote>
<p>《java并发编程的艺术》</p>
</blockquote>
<blockquote>
<p><a href="https://github.com/njustwh2014/MyJavaRepo" target="_blank" rel="noopener">我的github项目，有一些代码示例</a> forked from <a href="https://github.com/CL0610/Java-concurrency" target="_blank" rel="noopener">https://github.com/CL0610/Java-concurrency</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Concurrent</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Concurrent</tag>
        <tag>AQS</tag>
        <tag>Lock</tag>
        <tag>Condition</tag>
      </tags>
  </entry>
  <entry>
    <title>初识Lock和AbstractQueuedSynchronizer(AQS)</title>
    <url>/2019/11/04/chu-shi-lock-he-abstractqueuedsynchronizer-aqs/</url>
    <content><![CDATA[<p><a href="https://github.com/njustwh2014/MyJavaRepo" target="_blank" rel="noopener">我的github项目，有一些代码示例</a> forked from <a href="https://github.com/CL0610/Java-concurrency" target="_blank" rel="noopener">https://github.com/CL0610/Java-concurrency</a></p>
<h2 id="1-concurrent包的结构层次"><a href="#1-concurrent包的结构层次" class="headerlink" title="1. concurrent包的结构层次"></a>1. concurrent包的结构层次</h2><p>在针对并发编程中，Doug Lea大师为我们提供了大量实用，高性能的工具类，针对这些代码进行研究会让我们对并发编程的掌握更加透彻也会大大提升我们对并发编程技术的热爱。这些代码在java.util.concurrent包下。如下图，即为concurrent包的目录结构图。</p>
<a id="more"></a>
<p><img src="/2019/11/04/chu-shi-lock-he-abstractqueuedsynchronizer-aqs/concurrent%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="concurrent目录结构.png"></p>
<p>其中包含了两个子包：atomic以及lock，另外在concurrent下的阻塞队列以及executors,这些就是concurrent包中的精华，之后会一一进行学习。而这些类的实现主要是依赖于volatile以及CAS（关于volatile可以看<a href="https://juejin.im/post/5ae9b41b518825670b33e6c4" target="_blank" rel="noopener">这篇文章</a>，关于CAS可以看<a href="https://juejin.im/post/5ae6dc04f265da0ba351d3ff" target="_blank" rel="noopener">这篇文章的3.1节</a>），从整体上来看concurrent包的整体实现图如下图所示：</p>
<p><img src="/2019/11/04/chu-shi-lock-he-abstractqueuedsynchronizer-aqs/concurrent%E5%8C%85%E5%AE%9E%E7%8E%B0%E6%95%B4%E4%BD%93%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="concurrent包实现整体示意图.png"></p>
<h2 id="2-lock简介"><a href="#2-lock简介" class="headerlink" title="2. lock简介"></a>2. lock简介</h2><p>我们下来看concurent包下的lock子包。锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源。在Lock接口出现之前，java程序主要是靠synchronized关键字实现锁功能的，而java SE5之后，并发包中增加了lock接口，它提供了与synchronized一样的锁功能。<strong>虽然它失去了像synchronize关键字隐式加锁解锁的便捷性，但是却拥有了锁获取和释放的可操作性，可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性</strong>。通常使用显示使用lock的形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	.......</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是<strong>synchronized同步块执行完成或者遇到异常是锁会自动释放，而lock必须调用unlock()方法释放锁，因此在finally块中释放锁</strong>。</p>
<h3 id="2-1-Lock接口API"><a href="#2-1-Lock接口API" class="headerlink" title="2.1 Lock接口API"></a>2.1 Lock接口API</h3><p>我们现在就来看看lock接口定义了哪些方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>; <span class="comment">//获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException；<span class="comment">//获取锁的过程能够响应中断</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;<span class="comment">//非阻塞式响应中断能立即返回，获取锁放回true反之返回fasle</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;<span class="comment">//超时获取锁，在超时内或者未中断的情况下能够获取锁</span></span><br><span class="line"><span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;<span class="comment">//获取与lock绑定的等待通知组件，当前线程必须获得了锁才能进行等待，进行等待时会先释放锁，当再次获取锁时才能从等待中返回</span></span><br></pre></td></tr></table></figure>
<p>上面是lock接口下的五个方法，也只是从源码中英译中翻译了一遍，感兴趣的可以自己的去看看。那么在locks包下有哪些类实现了该接口了？先从最熟悉的ReentrantLock说起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p>很显然ReentrantLock实现了lock接口，接下来我们来仔细研究一下它是怎样实现的。当你查看源码时你会惊讶的发现ReentrantLock并没有多少代码，另外有一个很明显的特点是：<strong>基本上所有的方法的实现实际上都是调用了其静态内部类<code>Sync</code>中的方法，而Sync类继承了<code>AbstractQueuedSynchronizer（AQS）</code></strong>。可以看出要想理解ReentrantLock关键核心在于对队列同步器AbstractQueuedSynchronizer（简称同步器）的理解。</p>
<h3 id="2-2-初识AQS-AbstractQueuedSynchronizer"><a href="#2-2-初识AQS-AbstractQueuedSynchronizer" class="headerlink" title="2.2 初识AQS(AbstractQueuedSynchronizer)"></a>2.2 初识AQS(AbstractQueuedSynchronizer)</h3><p>关于AQS在源码中有十分具体的解释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Provides a framework <span class="keyword">for</span> implementing blocking locks and related</span><br><span class="line">synchronizers (semaphores, events, etc) that rely on</span><br><span class="line">first-in-first-out (FIFO) wait queues.  This <span class="class"><span class="keyword">class</span> <span class="title">is</span> <span class="title">designed</span> <span class="title">to</span></span></span><br><span class="line"><span class="class"><span class="title">be</span> <span class="title">a</span> <span class="title">useful</span> <span class="title">basis</span> <span class="title">for</span> <span class="title">most</span> <span class="title">kinds</span> <span class="title">of</span> <span class="title">synchronizers</span> <span class="title">that</span> <span class="title">rely</span> <span class="title">on</span> <span class="title">a</span></span></span><br><span class="line"><span class="class"><span class="title">single</span> <span class="title">atomic</span> </span>&#123;<span class="meta">@code</span> <span class="keyword">int</span>&#125; value to represent state. Subclasses</span><br><span class="line">must define the <span class="keyword">protected</span> methods that change <span class="keyword">this</span> state, and which</span><br><span class="line">define what that state means in terms of <span class="keyword">this</span> object being acquired</span><br><span class="line">or released.  Given these, the other methods in <span class="keyword">this</span> <span class="class"><span class="keyword">class</span> <span class="title">carry</span></span></span><br><span class="line"><span class="class"><span class="title">out</span> <span class="title">all</span> <span class="title">queuing</span> <span class="title">and</span> <span class="title">blocking</span> <span class="title">mechanics</span>. <span class="title">Subclasses</span> <span class="title">can</span> <span class="title">maintain</span></span></span><br><span class="line"><span class="class"><span class="title">other</span> <span class="title">state</span> <span class="title">fields</span>, <span class="title">but</span> <span class="title">only</span> <span class="title">the</span> <span class="title">atomically</span> <span class="title">updated</span> </span>&#123;<span class="meta">@code</span> <span class="keyword">int</span>&#125;</span><br><span class="line">value manipulated using methods &#123;@link #getState&#125;, &#123;@link</span><br><span class="line">#setState&#125; and &#123;@link #compareAndSetState&#125; is tracked with respect</span><br><span class="line">to synchronization.</span><br><span class="line"></span><br><span class="line">&lt;p&gt;Subclasses should be defined as non-<span class="keyword">public</span> internal helper</span><br><span class="line">classes that are used to implement the synchronization properties</span><br><span class="line">of their enclosing <span class="class"><span class="keyword">class</span>.  <span class="title">Class</span></span></span><br><span class="line"><span class="class"></span>&#123;<span class="meta">@code</span> AbstractQueuedSynchronizer&#125; does not implement any</span><br><span class="line">synchronization <span class="class"><span class="keyword">interface</span>.  <span class="title">Instead</span> <span class="title">it</span> <span class="title">defines</span> <span class="title">methods</span> <span class="title">such</span> <span class="title">as</span></span></span><br><span class="line">&#123;@link #acquireInterruptibly&#125; that can be invoked as</span><br><span class="line">appropriate by concrete locks and related synchronizers to</span><br><span class="line">implement their <span class="keyword">public</span> methods.</span><br></pre></td></tr></table></figure>
<p>同步器是用来构建锁和其他同步组件的基础框架，它的实现主要依赖一个int成员变量来表示同步状态以及通过一个FIFO队列构成等待队列。它的<strong>子类必须重写AQS的几个protected修饰的用来改变同步状态的方法</strong>，其他方法主要是实现了排队和阻塞机制。<strong>状态的更新使用getState,setState以及compareAndSetState这三个方法</strong>。</p>
<p>子类被<strong>推荐定义为自定义同步组件的静态内部类</strong>，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态的获取和释放方法来供自定义同步组件的使用，同步器既支持独占式获取同步状态，也可以支持共享式获取同步状态，这样就可以方便的实现不同类型的同步组件。</p>
<p><strong>同步器是实现锁（也可以是任意同步组件）的关键</strong>，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解二者的关系：<strong>锁是面向使用者，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器是面向锁的实现者，它简化了锁的实现方式，屏蔽了同步状态的管理，线程的排队，等待和唤醒等底层操作</strong>。锁和同步器很好的隔离了使用者和实现者所需关注的领域。</p>
<h3 id="2-3-AQS的模板方法设计模式"><a href="#2-3-AQS的模板方法设计模式" class="headerlink" title="2.3 AQS的模板方法设计模式"></a>2.3 AQS的模板方法设计模式</h3><p>AQS的设计是使用模板方法设计模式，它将<strong>一些方法开放给子类进行重写，而同步器给同步组件所提供模板方法又会重新调用被子类所重写的方法</strong>。举个例子，AQS中需要重写的方法tryAcquire：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReentrantLock中NonfairSync（继承AQS）会重写该方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而AQS中的模板方法acquire():</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">		acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">		selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会调用tryAcquire方法，而此时当继承AQS的NonfairSync调用模板方法acquire时就会调用已经被NonfairSync重写的tryAcquire方法。这就是使用AQS的方式，在弄懂这点后会lock的实现理解有很大的提升。可以归纳总结为这么几点：</p>
<ol>
<li>同步组件（这里不仅仅指锁，还包括CountDownLatch等）的实现依赖于同步器AQS，在同步组件实现中，使用AQS的方式被推荐定义继承AQS的静态内部类；</li>
<li>AQS采用模板方法进行设计，AQS的protected修饰的方法需要由继承AQS的子类进行重写实现，当调用AQS的子类的方法时就会调用被重写的方法；</li>
<li><strong>AQS负责同步状态的管理，线程的排队，等待和唤醒这些底层操作，而Lock等同步组件主要专注于实现同步语义</strong>；</li>
<li>在重写AQS的方式时，使用AQS提供的<code>getState(),setState(),compareAndSetState()</code>方法进行修改同步状态</li>
</ol>
<p>AQS可重写的方法如下图（摘自《java并发编程的艺术》一书）：</p>
<p><img src="/2019/11/04/chu-shi-lock-he-abstractqueuedsynchronizer-aqs/AQS%E5%8F%AF%E9%87%8D%E5%86%99%E7%9A%84%E6%96%B9%E6%B3%95.png" alt="AQS可重写的方法.png"></p>
<p>在实现同步组件时AQS提供的模板方法如下图：</p>
<p><img src="/2019/11/04/chu-shi-lock-he-abstractqueuedsynchronizer-aqs/AQS%E6%8F%90%E4%BE%9B%E7%9A%84%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95.png" alt="AQS提供的模板方法.png"></p>
<p>AQS提供的模板方法可以分为3类：</p>
<ol>
<li>独占式获取与释放同步状态；</li>
<li>共享式获取与释放同步状态；</li>
<li>查询同步队列中等待线程情况；</li>
</ol>
<p>同步组件通过AQS提供的模板方法实现自己的同步语义。</p>
<h2 id="3-一个例子"><a href="#3-一个例子" class="headerlink" title="3. 一个例子"></a>3. 一个例子</h2><p>下面使用一个例子来进一步理解下AQS的使用。这个例子也是来源于AQS源码中的example。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Our internal helper class</span></span><br><span class="line">	<span class="comment">// 继承AQS的静态内部类</span></span><br><span class="line">	<span class="comment">// 重写方法</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Reports whether in locked state</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Acquires the lock if state is zero</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">			<span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">				setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Releases the lock by setting state to zero</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">			<span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">			setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">			setState(<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Provides a Condition</span></span><br><span class="line">		<span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Deserializes properly</span></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">				<span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">			s.defaultReadObject();</span><br><span class="line">			setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The sync object does all the hard work. We just forward to it.</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">	<span class="comment">//使用同步器的模板方法实现自己的同步语义</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		sync.acquire(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		sync.release(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sync.newCondition();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sync.hasQueuedThreads();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MutexDemo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutextDemo</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Mutex mutex = <span class="keyword">new</span> Mutex();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">				mutex.lock();</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">					mutex.unlock();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			thread.start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行情况：</p>
<p><img src="/2019/11/04/chu-shi-lock-he-abstractqueuedsynchronizer-aqs/mutex%E7%9A%84%E6%89%A7%E8%A1%8C%E6%83%85%E5%86%B5.png" alt="mutex的执行情况.png"></p>
<blockquote>
<p>tips: <a href="https://www.jianshu.com/p/52089c4eefdd" target="_blank" rel="noopener">关于Condition可以参考这篇文章</a></p>
</blockquote>
<p>上面的这个例子实现了独占锁的语义，在同一个时刻只允许一个线程占有锁。MutexDemo新建了10个线程，分别睡眠3s。从执行情况也可以看出来当前Thread-6正在执行占有锁而其他Thread-7,Thread-8等线程处于WAIT状态。按照推荐的方式，Mutex定义了一个<strong>继承AQS的静态内部类Sync</strong>,并且重写了AQS的tryAcquire等等方法，而对state的更新也是利用了setState(),getState()，compareAndSetState()这三个方法。在实现实现lock接口中的方法也只是调用了AQS提供的模板方法（因为Sync继承AQS）。从这个例子就可以很清楚的看出来，<strong>在同步组件的实现上主要是利用了AQS，而AQS“屏蔽”了同步状态的修改，线程排队等底层实现，通过AQS的模板方法可以很方便的给同步组件的实现者进行调用。而针对用户来说，只需要调用同步组件提供的方法来实现并发编程即可</strong>。同时在新建一个同步组件时需要把握的两个关键点是：</p>
<ol>
<li>实现同步组件时推荐定义继承AQS的静态内部类，并重写需要的protected修饰的方法；</li>
<li>同步组件语义的实现依赖于AQS的模板方法，而AQS模板方法又依赖于被AQS的子类所重写的方法。</li>
</ol>
<p>通俗点说，因为AQS整体设计思路采用模板方法设计模式，同步组件以及AQS的功能实际上别切分成各自的两部分：</p>
<p><strong>同步组件实现者的角度：</strong></p>
<p>通过可重写的方法：<strong>独占式</strong>： tryAcquire()(独占式获取同步状态），tryRelease()（独占式释放同步状态）；<strong>共享式</strong> ：tryAcquireShared()(共享式获取同步状态)，tryReleaseShared()(共享式释放同步状态)；<strong>告诉AQS怎样判断当前同步状态是否成功获取或者是否成功释放</strong>。同步组件专注于对当前同步状态的逻辑判断，从而实现自己的同步语义。这句话比较抽象，举例来说，上面的Mutex例子中通过tryAcquire方法实现自己的同步语义，在该方法中如果当前同步状态为0（即该同步组件没被任何线程获取），当前线程可以获取同时将状态更改为1返回true，否则，该组件已经被线程占用返回false。很显然，该同步组件只能在同一时刻被线程占用，Mutex专注于获取释放的逻辑来实现自己想要表达的同步语义。</p>
<p><strong>AQS的角度</strong></p>
<p>而对AQS来说，只需要同步组件返回的true和false即可，因为AQS会对true和false会有不同的操作，true会认为当前线程获取同步组件成功直接返回，而false的话AQS也会将当前线程插入同步队列等一系列的方法。</p>
<p>总的来说，同步组件通过重写AQS的方法实现自己想要表达的同步语义，而AQS只需要同步组件表达的true和false即可，AQS会针对true和false不同的情况做不同的处理，至于底层实现，可以<a href="http://www.jianshu.com/p/cc308d82cc71" target="_blank" rel="noopener">看这篇文章</a>。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote>
<p>《java并发编程的艺术》</p>
</blockquote>
<blockquote>
<p> <a href="https://github.com/njustwh2014/MyJavaRepo" target="_blank" rel="noopener">我的github项目，有一些代码示例</a> forked from <a href="https://github.com/CL0610/Java-concurrency" target="_blank" rel="noopener">https://github.com/CL0610/Java-concurrency</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Concurrent</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Concurrent</tag>
        <tag>AQS</tag>
        <tag>Lock</tag>
        <tag>Condition</tag>
      </tags>
  </entry>
  <entry>
    <title>一次简单的elasticsearch使用</title>
    <url>/2019/10/30/yi-ci-jian-dan-de-elasticsearch-shi-yong/</url>
    <content><![CDATA[<h2 id="System-structure"><a href="#System-structure" class="headerlink" title="System structure"></a>System structure</h2><p><img src="http://pzpoejx7j.bkt.clouddn.com/systemstructure.png" alt="System structure"></p>
<ul>
<li>First, main thread monitors the bif data folder backup. </li>
<li>When the file directory is updated，the live thread of pool will work for unzipping zip file and extracting all XML files then resolving XML files to json files.</li>
<li>Put all json files to elasticsearch.</li>
<li>Visualize data of elasticsearch by Grafana.</li>
</ul>
<h2 id="Monitor-the-folder"><a href="#Monitor-the-folder" class="headerlink" title="Monitor the folder"></a>Monitor the folder</h2><p>Use Java class: <strong>WatchService</strong></p>
<a id="more"></a>
<p>This class allows you to monitor changes to files in the operating system in real time, including creating, updating, and deleting events.</p>
<p>the core code:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> micro.trend.wh.customerinsightsystem.service.MyWatchService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWatchTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String fileDirectory;</span><br><span class="line">    <span class="keyword">private</span> MyWatchService myWatchService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileWatchTask</span><span class="params">(String fileDirectory,MyWatchService myWatchService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileDirectory = fileDirectory;</span><br><span class="line">        <span class="keyword">this</span>.myWatchService=myWatchService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WatchService watchService = <span class="keyword">null</span>;</span><br><span class="line">        ExecutorService executorService=Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取当前文件系统的WatchService监控对象</span></span><br><span class="line">            watchService = FileSystems.getDefault().newWatchService();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取文件目录下的Path对象注册到 watchService中。</span></span><br><span class="line">            <span class="comment">//监听的事件类型，有创建，删除，以及修改</span></span><br><span class="line">            Paths.get(fileDirectory)</span><br><span class="line">                    .register(watchService, StandardWatchEventKinds.ENTRY_CREATE, StandardWatchEventKinds.ENTRY_DELETE,</span><br><span class="line">                            StandardWatchEventKinds.ENTRY_MODIFY);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            WatchKey key = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取可用key.没有可用的就wait</span></span><br><span class="line">                key = watchService.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                log.error(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (WatchEvent&lt;?&gt; event : key.pollEvents()) &#123;</span><br><span class="line">                <span class="comment">//todo</span></span><br><span class="line">                System.out.println(<span class="string">"the folder is updated!"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//重置，这一步很重要，否则当前的key就不再会获取将来发生的事件</span></span><br><span class="line">            <span class="keyword">boolean</span> valid = key.reset();</span><br><span class="line">            <span class="comment">//失效状态，退出监听</span></span><br><span class="line">            <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Unzip-File"><a href="#Unzip-File" class="headerlink" title="Unzip File"></a>Unzip File</h2><p>core code:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipEntry;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipFile;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnZip</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unZipFiles</span><span class="params">(String zipPath,String dstPath)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        unZipFiles(<span class="keyword">new</span> File(zipPath),dstPath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * unzip file to specified path</span></span><br><span class="line"><span class="comment">    * @param zipFile: the file that is need to unzip</span></span><br><span class="line"><span class="comment">    * @param dstPath: destination of unzipping</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unZipFiles</span><span class="params">(File zipFile,String dstPath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ZipFile zip=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            zip=<span class="keyword">new</span> ZipFile(zipFile, Charset.forName(<span class="string">"GBK"</span>));<span class="comment">// solving for chinese grabled</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (FileNotFoundException e)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.currentThread().sleep(<span class="number">10000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException sleepErr)&#123;</span><br><span class="line">                sleepErr.printStackTrace();</span><br><span class="line">                log.error(sleepErr.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            zip=<span class="keyword">new</span> ZipFile(zipFile, Charset.forName(<span class="string">"GBK"</span>));<span class="comment">// solving for chinese grabled</span></span><br><span class="line">        &#125;</span><br><span class="line">        String name=zip.getName().substring(zip.getName().lastIndexOf(<span class="string">'\\'</span>)+<span class="number">1</span>,zip.getName().lastIndexOf(<span class="string">'.'</span>));</span><br><span class="line"></span><br><span class="line">        File pathFile=<span class="keyword">new</span> File(dstPath+name);</span><br><span class="line">        <span class="keyword">if</span>(!pathFile.exists())&#123;</span><br><span class="line">            pathFile.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Enumeration&lt;? extends ZipEntry&gt; entries=zip.entries();entries.hasMoreElements();)&#123;</span><br><span class="line">            ZipEntry entry=(ZipEntry) entries.nextElement();</span><br><span class="line">            String zipEntryName=entry.getName();</span><br><span class="line">            InputStream in=zip.getInputStream(entry);</span><br><span class="line">            String outPath=(dstPath+name+<span class="string">"/"</span>+zipEntryName).replaceAll(<span class="string">"\\*"</span>,<span class="string">"/"</span>);</span><br><span class="line">            <span class="comment">// Judge whether the path exist</span></span><br><span class="line">            File file=<span class="keyword">new</span> File(outPath.substring(<span class="number">0</span>,outPath.lastIndexOf(<span class="string">'/'</span>)));</span><br><span class="line">            <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">                file.mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//judge whether the full path is directory</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">new</span> File(outPath).isDirectory())&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            FileOutputStream out=<span class="keyword">new</span> FileOutputStream(outPath);</span><br><span class="line">            <span class="keyword">byte</span>[] buf1=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len=in.read(buf1))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                out.write(buf1,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            in.close();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(zipFile.getName()+<span class="string">"unzipped finished!"</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Resolve-XML-file-to-Json-file"><a href="#Resolve-XML-file-to-Json-file" class="headerlink" title="Resolve XML file to Json file"></a>Resolve XML file to Json file</h2><p>core code:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONArray;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.TypeReference;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentException;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dom4jResolveXml</span> </span>&#123;</span><br><span class="line">    String xmlDir=<span class="keyword">null</span>;</span><br><span class="line">    String jsonFileDir=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dom4jResolveXml</span><span class="params">(String xmlDir, String jsonFileDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.xmlDir = xmlDir;</span><br><span class="line">        <span class="keyword">this</span>.jsonFileDir=jsonFileDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resolveXML</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">            InputStream inputStream=<span class="keyword">new</span> FileInputStream(xmlDir);</span><br><span class="line">            SAXReader saxReader=<span class="keyword">new</span> SAXReader();</span><br><span class="line">            Document document=saxReader.read(xmlDir);</span><br><span class="line">            Element bifElement=document.getRootElement();</span><br><span class="line"><span class="comment">//            System.out.println("root name:"+bifElement.getName());</span></span><br><span class="line"><span class="comment">//            System.out.println("root element attribute count:"+bifElement.attributeCount());</span></span><br><span class="line"><span class="comment">//            System.out.println("root element value:"+bifElement.attributeValue("bif"));</span></span><br><span class="line">            Element productElement=bifElement.element(<span class="string">"Product"</span>);</span><br><span class="line">            Element trafficMatrixElement=productElement.element(<span class="string">"TrafficMatrix"</span>);</span><br><span class="line">            <span class="keyword">if</span>(trafficMatrixElement==<span class="keyword">null</span>)&#123;</span><br><span class="line">                log.info(<span class="string">"the xml file: "</span>+xmlDir+<span class="string">" has no traffixMatrix node."</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            String trafficMatrixText=trafficMatrixElement.getTextTrim();</span><br><span class="line">            Element acElement=productElement.element(<span class="string">"AC"</span>);</span><br><span class="line">            String acText=acElement.getTextTrim();</span><br><span class="line">            Element guidElement=productElement.element(<span class="string">"GUID"</span>);</span><br><span class="line">            String guidText=guidElement.getText();</span><br><span class="line"><span class="comment">//            System.out.println(trafficMatrixText);</span></span><br><span class="line"><span class="comment">//            System.out.println("*************************");</span></span><br><span class="line"></span><br><span class="line">            StringBuilder jsonSB=<span class="keyword">new</span> StringBuilder(trafficMatrixText);</span><br><span class="line"></span><br><span class="line"><span class="comment">//            jsonSB.insert(1,"\"AC\":"+"\""+acText+"\","+"\"GUID\":\""+guidText+"\",\"cpuinfo\":&#123;");</span></span><br><span class="line"><span class="comment">//            jsonSB.append("&#125;");</span></span><br><span class="line"></span><br><span class="line">            trafficMatrixText=jsonSB.toString();</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.getClass())&#123;</span><br><span class="line">                jsonResolve(trafficMatrixText,acText,guidText);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.println(trafficMatrixText.substring(0,1));</span></span><br><span class="line"><span class="comment">//            outJsonToFile(trafficMatrixText);</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (FileNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (DocumentException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jsonResolve</span><span class="params">(String jsonOrigin,String acInfo,String guidInfo)</span></span>&#123;</span><br><span class="line">        String idTxtFileName=PropertiesUtils.getValueByKey(<span class="string">"config.properties"</span>,<span class="string">"idTxtFileName"</span>);</span><br><span class="line">        String idStr=ReadAndWriteFile.readFile(idTxtFileName);</span><br><span class="line">        BigInteger bigInteger=<span class="keyword">new</span> BigInteger(idStr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        JSONObject jsonObject= JSON.parseObject(jsonOrigin);//disorder</span></span><br><span class="line">        LinkedHashMap&lt;String, String&gt; jsonMap = JSON.parseObject(jsonOrigin, <span class="keyword">new</span> TypeReference&lt;LinkedHashMap&lt;String, String&gt;&gt;() &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        JSONObject cpuObject=<span class="keyword">null</span>;</span><br><span class="line">        String jsonFileNameNOTDir=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String,String&gt; entry:jsonMap.entrySet())&#123;</span><br><span class="line"><span class="comment">//            System.out.println("key:"+entry.getKey()+" value:"+entry.getValue().toString());</span></span><br><span class="line"><span class="comment">//            &#123;"index":&#123;"_index":"acinfoindex","_id":5&#125;&#125;</span></span><br><span class="line">            sb.append(<span class="string">"&#123;\"index\":&#123;\"_index\":\"acinfoindex\",\"_id\":"</span>+bigInteger+<span class="string">"&#125;&#125;\n"</span>);</span><br><span class="line">            bigInteger=bigInteger.add(BigInteger.valueOf(<span class="number">1</span>));</span><br><span class="line">            sb.append(<span class="string">"&#123;"</span>);</span><br><span class="line">            sb.append(<span class="string">"\"AC\":\""</span>+acInfo+<span class="string">"\","</span>);</span><br><span class="line">            sb.append(<span class="string">"\"GUID\":\""</span>+guidInfo+<span class="string">"\","</span>);</span><br><span class="line">            sb.append(<span class="string">"\"TIME\":\""</span>+entry.getKey()+<span class="string">"\","</span>);</span><br><span class="line">            sb.append(<span class="string">"\"CPUINFO\":"</span>);</span><br><span class="line">            sb.append(<span class="string">"&#123;"</span>);</span><br><span class="line">            LinkedHashMap&lt;String,String&gt; cpuMap=JSON.parseObject(entry.getValue(),<span class="keyword">new</span> TypeReference&lt;LinkedHashMap&lt;String, String&gt;&gt;()&#123;&#125;);</span><br><span class="line">            <span class="keyword">for</span>(Map.Entry&lt;String,String&gt; cpuEntry:cpuMap.entrySet())&#123;</span><br><span class="line"><span class="comment">//                System.out.println(cpuEntry.getKey()+"*******"+cpuEntry.getValue());</span></span><br><span class="line">                <span class="keyword">if</span>(cpuEntry.getValue()==<span class="keyword">null</span>||cpuEntry.getValue().equals(<span class="string">""</span>))&#123;</span><br><span class="line">                    cpuEntry.setValue(<span class="string">"0"</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    sb.append(<span class="string">"\""</span>+cpuEntry.getKey()+<span class="string">"\":"</span>+cpuEntry.getValue()+<span class="string">","</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">            sb.append(<span class="string">"&#125;"</span>);</span><br><span class="line"><span class="comment">//            sb.append(entry.getValue());</span></span><br><span class="line">            sb.append(<span class="string">"&#125;"</span>);</span><br><span class="line">            sb.append(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        jsonFileNameNOTDir=acInfo+<span class="string">"_"</span>+guidInfo+bigInteger+<span class="string">".json"</span>;</span><br><span class="line">        ReadAndWriteFile.writeFile(idTxtFileName,bigInteger.toString());</span><br><span class="line">        outJsonToFile(sb.toString(),jsonFileNameNOTDir);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * output json string to file</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outJsonToFile</span><span class="params">(String jsonStr,String jsonFileNameNeNOTDir)</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buff=<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        FileOutputStream fileOutputStream=<span class="keyword">null</span>;</span><br><span class="line">        File file=<span class="keyword">new</span> File(jsonFileDir+jsonFileNameNeNOTDir);</span><br><span class="line">        <span class="keyword">if</span>(!file.getParentFile().exists())&#123;</span><br><span class="line">            file.getParentFile().mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            buff=jsonStr.getBytes();</span><br><span class="line">            fileOutputStream=<span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">            log.info(<span class="string">"output file path:"</span>+jsonFileDir);</span><br><span class="line">            fileOutputStream.write(buff,<span class="number">0</span>,buff.length);</span><br><span class="line">            log.info(<span class="string">"output json data to file success!"</span>);</span><br><span class="line">            SSH2Util ssh2Util = <span class="keyword">new</span> SSH2Util(PropertiesUtils.getValueByKey(<span class="string">"config.properties"</span>,<span class="string">"ip"</span>), PropertiesUtils.getValueByKey(<span class="string">"config.properties"</span>,<span class="string">"usrName"</span>),PropertiesUtils.getValueByKey(<span class="string">"config.properties"</span>,<span class="string">"pwd"</span>), <span class="number">22</span>);</span><br><span class="line">            ssh2Util.putFile(jsonFileDir, jsonFileNameNeNOTDir,PropertiesUtils.getValueByKey(<span class="string">"config.properties"</span>,<span class="string">"serverDir"</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            log.error(e.getMessage());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            log.error(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fileOutputStream!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    fileOutputStream.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException eS)&#123;</span><br><span class="line">                    log.error(eS.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Beacuse the program need to record the index id, so I just write the id to the txt, so when build each json need to read the txt and increase the id. In order to speed up, multi-threaded data is used. We need to use lock avoiding open txt file failed.</p>
<h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><p>install guid:<a href="https://www.howtoing.com/how-to-install-elasticsearch-logstash-and-kibana-elastic-stack-on-centos-7" target="_blank" rel="noopener">https://www.howtoing.com/how-to-install-elasticsearch-logstash-and-kibana-elastic-stack-on-centos-7</a></p>
<p>index:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X PUT <span class="string">"localhost:9200/acinfoindex?pretty"</span> -H <span class="string">'Content-Type: application/json'</span> -d<span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  "mappings":&#123;</span></span><br><span class="line"><span class="string">    "info":&#123;</span></span><br><span class="line"><span class="string">      "properties":&#123;</span></span><br><span class="line"><span class="string">        "AC":&#123;"type":"keyword"&#125;,</span></span><br><span class="line"><span class="string">        "GUID":&#123;"type":"keyword"&#125;,</span></span><br><span class="line"><span class="string">        "TIME":&#123;"type":"date",</span></span><br><span class="line"><span class="string">          "format": "epoch_second"</span></span><br><span class="line"><span class="string">          &#125;,</span></span><br><span class="line"><span class="string">        "CPUINFO":&#123;</span></span><br><span class="line"><span class="string">            "properties":&#123;</span></span><br><span class="line"><span class="string">                "auth_simp_n":&#123;"type": "integer"&#125;,</span></span><br><span class="line"><span class="string">                "auth_ntlm_n":&#123;"type": "integer"&#125;,</span></span><br><span class="line"><span class="string">                "th_inc":&#123;"type": "integer"&#125;,</span></span><br><span class="line"><span class="string">                "th_net_in_traffic":&#123;"type": "integer"&#125;,</span></span><br><span class="line"><span class="string">                "auth_krb5_n":&#123;"type": "integer"&#125;,</span></span><br><span class="line"><span class="string">                "usg_mem":&#123;"type": "integer"&#125;,</span></span><br><span class="line"><span class="string">                "th_net_out_traffic":&#123;"type": "integer"&#125;,</span></span><br><span class="line"><span class="string">                "auth_succ_n":&#123;"type": "integer"&#125;,</span></span><br><span class="line"><span class="string">                "usg_disk_io":&#123;"type": "integer"&#125;,</span></span><br><span class="line"><span class="string">                "th_inc_http2":&#123;"type": "integer"&#125;,</span></span><br><span class="line"><span class="string">                "th_inc_https":&#123;"type": "integer"&#125;,</span></span><br><span class="line"><span class="string">                "th_inc_http":&#123;"type": "integer"&#125;,</span></span><br><span class="line"><span class="string">                "auth_n":&#123;"type": "integer"&#125;,</span></span><br><span class="line"><span class="string">                "usg_cpu":&#123;"type": "integer"&#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">        &#125; </span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &#125;   </span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></table></figure>

<p>and then put data to elasticsearch</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pyinotify</span><br><span class="line"></span><br><span class="line">multi_event=pyinotify.IN_CREATE|pyinotify.IN_ACCESS|pyinotify.IN_CLOSE_WRITE</span><br><span class="line">wm=pyinotify.WatchManager()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEventHandler</span><span class="params">(pyinotify.ProcessEvent)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_IN_CREATE</span><span class="params">(self,event)</span>:</span></span><br><span class="line">        print(<span class="string">'CREATE'</span>,event.pathname)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">precess_IN_ACCESS</span><span class="params">(self,event)</span>:</span></span><br><span class="line">        print(<span class="string">'ACCESS'</span>,event.pathname)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_IN_CLOSE_WRITE</span><span class="params">(self,event)</span>:</span></span><br><span class="line">        print(<span class="string">'CLOSE_WRITE'</span>,event.pathname)</span><br><span class="line">        output = os.popen(<span class="string">"curl -H 'Content-Type: application/x-ndjson' -XPOST 'localhost:9200/acinfoindex/info/_bulk?pretty' --data-binary @"</span>+event.pathname)</span><br><span class="line"></span><br><span class="line">handler=MyEventHandler()</span><br><span class="line"></span><br><span class="line">notifier=pyinotify.Notifier(wm,handler)</span><br><span class="line"></span><br><span class="line">wm.add_watch(<span class="string">'/home/huanhuan/data'</span>,multi_event)</span><br><span class="line">notifier.loop()</span><br></pre></td></tr></table></figure>

<h2 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h2><p> refer to:</p>
<p><a href="http://docs.flycloud.me/docs/ELKStack/elasticsearch/other/grafana.html" target="_blank" rel="noopener">http://docs.flycloud.me/docs/ELKStack/elasticsearch/other/grafana.html</a></p>
<p><a href="https://www.aiprose.com/blog/26" target="_blank" rel="noopener">https://www.aiprose.com/blog/26</a></p>
]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
  </entry>
  <entry>
    <title>Java中正则表达式使用</title>
    <url>/2019/10/28/java-zhong-zheng-ze-biao-da-shi-shi-yong/</url>
    <content><![CDATA[<h2 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h2><p>正则表达式是一个定义<strong>搜索模式</strong>的字符串。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><a id="more"></a>
<table>
<thead>
<tr>
<th align="left">正则表达式</th>
<th align="left">匹配</th>
</tr>
</thead>
<tbody><tr>
<td align="left">this is text</td>
<td align="left">精确匹配到字符串this is text</td>
</tr>
<tr>
<td align="left">this\s+is\s+text</td>
<td align="left">匹配单词this和is后跟一个或多个空格</td>
</tr>
<tr>
<td align="left">^\d+(.\d+)?</td>
<td align="left">^ 定义模式必须匹配字符串的开始，d+ 匹配一个或多个数字，? 表明小括号内的语句是可选的，. 匹配 “.”，小括号表示分组。例如匹配：”5”、”1.5” 和 “2.21”</td>
</tr>
</tbody></table>
<h2 id="正则表达式编写规则"><a href="#正则表达式编写规则" class="headerlink" title="正则表达式编写规则"></a>正则表达式编写规则</h2><h3 id="常见匹配符号"><a href="#常见匹配符号" class="headerlink" title="常见匹配符号"></a>常见匹配符号</h3><table>
<thead>
<tr>
<th align="left">正则表达式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">.</td>
<td align="left">匹配所有单个字符，除了换行(Linux换行符\n, Windows换行符\r\n)</td>
</tr>
<tr>
<td align="left">^regex</td>
<td align="left">正则必须匹配字符串开头</td>
</tr>
<tr>
<td align="left">regex$</td>
<td align="left">正则必须匹配字符串结尾</td>
</tr>
<tr>
<td align="left">[abc]</td>
<td align="left">复选集定义，匹配a或b或c</td>
</tr>
<tr>
<td align="left">[abc][vz]</td>
<td align="left">复选集定义，匹配字母 a 或 b 或 c，后面跟着 v 或 z</td>
</tr>
<tr>
<td align="left">[^abc]</td>
<td align="left">当插入符 ^ 在中括号中以第一个字符开始显示，则表示否定模式。此模式匹配所有字符，除了 a 或 b 或 c</td>
</tr>
<tr>
<td align="left">[a-d1-7]</td>
<td align="left">范围匹配，匹配字母 a 到 d 和数字从 1 到 7 之间，但不匹配 d1</td>
</tr>
<tr>
<td align="left">XZ</td>
<td align="left">X后直接跟着Z</td>
</tr>
<tr>
<td align="left">X|Z</td>
<td align="left">匹配X或Z</td>
</tr>
</tbody></table>
<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>元字符是一个预定义的字符。</p>
<table>
<thead>
<tr>
<th align="left">正则表达式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\d</td>
<td align="left">匹配一个数字，是 [0-9] 的简写</td>
</tr>
<tr>
<td align="left">\D</td>
<td align="left">匹配一个非数字，是 [^0-9] 的简写</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">匹配一个空格，是 [ \t\n\x0b\r\f] 的简写</td>
</tr>
<tr>
<td align="left">\S</td>
<td align="left">匹配一个非空格</td>
</tr>
<tr>
<td align="left">\w</td>
<td align="left">匹配一个单词字符（大小写字母、数字、下划线），是 [a-zA-Z_0-9] 的简写</td>
</tr>
<tr>
<td align="left">\W</td>
<td align="left">匹配一个非单词字符（除了大小写字母、数字、下划线之外的字符），等同于 [^\w]</td>
</tr>
</tbody></table>
<h3 id="限制符"><a href="#限制符" class="headerlink" title="限制符"></a>限制符</h3><p>限定符定义了一个元素可以发生的频率。</p>
<table>
<thead>
<tr>
<th align="left">正则表达式</th>
<th align="left">描述</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">*</td>
<td align="left">匹配 &gt;=0 个，是 {0,} 的简写</td>
<td align="left">X* 表示匹配零个或多个字母 X，.* 表示匹配任何字符串</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">匹配 &gt;=1 个，是 {1,} 的简写</td>
<td align="left">X+ 表示匹配一个或多个字母 X</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">匹配 1 个或 0 个，是 {0,1} 的简写</td>
<td align="left">X? 表示匹配 0 个或 1 个字母 X</td>
</tr>
<tr>
<td align="left">{X}</td>
<td align="left">只匹配 X 个字符</td>
<td align="left">\d{3} 表示匹配 3 个数字，.{10} 表示匹配任何长度是 10 的字符串</td>
</tr>
<tr>
<td align="left">{X,Y}</td>
<td align="left">匹配 &gt;=X 且 &lt;=Y 个</td>
<td align="left">\d{1,4} 表示匹配至少 1 个最多 4 个数字</td>
</tr>
<tr>
<td align="left">*?</td>
<td align="left">如果 ? 是限定符 * 或 + 或 ? 或 {} 后面的第一个字符，那么表示非贪婪模式（尽可能少的匹配字符），而不是默认的贪婪模式</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="分组与反向应用"><a href="#分组与反向应用" class="headerlink" title="分组与反向应用"></a>分组与反向应用</h3><p>小括号()可以达到对正则表达式分组的效果。</p>
<p>模式分组后会在正则表达式中创建反向引用。反向引用会保存匹配模式分组的字符串片断，这使得我们可以获取并使用这个字符串片断。</p>
<p>Java中，在以正则表达式替换字符串的语法中，是通过 $ 来引用分组的反向引用，$0 是匹配完整模式的字符串（注意在 JavaScript 中是用 $&amp; 表示）；$1 是第一个分组的反向引用；$2 是第二个分组的反向引用，以此类推。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str=<span class="string">"Hello ,world ."</span>;</span><br><span class="line">    String pattern=<span class="string">"(\\w)(\\s+)([.,])"</span>;</span><br><span class="line">    System.out.println(str.replaceAll(pattern,<span class="string">"$1$3"</span>));<span class="comment">//Hello,World.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，我们使用了 [.] 来匹配普通字符 . 而不需要使用 [\.]。因为正则对于 [] 中的 .，会自动处理为 [.]，即普通字符 . 进行匹配。</p>
<h3 id="仅分组但无反向引用"><a href="#仅分组但无反向引用" class="headerlink" title="仅分组但无反向引用"></a>仅分组但无反向引用</h3><p>当我们在小括号 () 内的模式开头加入 ?:，那么表示这个模式仅分组，但不创建反向引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"img.jpg"</span>;</span><br><span class="line"><span class="comment">// 分组且创建反向引用</span></span><br><span class="line"><span class="comment">//        Pattern pattern = Pattern.compile("(jpg|png)");</span></span><br><span class="line"><span class="comment">//        Matcher matcher = pattern.matcher(str);</span></span><br><span class="line"><span class="comment">//        while (matcher.find()) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(matcher.group());//jpg</span></span><br><span class="line"><span class="comment">//            System.out.println(matcher.group(1));//jpg</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分组但不创建反向引用</span></span><br><span class="line">Pattern pattern = Pattern.compile(<span class="string">"(?:jpg|png)"</span>);</span><br><span class="line">Matcher matcher = pattern.matcher(str);</span><br><span class="line"><span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">    System.out.println(matcher.group());<span class="comment">//jpg</span></span><br><span class="line">    System.out.println(matcher.group(<span class="number">1</span>));<span class="comment">//Exception in thread "main" java.lang.IndexOutOfBoundsException: No group 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分组的反向引用副本"><a href="#分组的反向引用副本" class="headerlink" title="分组的反向引用副本"></a>分组的反向引用副本</h3><p>Java 中可以在小括号中使用 ?<name> 将小括号中匹配的内容保存为一个名字为 name 的副本。</name></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str=<span class="string">"@wanghuan is a cool boy."</span>;</span><br><span class="line">Pattern pattern=Pattern.compile(<span class="string">"@(?&lt;first&gt;\\w+\\s)"</span>);</span><br><span class="line">Matcher matcher=pattern.matcher(str);</span><br><span class="line"><span class="keyword">while</span>(matcher.find())&#123;</span><br><span class="line">    System.out.println(matcher.group());<span class="comment">//@wanghuan</span></span><br><span class="line">    System.out.println(matcher.group(<span class="number">1</span>));<span class="comment">//wanghuan</span></span><br><span class="line">    System.out.println(matcher.group(<span class="string">"first"</span>));<span class="comment">//wanghuan</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="否对先行断言"><a href="#否对先行断言" class="headerlink" title="否对先行断言"></a>否对先行断言</h3><p>我们可以创建否定先行断言模式的匹配，即某个字符串后面不包含另一个字符串的匹配模式。</p>
<p>否定先行断言模式通过 (?!pattern) 定义。比如，我们匹配后面不是跟着 “b” 的 “a”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pattern pattern=Pattern.compile(<span class="string">"a(?!a)"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="指定正则表达式的模式"><a href="#指定正则表达式的模式" class="headerlink" title="指定正则表达式的模式"></a>指定正则表达式的模式</h3><p>可以在正则开头指定模式修饰符。</p>
<blockquote>
<p>(?i) 使正则忽略大小写。</p>
</blockquote>
<blockquote>
<p>(?s) 表示单行模式（”single line mode”）使正则的 . 匹配所有字符，包括换行符。</p>
</blockquote>
<blockquote>
<p>(?m) 表示多行模式（”multi-line mode”），使正则的 ^ 和 $ 匹配字符串中每行的开始和结束。</p>
</blockquote>
<h3 id="java中反斜杠"><a href="#java中反斜杠" class="headerlink" title="java中反斜杠"></a>java中反斜杠</h3><p>反斜杠 \ 在 Java 中表示转义字符，这意味着 \ 在 Java 拥有预定义的含义。</p>
<p>这里例举两个特别重要的用法：</p>
<ul>
<li>在匹配 . 或 { 或 [ 或 ( 或 ? 或 $ 或 ^ 或 * 这些特殊字符时，需要在前面加上 \，比如匹配 . 时，Java 中要写为 \.，但对于正则表达式来说就是 .。</li>
</ul>
<ul>
<li>在匹配 \ 时，Java 中要写为 \\，但对于正则表达式来说就是 \。</li>
</ul>
<p><strong>注意：</strong> Java 中的正则表达式字符串有两层含义，首先 Java 字符串转义出符合正则表达式语法的字符串，然后再由转义后的正则表达式进行模式匹配。</p>
<h3 id="易错示例"><a href="#易错示例" class="headerlink" title="易错示例"></a>易错示例</h3><blockquote>
<p>[jpg|png] 表示匹配字符j或p或g或p或n或g中的任意一个字符</p>
</blockquote>
<blockquote>
<p>(jpg|png) 表示匹配jpg或png</p>
</blockquote>
<h2 id="在字符串中使用正则表达式"><a href="#在字符串中使用正则表达式" class="headerlink" title="在字符串中使用正则表达式"></a>在字符串中使用正则表达式</h2><h3 id="内置的字符串正则处理方法"><a href="#内置的字符串正则处理方法" class="headerlink" title="内置的字符串正则处理方法"></a>内置的字符串正则处理方法</h3><p>在 Java 中有四个内置的运行正则表达式的方法，分别是 matches()、split())、replaceFirst()、replaceAll()。注意 replace() 方法不支持正则表达式。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">s.matches(“regex”)</td>
<td align="left">当仅且当正则匹配整个字符串时返回 true</td>
</tr>
<tr>
<td align="left">s.split(“regex”)</td>
<td align="left">按匹配的正则表达式切片字符串</td>
</tr>
<tr>
<td align="left">s.replaceFirst(“regex”, “replacement”)</td>
<td align="left">替换首次匹配的字符串片段</td>
</tr>
<tr>
<td align="left">s.replaceAll(“regex”, “replacement”)</td>
<td align="left">替换所有匹配的字符</td>
</tr>
</tbody></table>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"wxj"</span>.matches(<span class="string">"wxj"</span>));</span><br><span class="line">System.out.println(<span class="string">"----------"</span>);</span><br><span class="line"></span><br><span class="line">String[] array = <span class="string">"w x j"</span>.split(<span class="string">"\\s"</span>);</span><br><span class="line"><span class="keyword">for</span> (String item : array) &#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"----------"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"w x j"</span>.replaceFirst(<span class="string">"\\s"</span>, <span class="string">"-"</span>));</span><br><span class="line">System.out.println(<span class="string">"----------"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"w x j"</span>.replaceAll(<span class="string">"\\s"</span>, <span class="string">"-"</span>));</span><br></pre></td></tr></table></figure>

<p>result:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line">----------</span><br><span class="line">w</span><br><span class="line">x</span><br><span class="line">j</span><br><span class="line">----------</span><br><span class="line">w-x j</span><br><span class="line">----------</span><br><span class="line">w-x-j</span><br></pre></td></tr></table></figure>

<h2 id="模式与匹配"><a href="#模式与匹配" class="headerlink" title="模式与匹配"></a>模式与匹配</h2><p>Java 中使用正则表达式需要用到两个类，分别为 java.util.regex.Pattern 和 java.util.regex.Matcher。</p>
<ul>
<li><p>第一步，通过正则表达式创建模式对象 Pattern。</p>
</li>
<li><p>第二步，通过模式对象 Pattern，根据指定字符串创建匹配对象 Matcher。</p>
</li>
<li><p>第三步，通过匹配对象 Matcher，根据正则表达式操作字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str=<span class="string">"Wanghuan is a cool boy!"</span>;</span><br><span class="line">Pattern pattern=Pattern.compile(<span class="string">"\\w+"</span>);</span><br><span class="line"><span class="comment">// Java 中忽略大小写，有两种写法：</span></span><br><span class="line"><span class="comment">// Pattern pattern = Pattern.compile("\\w+", Pattern.CASE_INSENSITIVE);</span></span><br><span class="line"><span class="comment">// Pattern pattern = Pattern.compile("(?i)\\w+"); // 推荐写法</span></span><br><span class="line">Matcher matcher=pattern.matcher(str);</span><br><span class="line"><span class="keyword">while</span>(matcher.find())&#123;</span><br><span class="line">    System.out.print(<span class="string">"Start index: "</span> + matcher.start());</span><br><span class="line">    System.out.print(<span class="string">" End index: "</span> + matcher.end() + <span class="string">" "</span>);</span><br><span class="line">    System.out.println(matcher.group());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建第两个模式，将空格替换为 -</span></span><br><span class="line">Pattern replace = Pattern.compile(<span class="string">"\\s+"</span>);</span><br><span class="line">Matcher matcher2 = replace.matcher(str);</span><br><span class="line">System.out.println(matcher2.replaceAll(<span class="string">"-"</span>));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>result:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Start index: 0 End index: 8 Wanghuan</span><br><span class="line">Start index: 9 End index: 11 is</span><br><span class="line">Start index: 12 End index: 13 a</span><br><span class="line">Start index: 14 End index: 18 cool</span><br><span class="line">Start index: 19 End index: 22 boy</span><br><span class="line">Wanghuan-is<span class="_">-a</span>-cool-boy!</span><br></pre></td></tr></table></figure>

<h2 id="常用例子"><a href="#常用例子" class="headerlink" title="常用例子"></a>常用例子</h2><blockquote>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">    String pattern=<span class="string">"[+-]?\\d*(?:\\.\\d*)?(?:[Ee][+-]?\\d+)?$"</span>;</span><br><span class="line">    String s=<span class="keyword">new</span> String(str);</span><br><span class="line">    <span class="keyword">return</span> Pattern.matches(pattern,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多例子参考文章<a href="https://segmentfault.com/a/1190000009162306" target="_blank" rel="noopener">Java 正则表达式详解</a></p>
<h2 id="正则表达式检验网站"><a href="#正则表达式检验网站" class="headerlink" title="正则表达式检验网站"></a>正则表达式检验网站</h2><p>推荐一个网站，这个网站可以检查你写的正则表达式和对应的字符串匹配时会不会有问题。<br><a href="https://regex101.com/" target="_blank" rel="noopener">Online regex tester and debugger: PHP, PCRE, Python, Golang and JavaScript</a></p>
<h2 id="对于量词匹配的三种模式"><a href="#对于量词匹配的三种模式" class="headerlink" title="对于量词匹配的三种模式"></a>对于量词匹配的三种模式</h2><p>使用正则表达式时要注意对于量词匹配的三种模式使用，从而优化正则表达式的效率。</p>
<blockquote>
<p>贪婪模式</p>
</blockquote>
<blockquote>
<p>懒惰模式</p>
</blockquote>
<blockquote>
<p>独占模式</p>
</blockquote>
<p>具体细节可以参考文章<a href="https://www.cnblogs.com/study-everyday/p/7426862.html" target="_blank" rel="noopener">一个由正则表达式引发的血案</a></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote>
<p><a href="https://segmentfault.com/a/1190000009162306" target="_blank" rel="noopener">Java 正则表达式详解</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/study-everyday/p/7426862.html" target="_blank" rel="noopener">一个由正则表达式引发的血案</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>我的网站开发经历与Java学习心路历程</title>
    <url>/2019/10/22/wo-de-wang-zhan-kai-fa-jing-li-yu-java-xue-xi-xin-lu-li-cheng/</url>
    <content><![CDATA[<h2 id="网站介绍"><a href="#网站介绍" class="headerlink" title="网站介绍"></a>网站介绍</h2><h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p><a href="http://www.seumstc.top:8090/index.html" target="_blank" rel="noopener">http://www.seumstc.top:8090/index.html</a></p>
<h3 id="什么是前后端分离的开发模式"><a href="#什么是前后端分离的开发模式" class="headerlink" title="什么是前后端分离的开发模式"></a>什么是前后端分离的开发模式</h3><p><strong>Web研发模式演变：</strong><a href="https://github.com/lifesinger/blog/issues/184" target="_blank" rel="noopener">https://github.com/lifesinger/blog/issues/184</a></p>
<a id="more"></a>

<h3 id="开发这样一个网站我们需要的技术栈"><a href="#开发这样一个网站我们需要的技术栈" class="headerlink" title="开发这样一个网站我们需要的技术栈"></a>开发这样一个网站我们需要的技术栈</h3><h2 id="Java学习历程"><a href="#Java学习历程" class="headerlink" title="Java学习历程"></a>Java学习历程</h2><p><img src="/2019/10/22/wo-de-wang-zhan-kai-fa-jing-li-yu-java-xue-xi-xin-lu-li-cheng/javaweblearningroute.png" alt="Java后端学习路线"></p>
<p>学习资源：</p>
<blockquote>
<p><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p>
<p><a href="https://github.com/CL0610/Java-concurrency" target="_blank" rel="noopener">https://github.com/CL0610/Java-concurrency</a></p>
</blockquote>
<h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><p><img src="/2019/10/22/wo-de-wang-zhan-kai-fa-jing-li-yu-java-xue-xi-xin-lu-li-cheng/JavaBase.jpg" alt="Java基础思维导图"></p>
<p><strong>书本推荐：</strong>《Java核心技术》《Java编程思想》 建议先看核心技术</p>
<p>Java作为一门强类型语言，我们学习Java需要首先明确<strong>面向对象</strong>的概念，可以理解以下几个概念：<strong>封装、继承、多态</strong>等，并学会灵活运用。此外还可以学习一些Java语言特性，如泛型、反射等。这些特性广泛运用于一些框架中，如Spring的Aop和Ioc均使用了Java的反射特性，然而我们知道，原生Java反射效率不高，具体原因我们后面专门写博客分析。</p>
<p>其次，就是要学习一些Java的标准库，如集合、IO、String等等.</p>
<p>学习中可以采用这样一个模式：</p>
<ul>
<li>理解概念</li>
<li>找相关demo学习</li>
<li>动手复现</li>
<li>总结：效率、扩展性等方面</li>
</ul>
<h3 id="数据结构、基础算法与设计模式"><a href="#数据结构、基础算法与设计模式" class="headerlink" title="数据结构、基础算法与设计模式"></a>数据结构、基础算法与设计模式</h3><p><strong>推荐书籍：</strong>《剑指Offer》《修炼Java开发技术》《Effective Java》</p>
<p>数据结构的学习是学任何一门编程语言的基础，在学完基础语法以后就需要深入学习数据结构。只要掌握好数据结构才能结合算法写出效率与鲁棒性俱佳的代码。</p>
<p>对于这部分的学习，没有更多方法就是多刷题，多总结。我后续会在博客网站写相关内容。</p>
<h3 id="JVM以及操作系统"><a href="#JVM以及操作系统" class="headerlink" title="JVM以及操作系统"></a>JVM以及操作系统</h3><p><strong>推荐书籍：</strong> 《深入理解Java虚拟机》</p>
<p><strong>一定要看</strong>，重点关注JMM(Java内存模型)，GC，还需要了解一些Java虚拟机指令，方便调试。</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>这部分我没有书籍推荐，我个人觉得是要自己安装并使用才是最重要的。</p>
<p>对于数据库你需要理解</p>
<blockquote>
<p>什么是关系型数据库(Mysql, Orcal sql etc.)及其优缺点</p>
</blockquote>
<blockquote>
<p>什么是非关系型数据库(Redis, MongoDB etc.)及其优缺点</p>
</blockquote>
<blockquote>
<p>Sql与NoSql的应用场景</p>
</blockquote>
<blockquote>
<p>数据库运维基础</p>
</blockquote>
<blockquote>
<p>对于关系型数据库，怎么提升其性能</p>
</blockquote>
<blockquote>
<p>非关系数据库的备份与同步问题</p>
</blockquote>
<blockquote>
<p>Java操作数据库的API(如对于Mysql的Mybatis，对于Redis的Jedis)</p>
</blockquote>
<h3 id="框架学习"><a href="#框架学习" class="headerlink" title="框架学习"></a>框架学习</h3><p><strong>推荐书籍：</strong> 《Spring实战》《Springboot 实战》<br>Java的一大优势就是拥有很多优秀的开源与非开源的框架。</p>
<p><img src="http://pzpoejx7j.bkt.clouddn.com/JustCopyIt.jpg" alt></p>
<p>但是首推自然是Spring全家桶。</p>
<p><img src="http://pzpoejx7j.bkt.clouddn.com/springframe.png" alt="Spring框架"></p>
<p>同样，对于一个框架学习，需要抓住切入点，可以从以下方面展开学习：</p>
<blockquote>
<p>Spring是什么？它有什么优点？</p>
</blockquote>
<blockquote>
<p>什么IOC(依赖注入或者控制反转)？</p>
</blockquote>
<blockquote>
<p>什么是AOP(面向切片编程)？</p>
</blockquote>
<blockquote>
<p>Spring的结构是怎样的？</p>
</blockquote>
<blockquote>
<p>Spring中涉及的设计模式</p>
</blockquote>
<h3 id="计算机网络与Web基础"><a href="#计算机网络与Web基础" class="headerlink" title="计算机网络与Web基础"></a>计算机网络与Web基础</h3><p><strong>推荐书籍：</strong>《深入理解计算机网络》</p>
<p>参考连接：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/network/%E5%B9%B2%E8%B4%A7%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93.md" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/blob/master/docs/network/%E5%B9%B2%E8%B4%A7%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93.md</a></p>
<p>这部分的学习，需要系统性的学习，从网络基础的TCP协议到HTTP协议或SSH服务协议等，理解网络分层模型。</p>
<h3 id="一些工具"><a href="#一些工具" class="headerlink" title="一些工具"></a>一些工具</h3><ul>
<li>git</li>
<li>docker</li>
<li>nginx</li>
<li>…</li>
</ul>
<h3 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h3><blockquote>
<p>三件套HTML、JavaScript、CSS基础</p>
</blockquote>
<blockquote>
<p>利用一些框架如React、Angular、Vue等实现一些简单的前端交互界面。</p>
</blockquote>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><blockquote>
<p>什么是中间件</p>
</blockquote>
<p><img src="http://pzpoejx7j.bkt.clouddn.com/alimiddleware.png" alt="阿里中间件"></p>
<p>目前，它并没有很严格的定义，但是普遍接受IDC的定义：中间件是一种独立的系统软件服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源，中间件位于客户机服务器的操作系统之上，管理计算资源和网络通信。从这个意义上可以用一个等式来表示中间件：中间件=平台+通信，这也就限定了只有用于分布式系统中才能叫中间件，同时也把它与支撑软件和实用软件区分开来。</p>
<blockquote>
<p>中间件分类</p>
</blockquote>
<ul>
<li>底层中间件: 用于支撑单个应用系统或解决单一类问题<ul>
<li>事务处理中间件(TPM)</li>
<li>应用服务器(WAS)</li>
<li>消息中间件(MOM)</li>
<li>数据访问中间件(UDA)</li>
<li>…</li>
</ul>
</li>
<li>高层中间件: 用于系统整合<ul>
<li>企业应用集成中间件(EAI Suites)</li>
<li>工作流中间件(Workflow)</li>
<li>门户中间件(Portal)</li>
<li>…</li>
</ul>
</li>
</ul>
<h3 id="一些测试框架"><a href="#一些测试框架" class="headerlink" title="一些测试框架"></a>一些测试框架</h3><p><strong>不懂测试的开发不是好的开发</strong></p>
<h3 id="学无止境，寻找Java替代品"><a href="#学无止境，寻找Java替代品" class="headerlink" title="学无止境，寻找Java替代品"></a>学无止境，寻找Java替代品</h3><p>大家在学习一门语言要想想这门语言的短处在哪？</p>
<p>建议大家在学习之余，不管你是做算法还是开发，都要努力提升自己的编程能力，推荐学习Nodejs和Golang。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>应用sslh实现多协议访问同一端口</title>
    <url>/2019/10/22/ying-yong-sslh-shi-xian-duo-xie-yi-fang-wen-tong-yi-duan-kou/</url>
    <content><![CDATA[<h2 id="什么是SSLH"><a href="#什么是SSLH" class="headerlink" title="什么是SSLH"></a>什么是SSLH</h2><p>一种不同的multiplexing在相同端口处理多种协议，sslh就是这样可以处理ssl和ssh。sslh可以分辨进入端口的是哪种协议，并转发到相应的服务。这样就可以在同一个端口同时处理http和ssh。注意，这个方法并不是掩藏实际的ssh服务，扫描监听端口的工具scanssh依然可以监听到ssh。<strong>sslh方法可以在防火墙开放较少的端口情况下提供更多的服务。</strong></p>
<p><img src="http://pzpoejx7j.bkt.clouddn.com/sslh.png" alt="sslh"></p>
<h2 id="基本步骤："><a href="#基本步骤：" class="headerlink" title="基本步骤："></a>基本步骤：</h2><a id="more"></a>
<ul>
<li>首先安装web服务器(tomcat, nginx etc.)，使之监听在localhost(default port 80), 当然也可以监听在非标准端口如8088</li>
<li>设置ssh服务端口22的连接，这个端口也可以是任意的，但标准的是22</li>
<li>(optional)创建一个非特权用户 如sslh</li>
<li>安装和启动sslh服务，并监听在端口443，并转发到localhost的http和ssh <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/sbin/sslh-fork -u sslh -p xx.yy.zz.aa:443 --tls 127.0.0.1:2443 --ssh 127.0.0.1:22</span><br></pre></td></tr></table></figure>
 这个ip xx.yy.zz.aa是该服务器的外网ip，如我的10.206.210.235</li>
</ul>
<h2 id="Centos上配置全过程"><a href="#Centos上配置全过程" class="headerlink" title="Centos上配置全过程"></a>Centos上配置全过程</h2><p><strong>在一切开始前请确认服务器的443端口是否对外开放</strong></p>
<h3 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure>
<p>或者使用 <a href="https://openresty.org/cn/" target="_blank" rel="noopener">OpenResty(定制的nginx)</a></p>
<p>创建证书：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/nginx</span><br><span class="line">openssl genrsa -out cert.key 2048</span><br><span class="line">openssl req -new -x509 -key cert.key -out cert.pem -days 3650</span><br></pre></td></tr></table></figure>
<p>配置nginx:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/nginx/conf.d</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<ul>
<li><p>修改default.conf localhost:80<br><img src="/2019/10/22/ying-yong-sslh-shi-xian-duo-xie-yi-fang-wen-tong-yi-duan-kou/1.png" alt="default.conf"></p>
</li>
<li><p>新建sslh.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> vim sslh.conf</span><br><span class="line"> server &#123;</span><br><span class="line">    listen       localhost:443 ssl;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    ssl_certificate      cert.pem;</span><br><span class="line">    ssl_certificate_key  cert.key;</span><br><span class="line"></span><br><span class="line">    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动nginx, 并监听端口443</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -an | grep 443</span><br></pre></td></tr></table></figure>
<p>会看到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcp        0      0 127.0.0.1:443           0.0.0.0:*               LISTEN</span><br></pre></td></tr></table></figure>
<p>表明nginx启动成功，当然你也可以用下面命令查看nginx启动状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status nginx -l</span><br></pre></td></tr></table></figure>

<h3 id="安装sslh"><a href="#安装sslh" class="headerlink" title="安装sslh"></a>安装sslh</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install sslh</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个安装包位于EPEL，所以需要先安装EPEL软件仓库</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>EPEL中，这个sslh配置已经非常完善，配置文件 /etc/sslh.cfg</p>
</blockquote>
<p>修改/etc/sslh.cfg，只需要修改 { host: “SERVER_NAME”; port: “443”; }，这个SERVER_NAME对应的是/etc/hosts中服务器外网的IP地址解析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># This is a basic configuration file that should provide</span><br><span class="line"># sensible values for &quot;standard&quot; setup.</span><br><span class="line"></span><br><span class="line">verbose: false;</span><br><span class="line">foreground: true;</span><br><span class="line">inetd: false;</span><br><span class="line">numeric: false;</span><br><span class="line">transparent: false;</span><br><span class="line">timeout: &quot;2&quot;;</span><br><span class="line">user: &quot;sslh&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Change hostname with your external address name.</span><br><span class="line">listen:</span><br><span class="line">(</span><br><span class="line">    &#123; host: &quot;10.206.210.235&quot;; port: &quot;443&quot;; &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">protocols:</span><br><span class="line">(</span><br><span class="line">     &#123; name: &quot;ssh&quot;; service: &quot;ssh&quot;; host: &quot;localhost&quot;; port: &quot;22&quot;; probe: &quot;builtin&quot;; &#125;,</span><br><span class="line">     &#123; name: &quot;openvpn&quot;; host: &quot;localhost&quot;; port: &quot;1194&quot;; probe: &quot;builtin&quot;; &#125;,</span><br><span class="line">     &#123; name: &quot;xmpp&quot;; host: &quot;localhost&quot;; port: &quot;5222&quot;; probe: &quot;builtin&quot;; &#125;,</span><br><span class="line">     &#123; name: &quot;http&quot;; host: &quot;localhost&quot;; port: &quot;80&quot;; probe: &quot;builtin&quot;; &#125;,</span><br><span class="line">     &#123; name: &quot;ssl&quot;; host: &quot;localhost&quot;; port: &quot;443&quot;; probe: &quot;builtin&quot;; &#125;,</span><br><span class="line">     &#123; name: &quot;anyprot&quot;; host: &quot;localhost&quot;; port: &quot;443&quot;; probe: &quot;builtin&quot;; &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>现在我们准备在443端口上启动sslh，提供HTTPS和SSH的协议转发</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start sslh</span><br><span class="line">systemctl status sslh -l</span><br></pre></td></tr></table></figure>
<p><img src="/2019/10/22/ying-yong-sslh-shi-xian-duo-xie-yi-fang-wen-tong-yi-duan-kou/2.png" alt="sslh启动状态"></p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>在另一台可以ping到该服务器的机器上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh 10.206.210.235 -p 443</span><br></pre></td></tr></table></figure>

<p>浏览器访问：</p>
<blockquote>
<p><a href="https://10.206.210.235加密通道" target="_blank" rel="noopener">https://10.206.210.235加密通道</a></p>
</blockquote>
<blockquote>
<p><a href="http://10.206.210.235:443非加密通道" target="_blank" rel="noopener">http://10.206.210.235:443非加密通道</a></p>
</blockquote>
<p>验证了sslh确实在443端口提供了多种服务。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://huataihuang.gitbooks.io/cloud-atlas/service/ssh/sslh_multi_service_in_one_port.html" target="_blank" rel="noopener">https://huataihuang.gitbooks.io/cloud-atlas/service/ssh/sslh_multi_service_in_one_port.html</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>如何在Hexo博客中插入图片</title>
    <url>/2019/10/21/ru-he-zai-hexo-bo-ke-zhong-cha-ru-tu-pian/</url>
    <content><![CDATA[<p>在hexo博客中插入图片有好几种方法，但本着markdown语言所见即所得的原则，本文选择一种插件方式来显示图片。由于hexo在生成页面时会对文件路径前加入时间，所以直接使用markdown插入图片的方式是不可行的。</p>
<p>参考大佬的插件：<a href="https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="noopener">https://github.com/CodeFalling/hexo-asset-image</a>, 可以使用markdown插入图片的方式，这样可以本地预览也可以在网页浏览。</p>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install  https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="设置-config-yml"><a href="#设置-config-yml" class="headerlink" title="设置_config.yml"></a>设置_config.yml</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="在文章中插入图片"><a href="#在文章中插入图片" class="headerlink" title="在文章中插入图片"></a>在文章中插入图片</h2><p><strong>注意</strong>：<br><img src="/2019/10/21/ru-he-zai-hexo-bo-ke-zhong-cha-ru-tu-pian/1.png" alt="格式要求"></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>valine评论组件使用</title>
    <url>/2019/10/20/valine-ping-lun-zu-jian-shi-yong/</url>
    <content><![CDATA[<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Install leancloud's js-sdk</span></span><br><span class="line">npm install leancloud-storage --save</span><br><span class="line"><span class="comment"># Install valine</span></span><br><span class="line">npm install valine --save</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="参考官方教程：https-valine-js-org-quickstart-html"><a href="#参考官方教程：https-valine-js-org-quickstart-html" class="headerlink" title="参考官方教程：https://valine.js.org/quickstart.html"></a>参考官方教程：<a href="https://valine.js.org/quickstart.html" target="_blank" rel="noopener">https://valine.js.org/quickstart.html</a></h2><p><img src="/2019/10/20/valine-ping-lun-zu-jian-shi-yong/1.png" alt="配置文件图"></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>如何搭建github.io的博客网站</title>
    <url>/2019/10/20/guan-yu-bo-ke-wang-zhan-de-da-jian-bei-wang/</url>
    <content><![CDATA[<h2 id="1-注册github账号"><a href="#1-注册github账号" class="headerlink" title="1. 注册github账号"></a>1. 注册github账号</h2><h2 id="2-创建仓库：github用户名-github-io"><a href="#2-创建仓库：github用户名-github-io" class="headerlink" title="2. 创建仓库：github用户名.github.io"></a>2. 创建仓库：github用户名.github.io</h2><h2 id="3-本地安装node-js、npm"><a href="#3-本地安装node-js、npm" class="headerlink" title="3.本地安装node.js、npm"></a>3.本地安装node.js、npm</h2><h2 id="4-安装git-并配置git-ssh-key"><a href="#4-安装git-并配置git-ssh-key" class="headerlink" title="4.安装git 并配置git ssh key"></a>4.安装git 并配置git ssh key</h2><h2 id="5-绑定域名"><a href="#5-绑定域名" class="headerlink" title="5.绑定域名"></a>5.绑定域名</h2><a id="more"></a>
<h2 id="6-how-use"><a href="#6-how-use" class="headerlink" title="6. how use:"></a>6. how use:</h2><p><strong>refer to:</strong> <a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md</a></p>
<p><strong>change the file _config.xml:</strong><br>first create the reposity: your_github_usrname.github.io</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repository:</span> <span class="attr">https://github.com/your_github_usrname/your_github_usrname.github.io</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<p>then run the following command in terminal(git bash or cmder  etc. on windows or other os)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:njustwh2014/whblogsource.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> whblogsource</span><br><span class="line"></span><br><span class="line">npm install -g hexo</span><br><span class="line"></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line"></span><br><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>配置</tag>
        <tag>记录</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
